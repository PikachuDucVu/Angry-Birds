{"ast":null,"code":"import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n/**\r\n * Quaternion\r\n * @module quat\r\n */\n\n/**\r\n * Creates a new identity quat\r\n *\r\n * @returns {quat} a new quaternion\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Set a quat to the identity quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Sets a quat from the given angle and rotation axis,\r\n * then returns it.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {vec3} axis the axis around which to rotate\r\n * @param {Number} rad the angle in radians\r\n * @returns {quat} out\r\n **/\n\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\r\n * Gets the rotation axis and angle for a given\r\n *  quaternion. If a quaternion is created with\r\n *  setAxisAngle, this method will return the same\r\n *  values as providied in the original parameter list\r\n *  OR functionally equivalent values.\r\n * Example: The quaternion formed by axis [0, 0, 1] and\r\n *  angle -90 is the same as the quaternion formed by\r\n *  [0, 0, 1] and 270. This method favors the latter.\r\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\r\n * @param  {quat} q     Quaternion to be decomposed\r\n * @return {Number}     Angle, in radians, of the rotation\r\n */\n\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\r\n * Multiplies two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n */\n\nexport function multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the X axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Y axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Z axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\r\n * Calculates the W component of a quat from the X, Y, and Z components.\r\n * Assumes that quaternion is 1 unit in length.\r\n * Any existing W component will be ignored.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate W component of\r\n * @returns {quat} out\r\n */\n\nexport function calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\r\n * Performs a spherical linear interpolation between two quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega = void 0,\n      cosom = void 0,\n      sinom = void 0,\n      scale0 = void 0,\n      scale1 = void 0; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\r\n * Generates a random quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\r\n * Calculates the inverse of a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate inverse of\r\n * @returns {quat} out\r\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a quat\r\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate conjugate of\r\n * @returns {quat} out\r\n */\n\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a quaternion from the given 3x3 rotation matrix.\r\n *\r\n * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n * to renormalize the quaternion yourself where necessary.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {mat3} m rotation matrix\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot = void 0;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\r\n * Creates a quaternion from the given euler angle x, y, z.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {x} Angle to rotate around X axis in degrees.\r\n * @param {y} Angle to rotate around Y axis in degrees.\r\n * @param {z} Angle to rotate around Z axis in degrees.\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport function fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\r\n * Returns a string representation of a quatenion\r\n *\r\n * @param {quat} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat} a quaternion to clone\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\nexport var clone = vec4.clone;\n/**\r\n * Creates a new quat initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\nexport var fromValues = vec4.fromValues;\n/**\r\n * Copy the values from one quat to another\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the source quaternion\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var copy = vec4.copy;\n/**\r\n * Set the components of a quat to the given values\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var set = vec4.set;\n/**\r\n * Adds two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var add = vec4.add;\n/**\r\n * Alias for {@link quat.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Scales a quat by a scalar number\r\n *\r\n * @param {quat} out the receiving vector\r\n * @param {quat} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var scale = vec4.scale;\n/**\r\n * Calculates the dot product of two quat's\r\n *\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\nexport var dot = vec4.dot;\n/**\r\n * Performs a linear interpolation between two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var lerp = vec4.lerp;\n/**\r\n * Calculates the length of a quat\r\n *\r\n * @param {quat} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport var length = vec4.length;\n/**\r\n * Alias for {@link quat.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Calculates the squared length of a quat\r\n *\r\n * @param {quat} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nexport var squaredLength = vec4.squaredLength;\n/**\r\n * Alias for {@link quat.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Normalize a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quaternion to normalize\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var normalize = vec4.normalize;\n/**\r\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat} a The first quaternion.\r\n * @param {quat} b The second quaternion.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport var exactEquals = vec4.exactEquals;\n/**\r\n * Returns whether or not the quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat} a The first vector.\r\n * @param {quat} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport var equals = vec4.equals;\n/**\r\n * Sets a quaternion to represent the shortest rotation from one\r\n * vector to another.\r\n *\r\n * Both vectors are assumed to be unit length.\r\n *\r\n * @param {quat} out the receiving quaternion.\r\n * @param {vec3} a the initial vector\r\n * @param {vec3} b the destination vector\r\n * @returns {quat} out\r\n */\n\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\r\n * Performs a spherical linear interpolation with two control points\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {quat} c the third operand\r\n * @param {quat} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\r\n * Sets the specified quaternion with values corresponding to the given\r\n * axes. Each axis is a vec3 and is expected to be unit length and\r\n * perpendicular to all other specified axes.\r\n *\r\n * @param {vec3} view  the vector representing the viewing direction\r\n * @param {vec3} right the vector representing the local \"right\" direction\r\n * @param {vec3} up    the vector representing the local \"up\" direction\r\n * @returns {quat} out\r\n */\n\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();","map":{"version":3,"names":["glMatrix","mat3","vec3","vec4","create","out","ARRAY_TYPE","Float32Array","identity","setAxisAngle","axis","rad","s","Math","sin","cos","getAxisAngle","out_axis","q","acos","EPSILON","multiply","a","b","ax","ay","az","aw","bx","by","bz","bw","rotateX","rotateY","rotateZ","calculateW","x","y","z","sqrt","abs","slerp","t","omega","cosom","sinom","scale0","scale1","random","u1","RANDOM","u2","u3","sqrt1MinusU1","sqrtU1","PI","invert","a0","a1","a2","a3","dot","invDot","conjugate","fromMat3","m","fTrace","fRoot","i","j","k","fromEuler","halfToRad","sx","cx","sy","cy","sz","cz","str","clone","fromValues","copy","set","add","mul","scale","lerp","length","len","squaredLength","sqrLen","normalize","exactEquals","equals","rotationTo","tmpvec3","xUnitVec3","yUnitVec3","cross","sqlerp","temp1","temp2","c","d","setAxes","matr","view","right","up"],"sources":["D:/projects/test-game/node_modules/kami-batch2/node_modules/gl-matrix/lib/gl-matrix/quat.js"],"sourcesContent":["import * as glMatrix from \"./common.js\";\r\nimport * as mat3 from \"./mat3.js\";\r\nimport * as vec3 from \"./vec3.js\";\r\nimport * as vec4 from \"./vec4.js\";\r\n\r\n/**\r\n * Quaternion\r\n * @module quat\r\n */\r\n\r\n/**\r\n * Creates a new identity quat\r\n *\r\n * @returns {quat} a new quaternion\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(4);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[0] = 0;\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n  }\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a quat to the identity quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\r\nexport function identity(out) {\r\n  out[0] = 0;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Sets a quat from the given angle and rotation axis,\r\n * then returns it.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {vec3} axis the axis around which to rotate\r\n * @param {Number} rad the angle in radians\r\n * @returns {quat} out\r\n **/\r\nexport function setAxisAngle(out, axis, rad) {\r\n  rad = rad * 0.5;\r\n  var s = Math.sin(rad);\r\n  out[0] = s * axis[0];\r\n  out[1] = s * axis[1];\r\n  out[2] = s * axis[2];\r\n  out[3] = Math.cos(rad);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Gets the rotation axis and angle for a given\r\n *  quaternion. If a quaternion is created with\r\n *  setAxisAngle, this method will return the same\r\n *  values as providied in the original parameter list\r\n *  OR functionally equivalent values.\r\n * Example: The quaternion formed by axis [0, 0, 1] and\r\n *  angle -90 is the same as the quaternion formed by\r\n *  [0, 0, 1] and 270. This method favors the latter.\r\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\r\n * @param  {quat} q     Quaternion to be decomposed\r\n * @return {Number}     Angle, in radians, of the rotation\r\n */\r\nexport function getAxisAngle(out_axis, q) {\r\n  var rad = Math.acos(q[3]) * 2.0;\r\n  var s = Math.sin(rad / 2.0);\r\n  if (s > glMatrix.EPSILON) {\r\n    out_axis[0] = q[0] / s;\r\n    out_axis[1] = q[1] / s;\r\n    out_axis[2] = q[2] / s;\r\n  } else {\r\n    // If s is zero, return any axis (no rotation - axis does not matter)\r\n    out_axis[0] = 1;\r\n    out_axis[1] = 0;\r\n    out_axis[2] = 0;\r\n  }\r\n  return rad;\r\n}\r\n\r\n/**\r\n * Multiplies two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bx = b[0],\r\n      by = b[1],\r\n      bz = b[2],\r\n      bw = b[3];\r\n\r\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\r\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\r\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\r\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a quaternion by the given angle about the X axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\r\nexport function rotateX(out, a, rad) {\r\n  rad *= 0.5;\r\n\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bx = Math.sin(rad),\r\n      bw = Math.cos(rad);\r\n\r\n  out[0] = ax * bw + aw * bx;\r\n  out[1] = ay * bw + az * bx;\r\n  out[2] = az * bw - ay * bx;\r\n  out[3] = aw * bw - ax * bx;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a quaternion by the given angle about the Y axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\r\nexport function rotateY(out, a, rad) {\r\n  rad *= 0.5;\r\n\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var by = Math.sin(rad),\r\n      bw = Math.cos(rad);\r\n\r\n  out[0] = ax * bw - az * by;\r\n  out[1] = ay * bw + aw * by;\r\n  out[2] = az * bw + ax * by;\r\n  out[3] = aw * bw - ay * by;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a quaternion by the given angle about the Z axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\r\nexport function rotateZ(out, a, rad) {\r\n  rad *= 0.5;\r\n\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bz = Math.sin(rad),\r\n      bw = Math.cos(rad);\r\n\r\n  out[0] = ax * bw + ay * bz;\r\n  out[1] = ay * bw - ax * bz;\r\n  out[2] = az * bw + aw * bz;\r\n  out[3] = aw * bw - az * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the W component of a quat from the X, Y, and Z components.\r\n * Assumes that quaternion is 1 unit in length.\r\n * Any existing W component will be ignored.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate W component of\r\n * @returns {quat} out\r\n */\r\nexport function calculateW(out, a) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a spherical linear interpolation between two quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\r\nexport function slerp(out, a, b, t) {\r\n  // benchmarks:\r\n  //    http://jsperf.com/quaternion-slerp-implementations\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bx = b[0],\r\n      by = b[1],\r\n      bz = b[2],\r\n      bw = b[3];\r\n\r\n  var omega = void 0,\r\n      cosom = void 0,\r\n      sinom = void 0,\r\n      scale0 = void 0,\r\n      scale1 = void 0;\r\n\r\n  // calc cosine\r\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\r\n  // adjust signs (if necessary)\r\n  if (cosom < 0.0) {\r\n    cosom = -cosom;\r\n    bx = -bx;\r\n    by = -by;\r\n    bz = -bz;\r\n    bw = -bw;\r\n  }\r\n  // calculate coefficients\r\n  if (1.0 - cosom > glMatrix.EPSILON) {\r\n    // standard case (slerp)\r\n    omega = Math.acos(cosom);\r\n    sinom = Math.sin(omega);\r\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\r\n    scale1 = Math.sin(t * omega) / sinom;\r\n  } else {\r\n    // \"from\" and \"to\" quaternions are very close\r\n    //  ... so we can do a linear interpolation\r\n    scale0 = 1.0 - t;\r\n    scale1 = t;\r\n  }\r\n  // calculate final values\r\n  out[0] = scale0 * ax + scale1 * bx;\r\n  out[1] = scale0 * ay + scale1 * by;\r\n  out[2] = scale0 * az + scale1 * bz;\r\n  out[3] = scale0 * aw + scale1 * bw;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a random quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\r\nexport function random(out) {\r\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\r\n  // TODO: Calling random 3 times is probably not the fastest solution\r\n  var u1 = glMatrix.RANDOM();\r\n  var u2 = glMatrix.RANDOM();\r\n  var u3 = glMatrix.RANDOM();\r\n\r\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\r\n  var sqrtU1 = Math.sqrt(u1);\r\n\r\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\r\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\r\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\r\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the inverse of a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate inverse of\r\n * @returns {quat} out\r\n */\r\nexport function invert(out, a) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\r\n  var invDot = dot ? 1.0 / dot : 0;\r\n\r\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\r\n\r\n  out[0] = -a0 * invDot;\r\n  out[1] = -a1 * invDot;\r\n  out[2] = -a2 * invDot;\r\n  out[3] = a3 * invDot;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the conjugate of a quat\r\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate conjugate of\r\n * @returns {quat} out\r\n */\r\nexport function conjugate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from the given 3x3 rotation matrix.\r\n *\r\n * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n * to renormalize the quaternion yourself where necessary.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {mat3} m rotation matrix\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport function fromMat3(out, m) {\r\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\r\n  // article \"Quaternion Calculus and Fast Animation\".\r\n  var fTrace = m[0] + m[4] + m[8];\r\n  var fRoot = void 0;\r\n\r\n  if (fTrace > 0.0) {\r\n    // |w| > 1/2, may as well choose w > 1/2\r\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\r\n    out[3] = 0.5 * fRoot;\r\n    fRoot = 0.5 / fRoot; // 1/(4w)\r\n    out[0] = (m[5] - m[7]) * fRoot;\r\n    out[1] = (m[6] - m[2]) * fRoot;\r\n    out[2] = (m[1] - m[3]) * fRoot;\r\n  } else {\r\n    // |w| <= 1/2\r\n    var i = 0;\r\n    if (m[4] > m[0]) i = 1;\r\n    if (m[8] > m[i * 3 + i]) i = 2;\r\n    var j = (i + 1) % 3;\r\n    var k = (i + 2) % 3;\r\n\r\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\r\n    out[i] = 0.5 * fRoot;\r\n    fRoot = 0.5 / fRoot;\r\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\r\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\r\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from the given euler angle x, y, z.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {x} Angle to rotate around X axis in degrees.\r\n * @param {y} Angle to rotate around Y axis in degrees.\r\n * @param {z} Angle to rotate around Z axis in degrees.\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport function fromEuler(out, x, y, z) {\r\n  var halfToRad = 0.5 * Math.PI / 180.0;\r\n  x *= halfToRad;\r\n  y *= halfToRad;\r\n  z *= halfToRad;\r\n\r\n  var sx = Math.sin(x);\r\n  var cx = Math.cos(x);\r\n  var sy = Math.sin(y);\r\n  var cy = Math.cos(y);\r\n  var sz = Math.sin(z);\r\n  var cz = Math.cos(z);\r\n\r\n  out[0] = sx * cy * cz - cx * sy * sz;\r\n  out[1] = cx * sy * cz + sx * cy * sz;\r\n  out[2] = cx * cy * sz - sx * sy * cz;\r\n  out[3] = cx * cy * cz + sx * sy * sz;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a quatenion\r\n *\r\n * @param {quat} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\r\nexport function str(a) {\r\n  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\r\n}\r\n\r\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat} a quaternion to clone\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\r\nexport var clone = vec4.clone;\r\n\r\n/**\r\n * Creates a new quat initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\r\nexport var fromValues = vec4.fromValues;\r\n\r\n/**\r\n * Copy the values from one quat to another\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the source quaternion\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var copy = vec4.copy;\r\n\r\n/**\r\n * Set the components of a quat to the given values\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var set = vec4.set;\r\n\r\n/**\r\n * Adds two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var add = vec4.add;\r\n\r\n/**\r\n * Alias for {@link quat.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Scales a quat by a scalar number\r\n *\r\n * @param {quat} out the receiving vector\r\n * @param {quat} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var scale = vec4.scale;\r\n\r\n/**\r\n * Calculates the dot product of two quat's\r\n *\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\r\nexport var dot = vec4.dot;\r\n\r\n/**\r\n * Performs a linear interpolation between two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var lerp = vec4.lerp;\r\n\r\n/**\r\n * Calculates the length of a quat\r\n *\r\n * @param {quat} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nexport var length = vec4.length;\r\n\r\n/**\r\n * Alias for {@link quat.length}\r\n * @function\r\n */\r\nexport var len = length;\r\n\r\n/**\r\n * Calculates the squared length of a quat\r\n *\r\n * @param {quat} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\r\nexport var squaredLength = vec4.squaredLength;\r\n\r\n/**\r\n * Alias for {@link quat.squaredLength}\r\n * @function\r\n */\r\nexport var sqrLen = squaredLength;\r\n\r\n/**\r\n * Normalize a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quaternion to normalize\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var normalize = vec4.normalize;\r\n\r\n/**\r\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat} a The first quaternion.\r\n * @param {quat} b The second quaternion.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport var exactEquals = vec4.exactEquals;\r\n\r\n/**\r\n * Returns whether or not the quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat} a The first vector.\r\n * @param {quat} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport var equals = vec4.equals;\r\n\r\n/**\r\n * Sets a quaternion to represent the shortest rotation from one\r\n * vector to another.\r\n *\r\n * Both vectors are assumed to be unit length.\r\n *\r\n * @param {quat} out the receiving quaternion.\r\n * @param {vec3} a the initial vector\r\n * @param {vec3} b the destination vector\r\n * @returns {quat} out\r\n */\r\nexport var rotationTo = function () {\r\n  var tmpvec3 = vec3.create();\r\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\r\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\r\n\r\n  return function (out, a, b) {\r\n    var dot = vec3.dot(a, b);\r\n    if (dot < -0.999999) {\r\n      vec3.cross(tmpvec3, xUnitVec3, a);\r\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\r\n      vec3.normalize(tmpvec3, tmpvec3);\r\n      setAxisAngle(out, tmpvec3, Math.PI);\r\n      return out;\r\n    } else if (dot > 0.999999) {\r\n      out[0] = 0;\r\n      out[1] = 0;\r\n      out[2] = 0;\r\n      out[3] = 1;\r\n      return out;\r\n    } else {\r\n      vec3.cross(tmpvec3, a, b);\r\n      out[0] = tmpvec3[0];\r\n      out[1] = tmpvec3[1];\r\n      out[2] = tmpvec3[2];\r\n      out[3] = 1 + dot;\r\n      return normalize(out, out);\r\n    }\r\n  };\r\n}();\r\n\r\n/**\r\n * Performs a spherical linear interpolation with two control points\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {quat} c the third operand\r\n * @param {quat} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\r\nexport var sqlerp = function () {\r\n  var temp1 = create();\r\n  var temp2 = create();\r\n\r\n  return function (out, a, b, c, d, t) {\r\n    slerp(temp1, a, d, t);\r\n    slerp(temp2, b, c, t);\r\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\r\n\r\n    return out;\r\n  };\r\n}();\r\n\r\n/**\r\n * Sets the specified quaternion with values corresponding to the given\r\n * axes. Each axis is a vec3 and is expected to be unit length and\r\n * perpendicular to all other specified axes.\r\n *\r\n * @param {vec3} view  the vector representing the viewing direction\r\n * @param {vec3} right the vector representing the local \"right\" direction\r\n * @param {vec3} up    the vector representing the local \"up\" direction\r\n * @returns {quat} out\r\n */\r\nexport var setAxes = function () {\r\n  var matr = mat3.create();\r\n\r\n  return function (out, view, right, up) {\r\n    matr[0] = right[0];\r\n    matr[3] = right[1];\r\n    matr[6] = right[2];\r\n\r\n    matr[1] = up[0];\r\n    matr[4] = up[1];\r\n    matr[7] = up[2];\r\n\r\n    matr[2] = -view[0];\r\n    matr[5] = -view[1];\r\n    matr[8] = -view[2];\r\n\r\n    return normalize(out, fromMat3(out, matr));\r\n  };\r\n}();"],"mappings":"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sCA,CAAC,CAAC,CAAD,CAAvC,GAA6C,IAA7C,GAAoDA,CAAC,CAAC,CAAD,CAArD,GAA2D,GAAlE;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAI0D,KAAK,GAAG7E,IAAI,CAAC6E,KAAjB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,UAAU,GAAG9E,IAAI,CAAC8E,UAAtB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,IAAI,GAAG/E,IAAI,CAAC+E,IAAhB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,GAAG,GAAGhF,IAAI,CAACgF,GAAf;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,GAAG,GAAGjF,IAAI,CAACiF,GAAf;AAEP;AACA;AACA;AACA;;AACA,OAAO,IAAIC,GAAG,GAAGhE,QAAV;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIiE,KAAK,GAAGnF,IAAI,CAACmF,KAAjB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIzB,GAAG,GAAG1D,IAAI,CAAC0D,GAAf;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAI0B,IAAI,GAAGpF,IAAI,CAACoF,IAAhB;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,MAAM,GAAGrF,IAAI,CAACqF,MAAlB;AAEP;AACA;AACA;AACA;;AACA,OAAO,IAAIC,GAAG,GAAGD,MAAV;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIE,aAAa,GAAGvF,IAAI,CAACuF,aAAzB;AAEP;AACA;AACA;AACA;;AACA,OAAO,IAAIC,MAAM,GAAGD,aAAb;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIE,SAAS,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"},"metadata":{},"sourceType":"module"}