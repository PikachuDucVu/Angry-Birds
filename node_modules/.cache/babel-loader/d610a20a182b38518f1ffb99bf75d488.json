{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _classCallCheck = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Color2Attribute = exports.ColorAttribute = exports.TexCoordAttribute = exports.Position3Attribute = exports.Position2Attribute = exports.VertexAttribute = exports.VertexAttributeType = exports.Mesh = void 0;\n\nvar Shader_1 = require(\"./Shader\");\n\nvar Mesh = /*#__PURE__*/function () {\n  function Mesh(context, attributes, maxVertices, maxIndices) {\n    _classCallCheck(this, Mesh);\n\n    this.attributes = attributes;\n    this.verticesLength = 0;\n    this.dirtyVertices = false;\n    this.indicesLength = 0;\n    this.dirtyIndices = false;\n    this.elementsPerVertex = 0;\n    this.context = context;\n    this.elementsPerVertex = 0;\n\n    for (var i = 0; i < attributes.length; i++) {\n      this.elementsPerVertex += attributes[i].numElements;\n    }\n\n    this.vertices = new Float32Array(maxVertices * this.elementsPerVertex);\n    this.indices = new Uint16Array(maxIndices);\n  }\n\n  _createClass(Mesh, [{\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"maxVertices\",\n    value: function maxVertices() {\n      return this.vertices.length / this.elementsPerVertex;\n    }\n  }, {\n    key: \"numVertices\",\n    value: function numVertices() {\n      return this.verticesLength / this.elementsPerVertex;\n    }\n  }, {\n    key: \"setVerticesLength\",\n    value: function setVerticesLength(length) {\n      this.dirtyVertices = true;\n      this.verticesLength = length;\n    }\n  }, {\n    key: \"getVertices\",\n    value: function getVertices() {\n      return this.vertices;\n    }\n  }, {\n    key: \"maxIndices\",\n    value: function maxIndices() {\n      return this.indices.length;\n    }\n  }, {\n    key: \"numIndices\",\n    value: function numIndices() {\n      return this.indicesLength;\n    }\n  }, {\n    key: \"setIndicesLength\",\n    value: function setIndicesLength(length) {\n      this.dirtyIndices = true;\n      this.indicesLength = length;\n    }\n  }, {\n    key: \"getIndices\",\n    value: function getIndices() {\n      return this.indices;\n    }\n  }, {\n    key: \"getVertexSizeInFloats\",\n    value: function getVertexSizeInFloats() {\n      var size = 0;\n\n      for (var i = 0; i < this.attributes.length; i++) {\n        var attribute = this.attributes[i];\n        size += attribute.numElements;\n      }\n\n      return size;\n    }\n  }, {\n    key: \"setVertices\",\n    value: function setVertices(vertices) {\n      this.dirtyVertices = true;\n      if (vertices.length > this.vertices.length) throw Error(\"Mesh can't store more than \" + this.maxVertices() + ' vertices');\n      this.vertices.set(vertices, 0);\n      this.verticesLength = vertices.length;\n    }\n  }, {\n    key: \"setIndices\",\n    value: function setIndices(indices) {\n      this.dirtyIndices = true;\n      if (indices.length > this.indices.length) throw Error(\"Mesh can't store more than \" + this.maxIndices() + ' indices');\n      this.indices.set(indices, 0);\n      this.indicesLength = indices.length;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(shader, primitiveType) {\n      this.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);\n    }\n  }, {\n    key: \"drawWithOffset\",\n    value: function drawWithOffset(shader, primitiveType, offset, count) {\n      var gl = this.context;\n      if (this.dirtyVertices || this.dirtyIndices) this.update();\n      this.bind(shader);\n\n      if (this.indicesLength > 0) {\n        gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);\n      } else {\n        gl.drawArrays(primitiveType, offset, count);\n      }\n\n      this.unbind(shader);\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(shader) {\n      var gl = this.context;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n      var offset = 0;\n\n      for (var i = 0; i < this.attributes.length; i++) {\n        var attrib = this.attributes[i];\n        var location = shader.getAttributeLocation(attrib.name);\n        gl.enableVertexAttribArray(location);\n        gl.vertexAttribPointer(location, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);\n        offset += attrib.numElements;\n      }\n\n      if (this.indicesLength > 0) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(shader) {\n      var gl = this.context;\n\n      for (var i = 0; i < this.attributes.length; i++) {\n        var attrib = this.attributes[i];\n        var location = shader.getAttributeLocation(attrib.name);\n        gl.disableVertexAttribArray(location);\n      }\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      if (this.indicesLength > 0) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var gl = this.context;\n\n      if (this.dirtyVertices) {\n        if (!this.verticesBuffer) {\n          this.verticesBuffer = gl.createBuffer();\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);\n        this.dirtyVertices = false;\n      }\n\n      if (this.dirtyIndices) {\n        if (!this.indicesBuffer) {\n          this.indicesBuffer = gl.createBuffer();\n        }\n\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);\n        this.dirtyIndices = false;\n      }\n    }\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      this.verticesBuffer = null;\n      this.indicesBuffer = null;\n      this.update();\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var gl = this.context;\n      gl.deleteBuffer(this.verticesBuffer);\n      gl.deleteBuffer(this.indicesBuffer);\n    }\n  }]);\n\n  return Mesh;\n}();\n\nexports.Mesh = Mesh;\nvar VertexAttributeType;\n\n(function (VertexAttributeType) {\n  VertexAttributeType[VertexAttributeType[\"Float\"] = 0] = \"Float\";\n})(VertexAttributeType = exports.VertexAttributeType || (exports.VertexAttributeType = {}));\n\nvar VertexAttribute = /*#__PURE__*/_createClass(function VertexAttribute(name, type, numElements) {\n  _classCallCheck(this, VertexAttribute);\n\n  this.name = name;\n  this.type = type;\n  this.numElements = numElements;\n});\n\nexports.VertexAttribute = VertexAttribute;\n\nvar Position2Attribute = /*#__PURE__*/function (_VertexAttribute) {\n  _inherits(Position2Attribute, _VertexAttribute);\n\n  var _super = _createSuper(Position2Attribute);\n\n  function Position2Attribute() {\n    _classCallCheck(this, Position2Attribute);\n\n    return _super.call(this, Shader_1.Shader.POSITION, VertexAttributeType.Float, 2);\n  }\n\n  return _createClass(Position2Attribute);\n}(VertexAttribute);\n\nexports.Position2Attribute = Position2Attribute;\n\nvar Position3Attribute = /*#__PURE__*/function (_VertexAttribute2) {\n  _inherits(Position3Attribute, _VertexAttribute2);\n\n  var _super2 = _createSuper(Position3Attribute);\n\n  function Position3Attribute() {\n    _classCallCheck(this, Position3Attribute);\n\n    return _super2.call(this, Shader_1.Shader.POSITION, VertexAttributeType.Float, 3);\n  }\n\n  return _createClass(Position3Attribute);\n}(VertexAttribute);\n\nexports.Position3Attribute = Position3Attribute;\n\nvar TexCoordAttribute = /*#__PURE__*/function (_VertexAttribute3) {\n  _inherits(TexCoordAttribute, _VertexAttribute3);\n\n  var _super3 = _createSuper(TexCoordAttribute);\n\n  function TexCoordAttribute() {\n    var unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    _classCallCheck(this, TexCoordAttribute);\n\n    return _super3.call(this, Shader_1.Shader.TEXCOORDS + (unit === 0 ? '' : unit), VertexAttributeType.Float, 2);\n  }\n\n  return _createClass(TexCoordAttribute);\n}(VertexAttribute);\n\nexports.TexCoordAttribute = TexCoordAttribute;\n\nvar ColorAttribute = /*#__PURE__*/function (_VertexAttribute4) {\n  _inherits(ColorAttribute, _VertexAttribute4);\n\n  var _super4 = _createSuper(ColorAttribute);\n\n  function ColorAttribute() {\n    _classCallCheck(this, ColorAttribute);\n\n    return _super4.call(this, Shader_1.Shader.COLOR, VertexAttributeType.Float, 4);\n  }\n\n  return _createClass(ColorAttribute);\n}(VertexAttribute);\n\nexports.ColorAttribute = ColorAttribute;\n\nvar Color2Attribute = /*#__PURE__*/function (_VertexAttribute5) {\n  _inherits(Color2Attribute, _VertexAttribute5);\n\n  var _super5 = _createSuper(Color2Attribute);\n\n  function Color2Attribute() {\n    _classCallCheck(this, Color2Attribute);\n\n    return _super5.call(this, Shader_1.Shader.COLOR2, VertexAttributeType.Float, 4);\n  }\n\n  return _createClass(Color2Attribute);\n}(VertexAttribute);\n\nexports.Color2Attribute = Color2Attribute;","map":{"version":3,"names":["Object","defineProperty","exports","value","Color2Attribute","ColorAttribute","TexCoordAttribute","Position3Attribute","Position2Attribute","VertexAttribute","VertexAttributeType","Mesh","Shader_1","require","context","attributes","maxVertices","maxIndices","verticesLength","dirtyVertices","indicesLength","dirtyIndices","elementsPerVertex","i","length","numElements","vertices","Float32Array","indices","Uint16Array","size","attribute","Error","set","shader","primitiveType","drawWithOffset","offset","count","gl","update","bind","drawElements","UNSIGNED_SHORT","drawArrays","unbind","bindBuffer","ARRAY_BUFFER","verticesBuffer","attrib","location","getAttributeLocation","name","enableVertexAttribArray","vertexAttribPointer","FLOAT","ELEMENT_ARRAY_BUFFER","indicesBuffer","disableVertexAttribArray","createBuffer","bufferData","subarray","DYNAMIC_DRAW","deleteBuffer","type","Shader","POSITION","Float","unit","TEXCOORDS","COLOR","COLOR2"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/Mesh.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Color2Attribute = exports.ColorAttribute = exports.TexCoordAttribute = exports.Position3Attribute = exports.Position2Attribute = exports.VertexAttribute = exports.VertexAttributeType = exports.Mesh = void 0;\r\nconst Shader_1 = require(\"./Shader\");\r\nclass Mesh {\r\n    constructor(context, attributes, maxVertices, maxIndices) {\r\n        this.attributes = attributes;\r\n        this.verticesLength = 0;\r\n        this.dirtyVertices = false;\r\n        this.indicesLength = 0;\r\n        this.dirtyIndices = false;\r\n        this.elementsPerVertex = 0;\r\n        this.context = context;\r\n        this.elementsPerVertex = 0;\r\n        for (let i = 0; i < attributes.length; i++) {\r\n            this.elementsPerVertex += attributes[i].numElements;\r\n        }\r\n        this.vertices = new Float32Array(maxVertices * this.elementsPerVertex);\r\n        this.indices = new Uint16Array(maxIndices);\r\n    }\r\n    getAttributes() {\r\n        return this.attributes;\r\n    }\r\n    maxVertices() {\r\n        return this.vertices.length / this.elementsPerVertex;\r\n    }\r\n    numVertices() {\r\n        return this.verticesLength / this.elementsPerVertex;\r\n    }\r\n    setVerticesLength(length) {\r\n        this.dirtyVertices = true;\r\n        this.verticesLength = length;\r\n    }\r\n    getVertices() {\r\n        return this.vertices;\r\n    }\r\n    maxIndices() {\r\n        return this.indices.length;\r\n    }\r\n    numIndices() {\r\n        return this.indicesLength;\r\n    }\r\n    setIndicesLength(length) {\r\n        this.dirtyIndices = true;\r\n        this.indicesLength = length;\r\n    }\r\n    getIndices() {\r\n        return this.indices;\r\n    }\r\n    getVertexSizeInFloats() {\r\n        let size = 0;\r\n        for (var i = 0; i < this.attributes.length; i++) {\r\n            let attribute = this.attributes[i];\r\n            size += attribute.numElements;\r\n        }\r\n        return size;\r\n    }\r\n    setVertices(vertices) {\r\n        this.dirtyVertices = true;\r\n        if (vertices.length > this.vertices.length)\r\n            throw Error(\"Mesh can't store more than \" + this.maxVertices() + ' vertices');\r\n        this.vertices.set(vertices, 0);\r\n        this.verticesLength = vertices.length;\r\n    }\r\n    setIndices(indices) {\r\n        this.dirtyIndices = true;\r\n        if (indices.length > this.indices.length)\r\n            throw Error(\"Mesh can't store more than \" + this.maxIndices() + ' indices');\r\n        this.indices.set(indices, 0);\r\n        this.indicesLength = indices.length;\r\n    }\r\n    draw(shader, primitiveType) {\r\n        this.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);\r\n    }\r\n    drawWithOffset(shader, primitiveType, offset, count) {\r\n        let gl = this.context;\r\n        if (this.dirtyVertices || this.dirtyIndices)\r\n            this.update();\r\n        this.bind(shader);\r\n        if (this.indicesLength > 0) {\r\n            gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);\r\n        }\r\n        else {\r\n            gl.drawArrays(primitiveType, offset, count);\r\n        }\r\n        this.unbind(shader);\r\n    }\r\n    bind(shader) {\r\n        let gl = this.context;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\r\n        let offset = 0;\r\n        for (let i = 0; i < this.attributes.length; i++) {\r\n            let attrib = this.attributes[i];\r\n            let location = shader.getAttributeLocation(attrib.name);\r\n            gl.enableVertexAttribArray(location);\r\n            gl.vertexAttribPointer(location, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);\r\n            offset += attrib.numElements;\r\n        }\r\n        if (this.indicesLength > 0)\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n    }\r\n    unbind(shader) {\r\n        let gl = this.context;\r\n        for (let i = 0; i < this.attributes.length; i++) {\r\n            let attrib = this.attributes[i];\r\n            let location = shader.getAttributeLocation(attrib.name);\r\n            gl.disableVertexAttribArray(location);\r\n        }\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        if (this.indicesLength > 0)\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n    update() {\r\n        let gl = this.context;\r\n        if (this.dirtyVertices) {\r\n            if (!this.verticesBuffer) {\r\n                this.verticesBuffer = gl.createBuffer();\r\n            }\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);\r\n            this.dirtyVertices = false;\r\n        }\r\n        if (this.dirtyIndices) {\r\n            if (!this.indicesBuffer) {\r\n                this.indicesBuffer = gl.createBuffer();\r\n            }\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);\r\n            this.dirtyIndices = false;\r\n        }\r\n    }\r\n    restore() {\r\n        this.verticesBuffer = null;\r\n        this.indicesBuffer = null;\r\n        this.update();\r\n    }\r\n    dispose() {\r\n        let gl = this.context;\r\n        gl.deleteBuffer(this.verticesBuffer);\r\n        gl.deleteBuffer(this.indicesBuffer);\r\n    }\r\n}\r\nexports.Mesh = Mesh;\r\nvar VertexAttributeType;\r\n(function (VertexAttributeType) {\r\n    VertexAttributeType[VertexAttributeType[\"Float\"] = 0] = \"Float\";\r\n})(VertexAttributeType = exports.VertexAttributeType || (exports.VertexAttributeType = {}));\r\nclass VertexAttribute {\r\n    constructor(name, type, numElements) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.numElements = numElements;\r\n    }\r\n}\r\nexports.VertexAttribute = VertexAttribute;\r\nclass Position2Attribute extends VertexAttribute {\r\n    constructor() {\r\n        super(Shader_1.Shader.POSITION, VertexAttributeType.Float, 2);\r\n    }\r\n}\r\nexports.Position2Attribute = Position2Attribute;\r\nclass Position3Attribute extends VertexAttribute {\r\n    constructor() {\r\n        super(Shader_1.Shader.POSITION, VertexAttributeType.Float, 3);\r\n    }\r\n}\r\nexports.Position3Attribute = Position3Attribute;\r\nclass TexCoordAttribute extends VertexAttribute {\r\n    constructor(unit = 0) {\r\n        super(Shader_1.Shader.TEXCOORDS + (unit === 0 ? '' : unit), VertexAttributeType.Float, 2);\r\n    }\r\n}\r\nexports.TexCoordAttribute = TexCoordAttribute;\r\nclass ColorAttribute extends VertexAttribute {\r\n    constructor() {\r\n        super(Shader_1.Shader.COLOR, VertexAttributeType.Float, 4);\r\n    }\r\n}\r\nexports.ColorAttribute = ColorAttribute;\r\nclass Color2Attribute extends VertexAttribute {\r\n    constructor() {\r\n        super(Shader_1.Shader.COLOR2, VertexAttributeType.Float, 4);\r\n    }\r\n}\r\nexports.Color2Attribute = Color2Attribute;\r\n"],"mappings":"AAAA;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0BF,OAAO,CAACG,cAAR,GAAyBH,OAAO,CAACI,iBAAR,GAA4BJ,OAAO,CAACK,kBAAR,GAA6BL,OAAO,CAACM,kBAAR,GAA6BN,OAAO,CAACO,eAAR,GAA0BP,OAAO,CAACQ,mBAAR,GAA8BR,OAAO,CAACS,IAAR,GAAe,KAAK,CAArN;;AACA,IAAMC,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;IACMF,I;EACF,cAAYG,OAAZ,EAAqBC,UAArB,EAAiCC,WAAjC,EAA8CC,UAA9C,EAA0D;IAAA;;IACtD,KAAKF,UAAL,GAAkBA,UAAlB;IACA,KAAKG,cAAL,GAAsB,CAAtB;IACA,KAAKC,aAAL,GAAqB,KAArB;IACA,KAAKC,aAAL,GAAqB,CAArB;IACA,KAAKC,YAAL,GAAoB,KAApB;IACA,KAAKC,iBAAL,GAAyB,CAAzB;IACA,KAAKR,OAAL,GAAeA,OAAf;IACA,KAAKQ,iBAAL,GAAyB,CAAzB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,UAAU,CAACS,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;MACxC,KAAKD,iBAAL,IAA0BP,UAAU,CAACQ,CAAD,CAAV,CAAcE,WAAxC;IACH;;IACD,KAAKC,QAAL,GAAgB,IAAIC,YAAJ,CAAiBX,WAAW,GAAG,KAAKM,iBAApC,CAAhB;IACA,KAAKM,OAAL,GAAe,IAAIC,WAAJ,CAAgBZ,UAAhB,CAAf;EACH;;;;WACD,yBAAgB;MACZ,OAAO,KAAKF,UAAZ;IACH;;;WACD,uBAAc;MACV,OAAO,KAAKW,QAAL,CAAcF,MAAd,GAAuB,KAAKF,iBAAnC;IACH;;;WACD,uBAAc;MACV,OAAO,KAAKJ,cAAL,GAAsB,KAAKI,iBAAlC;IACH;;;WACD,2BAAkBE,MAAlB,EAA0B;MACtB,KAAKL,aAAL,GAAqB,IAArB;MACA,KAAKD,cAAL,GAAsBM,MAAtB;IACH;;;WACD,uBAAc;MACV,OAAO,KAAKE,QAAZ;IACH;;;WACD,sBAAa;MACT,OAAO,KAAKE,OAAL,CAAaJ,MAApB;IACH;;;WACD,sBAAa;MACT,OAAO,KAAKJ,aAAZ;IACH;;;WACD,0BAAiBI,MAAjB,EAAyB;MACrB,KAAKH,YAAL,GAAoB,IAApB;MACA,KAAKD,aAAL,GAAqBI,MAArB;IACH;;;WACD,sBAAa;MACT,OAAO,KAAKI,OAAZ;IACH;;;WACD,iCAAwB;MACpB,IAAIE,IAAI,GAAG,CAAX;;MACA,KAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKR,UAAL,CAAgBS,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;QAC7C,IAAIQ,SAAS,GAAG,KAAKhB,UAAL,CAAgBQ,CAAhB,CAAhB;QACAO,IAAI,IAAIC,SAAS,CAACN,WAAlB;MACH;;MACD,OAAOK,IAAP;IACH;;;WACD,qBAAYJ,QAAZ,EAAsB;MAClB,KAAKP,aAAL,GAAqB,IAArB;MACA,IAAIO,QAAQ,CAACF,MAAT,GAAkB,KAAKE,QAAL,CAAcF,MAApC,EACI,MAAMQ,KAAK,CAAC,gCAAgC,KAAKhB,WAAL,EAAhC,GAAqD,WAAtD,CAAX;MACJ,KAAKU,QAAL,CAAcO,GAAd,CAAkBP,QAAlB,EAA4B,CAA5B;MACA,KAAKR,cAAL,GAAsBQ,QAAQ,CAACF,MAA/B;IACH;;;WACD,oBAAWI,OAAX,EAAoB;MAChB,KAAKP,YAAL,GAAoB,IAApB;MACA,IAAIO,OAAO,CAACJ,MAAR,GAAiB,KAAKI,OAAL,CAAaJ,MAAlC,EACI,MAAMQ,KAAK,CAAC,gCAAgC,KAAKf,UAAL,EAAhC,GAAoD,UAArD,CAAX;MACJ,KAAKW,OAAL,CAAaK,GAAb,CAAiBL,OAAjB,EAA0B,CAA1B;MACA,KAAKR,aAAL,GAAqBQ,OAAO,CAACJ,MAA7B;IACH;;;WACD,cAAKU,MAAL,EAAaC,aAAb,EAA4B;MACxB,KAAKC,cAAL,CAAoBF,MAApB,EAA4BC,aAA5B,EAA2C,CAA3C,EAA8C,KAAKf,aAAL,GAAqB,CAArB,GAAyB,KAAKA,aAA9B,GAA8C,KAAKF,cAAL,GAAsB,KAAKI,iBAAvH;IACH;;;WACD,wBAAeY,MAAf,EAAuBC,aAAvB,EAAsCE,MAAtC,EAA8CC,KAA9C,EAAqD;MACjD,IAAIC,EAAE,GAAG,KAAKzB,OAAd;MACA,IAAI,KAAKK,aAAL,IAAsB,KAAKE,YAA/B,EACI,KAAKmB,MAAL;MACJ,KAAKC,IAAL,CAAUP,MAAV;;MACA,IAAI,KAAKd,aAAL,GAAqB,CAAzB,EAA4B;QACxBmB,EAAE,CAACG,YAAH,CAAgBP,aAAhB,EAA+BG,KAA/B,EAAsCC,EAAE,CAACI,cAAzC,EAAyDN,MAAM,GAAG,CAAlE;MACH,CAFD,MAGK;QACDE,EAAE,CAACK,UAAH,CAAcT,aAAd,EAA6BE,MAA7B,EAAqCC,KAArC;MACH;;MACD,KAAKO,MAAL,CAAYX,MAAZ;IACH;;;WACD,cAAKA,MAAL,EAAa;MACT,IAAIK,EAAE,GAAG,KAAKzB,OAAd;MACAyB,EAAE,CAACO,UAAH,CAAcP,EAAE,CAACQ,YAAjB,EAA+B,KAAKC,cAApC;MACA,IAAIX,MAAM,GAAG,CAAb;;MACA,KAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKR,UAAL,CAAgBS,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;QAC7C,IAAI0B,MAAM,GAAG,KAAKlC,UAAL,CAAgBQ,CAAhB,CAAb;QACA,IAAI2B,QAAQ,GAAGhB,MAAM,CAACiB,oBAAP,CAA4BF,MAAM,CAACG,IAAnC,CAAf;QACAb,EAAE,CAACc,uBAAH,CAA2BH,QAA3B;QACAX,EAAE,CAACe,mBAAH,CAAuBJ,QAAvB,EAAiCD,MAAM,CAACxB,WAAxC,EAAqDc,EAAE,CAACgB,KAAxD,EAA+D,KAA/D,EAAsE,KAAKjC,iBAAL,GAAyB,CAA/F,EAAkGe,MAAM,GAAG,CAA3G;QACAA,MAAM,IAAIY,MAAM,CAACxB,WAAjB;MACH;;MACD,IAAI,KAAKL,aAAL,GAAqB,CAAzB,EACImB,EAAE,CAACO,UAAH,CAAcP,EAAE,CAACiB,oBAAjB,EAAuC,KAAKC,aAA5C;IACP;;;WACD,gBAAOvB,MAAP,EAAe;MACX,IAAIK,EAAE,GAAG,KAAKzB,OAAd;;MACA,KAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKR,UAAL,CAAgBS,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;QAC7C,IAAI0B,MAAM,GAAG,KAAKlC,UAAL,CAAgBQ,CAAhB,CAAb;QACA,IAAI2B,QAAQ,GAAGhB,MAAM,CAACiB,oBAAP,CAA4BF,MAAM,CAACG,IAAnC,CAAf;QACAb,EAAE,CAACmB,wBAAH,CAA4BR,QAA5B;MACH;;MACDX,EAAE,CAACO,UAAH,CAAcP,EAAE,CAACQ,YAAjB,EAA+B,IAA/B;MACA,IAAI,KAAK3B,aAAL,GAAqB,CAAzB,EACImB,EAAE,CAACO,UAAH,CAAcP,EAAE,CAACiB,oBAAjB,EAAuC,IAAvC;IACP;;;WACD,kBAAS;MACL,IAAIjB,EAAE,GAAG,KAAKzB,OAAd;;MACA,IAAI,KAAKK,aAAT,EAAwB;QACpB,IAAI,CAAC,KAAK6B,cAAV,EAA0B;UACtB,KAAKA,cAAL,GAAsBT,EAAE,CAACoB,YAAH,EAAtB;QACH;;QACDpB,EAAE,CAACO,UAAH,CAAcP,EAAE,CAACQ,YAAjB,EAA+B,KAAKC,cAApC;QACAT,EAAE,CAACqB,UAAH,CAAcrB,EAAE,CAACQ,YAAjB,EAA+B,KAAKrB,QAAL,CAAcmC,QAAd,CAAuB,CAAvB,EAA0B,KAAK3C,cAA/B,CAA/B,EAA+EqB,EAAE,CAACuB,YAAlF;QACA,KAAK3C,aAAL,GAAqB,KAArB;MACH;;MACD,IAAI,KAAKE,YAAT,EAAuB;QACnB,IAAI,CAAC,KAAKoC,aAAV,EAAyB;UACrB,KAAKA,aAAL,GAAqBlB,EAAE,CAACoB,YAAH,EAArB;QACH;;QACDpB,EAAE,CAACO,UAAH,CAAcP,EAAE,CAACiB,oBAAjB,EAAuC,KAAKC,aAA5C;QACAlB,EAAE,CAACqB,UAAH,CAAcrB,EAAE,CAACiB,oBAAjB,EAAuC,KAAK5B,OAAL,CAAaiC,QAAb,CAAsB,CAAtB,EAAyB,KAAKzC,aAA9B,CAAvC,EAAqFmB,EAAE,CAACuB,YAAxF;QACA,KAAKzC,YAAL,GAAoB,KAApB;MACH;IACJ;;;WACD,mBAAU;MACN,KAAK2B,cAAL,GAAsB,IAAtB;MACA,KAAKS,aAAL,GAAqB,IAArB;MACA,KAAKjB,MAAL;IACH;;;WACD,mBAAU;MACN,IAAID,EAAE,GAAG,KAAKzB,OAAd;MACAyB,EAAE,CAACwB,YAAH,CAAgB,KAAKf,cAArB;MACAT,EAAE,CAACwB,YAAH,CAAgB,KAAKN,aAArB;IACH;;;;;;AAELvD,OAAO,CAACS,IAAR,GAAeA,IAAf;AACA,IAAID,mBAAJ;;AACA,CAAC,UAAUA,mBAAV,EAA+B;EAC5BA,mBAAmB,CAACA,mBAAmB,CAAC,OAAD,CAAnB,GAA+B,CAAhC,CAAnB,GAAwD,OAAxD;AACH,CAFD,EAEGA,mBAAmB,GAAGR,OAAO,CAACQ,mBAAR,KAAgCR,OAAO,CAACQ,mBAAR,GAA8B,EAA9D,CAFzB;;IAGMD,e,6BACF,yBAAY2C,IAAZ,EAAkBY,IAAlB,EAAwBvC,WAAxB,EAAqC;EAAA;;EACjC,KAAK2B,IAAL,GAAYA,IAAZ;EACA,KAAKY,IAAL,GAAYA,IAAZ;EACA,KAAKvC,WAAL,GAAmBA,WAAnB;AACH,C;;AAELvB,OAAO,CAACO,eAAR,GAA0BA,eAA1B;;IACMD,kB;;;;;EACF,8BAAc;IAAA;;IAAA,yBACJI,QAAQ,CAACqD,MAAT,CAAgBC,QADZ,EACsBxD,mBAAmB,CAACyD,KAD1C,EACiD,CADjD;EAEb;;;EAH4B1D,e;;AAKjCP,OAAO,CAACM,kBAAR,GAA6BA,kBAA7B;;IACMD,kB;;;;;EACF,8BAAc;IAAA;;IAAA,0BACJK,QAAQ,CAACqD,MAAT,CAAgBC,QADZ,EACsBxD,mBAAmB,CAACyD,KAD1C,EACiD,CADjD;EAEb;;;EAH4B1D,e;;AAKjCP,OAAO,CAACK,kBAAR,GAA6BA,kBAA7B;;IACMD,iB;;;;;EACF,6BAAsB;IAAA,IAAV8D,IAAU,uEAAH,CAAG;;IAAA;;IAAA,0BACZxD,QAAQ,CAACqD,MAAT,CAAgBI,SAAhB,IAA6BD,IAAI,KAAK,CAAT,GAAa,EAAb,GAAkBA,IAA/C,CADY,EAC0C1D,mBAAmB,CAACyD,KAD9D,EACqE,CADrE;EAErB;;;EAH2B1D,e;;AAKhCP,OAAO,CAACI,iBAAR,GAA4BA,iBAA5B;;IACMD,c;;;;;EACF,0BAAc;IAAA;;IAAA,0BACJO,QAAQ,CAACqD,MAAT,CAAgBK,KADZ,EACmB5D,mBAAmB,CAACyD,KADvC,EAC8C,CAD9C;EAEb;;;EAHwB1D,e;;AAK7BP,OAAO,CAACG,cAAR,GAAyBA,cAAzB;;IACMD,e;;;;;EACF,2BAAc;IAAA;;IAAA,0BACJQ,QAAQ,CAACqD,MAAT,CAAgBM,MADZ,EACoB7D,mBAAmB,CAACyD,KADxC,EAC+C,CAD/C;EAEb;;;EAHyB1D,e;;AAK9BP,OAAO,CAACE,eAAR,GAA0BA,eAA1B"},"metadata":{},"sourceType":"script"}