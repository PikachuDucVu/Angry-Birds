{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createClass = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitmapFont = void 0;\n\nvar BitmapFontCache_1 = require(\"./BitmapFontCache\");\n\nvar BitmapFontData_1 = require(\"./BitmapFontData\");\n\nvar Utils_1 = require(\"./Utils\");\n\nvar BitmapFont = /*#__PURE__*/_createClass(\n/** Constructs a new BitmapFont from the given {@link BitmapFontData} and array of {@link TextureRegion}. If the TextureRegion\n * is null or empty, the image path(s) will be read from the BitmapFontData. The dispose() method will not dispose the texture\n * of the region(s) if the regions array is != null and not empty.\n * @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */\nfunction BitmapFont(data, regions, integer) {\n  var _this = this;\n\n  _classCallCheck(this, BitmapFont);\n\n  this.load = function (data) {\n    var glyphValues = Object.values(data.glyphs);\n\n    for (var i = 0; i < glyphValues.length; i++) {\n      var page = glyphValues[i];\n      if (!page) continue;\n\n      for (var j = 0; j < page.length; j++) {\n        var glyph = page[j];\n\n        if (glyph) {\n          data.setGlyphRegion(glyph, _this.regions[glyph.page]);\n        }\n      }\n    }\n\n    if (data.missingGlyph != null) data.setGlyphRegion(data.missingGlyph, _this.regions[data.missingGlyph.page]);\n  };\n  /** Draws text at the specified position.\n   * @see BitmapFontCache#addText(CharSequence, float, float, int, int, float, int, boolean, String) */\n\n\n  this.draw = function (batch, str, x, y, targetWidth) {\n    var halign = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Utils_1.Align.left;\n    var wrap = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n    var start = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    var end = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : str.length;\n    var truncate = arguments.length > 9 ? arguments[9] : undefined;\n\n    _this.cache.clear();\n\n    _this.cache.addText(str, x, y, start, end, targetWidth, halign, wrap, truncate);\n\n    _this.cache.draw(batch);\n  };\n  /** Returns the color of text drawn with this font. */\n\n\n  this.getColor = function () {\n    return _this.cache.getColor();\n  };\n  /** A convenience method for setting the font color. The color can also be set by modifying {@link #getColor()}. */\n  // setColor = (r: number, g: number, b: number, a: number) => {\n  //    this.cache.getColor().set(r, g, b, a);\n  // };\n\n\n  this.getScaleX = function () {\n    return _this.data.scaleX;\n  };\n\n  this.getScaleY = function () {\n    return _this.data.scaleY;\n  };\n  /** Returns the array of TextureRegions that represents each texture page of glyphs.\n   * @return the array of texture regions; modifying it may produce undesirable results */\n\n\n  this.getRegions = function () {\n    return _this.regions;\n  };\n  /** Returns the texture page at the given index.\n   * @return the texture page at the given index */\n\n\n  this.getRegion = function (index) {\n    return _this.regions[index];\n  };\n  /** Returns the line height, which is the distance from one line of text to the next. */\n\n\n  this.getLineHeight = function () {\n    return _this.data.lineHeight;\n  };\n  /** Returns the x-advance of the space character. */\n\n\n  this.getSpaceXadvance = function () {\n    return _this.data.spaceXadvance;\n  };\n  /** Returns the x-height, which is the distance from the top of most lowercase characters to the baseline. */\n\n\n  this.getXHeight = function () {\n    return _this.data.xHeight;\n  };\n  /** Returns the cap height, which is the distance from the top of most uppercase characters to the baseline. Since the drawing\n   * position is the cap height of the first line, the cap height can be used to get the location of the baseline. */\n\n\n  this.getCapHeight = function () {\n    return _this.data.capHeight;\n  };\n  /** Returns the ascent, which is the distance from the cap height to the top of the tallest glyph. */\n\n\n  this.getAscent = function () {\n    return _this.data.ascent;\n  };\n  /** Returns the descent, which is the distance from the bottom of the glyph that extends the lowest to the baseline. This\n   * number is negative. */\n\n\n  this.getDescent = function () {\n    return _this.data.descent;\n  };\n  /** Returns true if this BitmapFont has been flipped for use with a y-down coordinate system. */\n\n\n  this.isFlipped = function () {\n    return _this.flipped;\n  };\n  /** Disposes the texture used by this BitmapFont's region IF this BitmapFont created the texture. */\n\n\n  this.dispose = function () {\n    if (_this.ownsTexture) {\n      for (var i = 0; i < _this.regions.length; i++) {\n        _this.regions[i].texture.dispose();\n      }\n    }\n  };\n  /** Makes the specified glyphs fixed width. This can be useful to make the numbers in a font fixed width. Eg, when horizontally\n   * centering a score or loading percentage text, it will not jump around as different numbers are shown. */\n\n\n  this.setFixedWidthGlyphs = function (glyphs) {\n    var data = _this.data;\n    var maxAdvance = 0;\n\n    for (var index = 0, end = glyphs.length; index < end; index++) {\n      var g = data.getGlyph(glyphs.charAt(index));\n      if (g != null && g.xadvance > maxAdvance) maxAdvance = g.xadvance;\n    }\n\n    for (var _index = 0, _end = glyphs.length; _index < _end; _index++) {\n      var _g = data.getGlyph(glyphs.charAt(_index));\n\n      if (!_g) continue;\n      _g.xoffset += (maxAdvance - _g.xadvance) / 2;\n      _g.xadvance = maxAdvance;\n      _g.kerning = [];\n      _g.kerning = null;\n      _g.fixedWidth = true;\n    }\n  };\n  /** Specifies whether to use integer positions. Default is to use them so filtering doesn't kick in as badly. */\n\n\n  this.setUseIntegerPositions = function (integer) {\n    _this.integer = integer;\n\n    _this.cache.setUseIntegerPositions(integer);\n  };\n  /** Checks whether this font uses integer positions for drawing. */\n\n\n  this.usesIntegerPositions = function () {\n    return _this.integer;\n  };\n  /** For expert usage -- returns the BitmapFontCache used by this font, for rendering to a sprite batch. This can be used, for\n   * example, to manipulate glyph colors within a specific index.\n   * @return the bitmap font cache used by this font */\n\n\n  this.getCache = function () {\n    return _this.cache;\n  };\n  /** Gets the underlying {@link BitmapFontData} for this BitmapFont. */\n\n\n  this.getData = function () {\n    return _this.data;\n  };\n  /** @return whether the texture is owned by the font, font disposes the texture itself if true */\n\n\n  this.getOwnsTexture = function () {\n    return _this.ownsTexture;\n  };\n  /** Sets whether the font owns the texture. In case it does, the font will also dispose of the texture when {@link #dispose()}\n   * is called. Use with care!\n   * @param ownsTexture whether the font owns the texture */\n\n\n  this.setOwnsTexture = function (ownsTexture) {\n    _this.ownsTexture = ownsTexture;\n  };\n  /** Creates a new BitmapFontCache for this font. Using this method allows the font to provide the BitmapFontCache\n   * implementation to customize rendering.\n   * <p>\n   * Note this method is called by the BitmapFont constructors. If a subclass overrides this method, it will be called before the\n   * subclass constructors. */\n\n\n  this.newFontCache = function () {\n    return new BitmapFontCache_1.BitmapFontCache(_this, _this.integer);\n  };\n\n  this.regions = regions;\n  this.flipped = data.flipped;\n  this.data = data;\n  this.integer = integer;\n\n  if (this.regions.length === 0) {\n    console.log('No texture region were found');\n    return;\n  } else {\n    this.ownsTexture = false;\n  }\n\n  this.cache = this.newFontCache();\n  this.load(data);\n});\n\nexports.BitmapFont = BitmapFont;\n_a = BitmapFont;\n\nBitmapFont.load = function (gl, fontFile) {\n  var flip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var interger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var fontData;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            fontData = new BitmapFontData_1.BitmapFontData(fontFile, flip);\n            _context.next = 3;\n            return fontData.loadFont(gl);\n\n          case 3:\n            return _context.abrupt(\"return\", new BitmapFont(fontData, fontData.regions, interger));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n};","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","_a","Object","defineProperty","exports","BitmapFont","BitmapFontCache_1","require","BitmapFontData_1","Utils_1","data","regions","integer","load","glyphValues","values","glyphs","i","length","page","j","glyph","setGlyphRegion","missingGlyph","draw","batch","str","x","y","targetWidth","halign","Align","left","wrap","start","end","truncate","cache","clear","addText","getColor","getScaleX","scaleX","getScaleY","scaleY","getRegions","getRegion","index","getLineHeight","lineHeight","getSpaceXadvance","spaceXadvance","getXHeight","xHeight","getCapHeight","capHeight","getAscent","ascent","getDescent","descent","isFlipped","flipped","dispose","ownsTexture","texture","setFixedWidthGlyphs","maxAdvance","g","getGlyph","charAt","xadvance","xoffset","kerning","fixedWidth","setUseIntegerPositions","usesIntegerPositions","getCache","getData","getOwnsTexture","setOwnsTexture","newFontCache","BitmapFontCache","console","log","gl","fontFile","flip","interger","fontData","BitmapFontData","loadFont"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/BitmapFont.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitmapFont = void 0;\nconst BitmapFontCache_1 = require(\"./BitmapFontCache\");\nconst BitmapFontData_1 = require(\"./BitmapFontData\");\nconst Utils_1 = require(\"./Utils\");\nclass BitmapFont {\n    /** Constructs a new BitmapFont from the given {@link BitmapFontData} and array of {@link TextureRegion}. If the TextureRegion\n     * is null or empty, the image path(s) will be read from the BitmapFontData. The dispose() method will not dispose the texture\n     * of the region(s) if the regions array is != null and not empty.\n     * @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */\n    constructor(data, regions, integer) {\n        this.load = (data) => {\n            const glyphValues = Object.values(data.glyphs);\n            for (let i = 0; i < glyphValues.length; i++) {\n                const page = glyphValues[i];\n                if (!page)\n                    continue;\n                for (let j = 0; j < page.length; j++) {\n                    const glyph = page[j];\n                    if (glyph) {\n                        data.setGlyphRegion(glyph, this.regions[glyph.page]);\n                    }\n                }\n            }\n            if (data.missingGlyph != null)\n                data.setGlyphRegion(data.missingGlyph, this.regions[data.missingGlyph.page]);\n        };\n        /** Draws text at the specified position.\n         * @see BitmapFontCache#addText(CharSequence, float, float, int, int, float, int, boolean, String) */\n        this.draw = (batch, str, x, y, targetWidth, halign = Utils_1.Align.left, wrap = true, start = 0, end = str.length, truncate) => {\n            this.cache.clear();\n            this.cache.addText(str, x, y, start, end, targetWidth, halign, wrap, truncate);\n            this.cache.draw(batch);\n        };\n        /** Returns the color of text drawn with this font. */\n        this.getColor = () => {\n            return this.cache.getColor();\n        };\n        /** A convenience method for setting the font color. The color can also be set by modifying {@link #getColor()}. */\n        // setColor = (r: number, g: number, b: number, a: number) => {\n        //    this.cache.getColor().set(r, g, b, a);\n        // };\n        this.getScaleX = () => {\n            return this.data.scaleX;\n        };\n        this.getScaleY = () => {\n            return this.data.scaleY;\n        };\n        /** Returns the array of TextureRegions that represents each texture page of glyphs.\n         * @return the array of texture regions; modifying it may produce undesirable results */\n        this.getRegions = () => {\n            return this.regions;\n        };\n        /** Returns the texture page at the given index.\n         * @return the texture page at the given index */\n        this.getRegion = (index) => {\n            return this.regions[index];\n        };\n        /** Returns the line height, which is the distance from one line of text to the next. */\n        this.getLineHeight = () => {\n            return this.data.lineHeight;\n        };\n        /** Returns the x-advance of the space character. */\n        this.getSpaceXadvance = () => {\n            return this.data.spaceXadvance;\n        };\n        /** Returns the x-height, which is the distance from the top of most lowercase characters to the baseline. */\n        this.getXHeight = () => {\n            return this.data.xHeight;\n        };\n        /** Returns the cap height, which is the distance from the top of most uppercase characters to the baseline. Since the drawing\n         * position is the cap height of the first line, the cap height can be used to get the location of the baseline. */\n        this.getCapHeight = () => {\n            return this.data.capHeight;\n        };\n        /** Returns the ascent, which is the distance from the cap height to the top of the tallest glyph. */\n        this.getAscent = () => {\n            return this.data.ascent;\n        };\n        /** Returns the descent, which is the distance from the bottom of the glyph that extends the lowest to the baseline. This\n         * number is negative. */\n        this.getDescent = () => {\n            return this.data.descent;\n        };\n        /** Returns true if this BitmapFont has been flipped for use with a y-down coordinate system. */\n        this.isFlipped = () => {\n            return this.flipped;\n        };\n        /** Disposes the texture used by this BitmapFont's region IF this BitmapFont created the texture. */\n        this.dispose = () => {\n            if (this.ownsTexture) {\n                for (let i = 0; i < this.regions.length; i++) {\n                    this.regions[i].texture.dispose();\n                }\n            }\n        };\n        /** Makes the specified glyphs fixed width. This can be useful to make the numbers in a font fixed width. Eg, when horizontally\n         * centering a score or loading percentage text, it will not jump around as different numbers are shown. */\n        this.setFixedWidthGlyphs = (glyphs) => {\n            const data = this.data;\n            let maxAdvance = 0;\n            for (let index = 0, end = glyphs.length; index < end; index++) {\n                const g = data.getGlyph(glyphs.charAt(index));\n                if (g != null && g.xadvance > maxAdvance)\n                    maxAdvance = g.xadvance;\n            }\n            for (let index = 0, end = glyphs.length; index < end; index++) {\n                const g = data.getGlyph(glyphs.charAt(index));\n                if (!g)\n                    continue;\n                g.xoffset += (maxAdvance - g.xadvance) / 2;\n                g.xadvance = maxAdvance;\n                g.kerning = [];\n                g.kerning = null;\n                g.fixedWidth = true;\n            }\n        };\n        /** Specifies whether to use integer positions. Default is to use them so filtering doesn't kick in as badly. */\n        this.setUseIntegerPositions = (integer) => {\n            this.integer = integer;\n            this.cache.setUseIntegerPositions(integer);\n        };\n        /** Checks whether this font uses integer positions for drawing. */\n        this.usesIntegerPositions = () => {\n            return this.integer;\n        };\n        /** For expert usage -- returns the BitmapFontCache used by this font, for rendering to a sprite batch. This can be used, for\n         * example, to manipulate glyph colors within a specific index.\n         * @return the bitmap font cache used by this font */\n        this.getCache = () => {\n            return this.cache;\n        };\n        /** Gets the underlying {@link BitmapFontData} for this BitmapFont. */\n        this.getData = () => {\n            return this.data;\n        };\n        /** @return whether the texture is owned by the font, font disposes the texture itself if true */\n        this.getOwnsTexture = () => {\n            return this.ownsTexture;\n        };\n        /** Sets whether the font owns the texture. In case it does, the font will also dispose of the texture when {@link #dispose()}\n         * is called. Use with care!\n         * @param ownsTexture whether the font owns the texture */\n        this.setOwnsTexture = (ownsTexture) => {\n            this.ownsTexture = ownsTexture;\n        };\n        /** Creates a new BitmapFontCache for this font. Using this method allows the font to provide the BitmapFontCache\n         * implementation to customize rendering.\n         * <p>\n         * Note this method is called by the BitmapFont constructors. If a subclass overrides this method, it will be called before the\n         * subclass constructors. */\n        this.newFontCache = () => {\n            return new BitmapFontCache_1.BitmapFontCache(this, this.integer);\n        };\n        this.regions = regions;\n        this.flipped = data.flipped;\n        this.data = data;\n        this.integer = integer;\n        if (this.regions.length === 0) {\n            console.log('No texture region were found');\n            return;\n        }\n        else {\n            this.ownsTexture = false;\n        }\n        this.cache = this.newFontCache();\n        this.load(data);\n    }\n}\nexports.BitmapFont = BitmapFont;\n_a = BitmapFont;\nBitmapFont.load = (gl, fontFile, flip = false, interger = false) => __awaiter(void 0, void 0, void 0, function* () {\n    const fontData = new BitmapFontData_1.BitmapFontData(fontFile, flip);\n    yield fontData.loadFont(gl);\n    return new BitmapFont(fontData, fontData.regions, interger);\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}