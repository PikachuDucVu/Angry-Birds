{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TextureAtlas = void 0;\n\nconst Texture_1 = require(\"./Texture\");\n\nconst TextureRegion_1 = require(\"./TextureRegion\");\n\nfunction concatAndResolveUrl(url, concat) {\n  let url1 = url.split('/');\n  let url2 = concat.split('/');\n  let url3 = [];\n\n  for (let i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (let i = 0, l = url2.length; i < l; i++) {\n    if (url2[i] === '..') {\n      url3.pop();\n    } else if (url2[i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nclass TextureAtlas {\n  constructor(pages, regions) {\n    this.pages = pages;\n    this.regions = regions;\n  }\n\n  dispose() {\n    for (let page of this.pages) {\n      page.dispose();\n    }\n  }\n\n  getPages() {\n    return this.pages;\n  }\n\n  getRegions() {\n    return this.regions;\n  }\n\n  findRegion(name, index) {\n    for (let i = 0; i < this.regions.length; i++) {\n      let region = this.regions[i];\n      if (region.name !== name) continue;\n      if (index !== undefined && region.index !== index) continue;\n      return region;\n    }\n\n    return null;\n  }\n\n  findRegions(name) {\n    return this.regions.filter(region => region.name === name).sort((a, b) => a.index - b.index);\n  }\n\n  static load(gl, packFileUrl, textureOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packFileContent = yield fetch(packFileUrl).then(res => res.text());\n      const pageData = [];\n      const pages = [];\n      const regionsData = [];\n      let pageImage;\n      const lines = packFileContent.split('\\n');\n      let i = 0;\n      let tuple;\n\n      while (true) {\n        let line = lines[i];\n\n        if (line === undefined) {\n          break;\n        }\n\n        if (line.trim().length === 0) {\n          pageImage = null;\n        } else if (pageImage === null) {\n          const file = concatAndResolveUrl(packFileUrl, `../${line}`);\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n          const width = parseInt(tuple[0], 10);\n          const height = parseInt(tuple[1], 10);\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n          const format = tuple[0];\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n          const [min, max] = tuple;\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n          const direction = tuple[0];\n          let repeatX = Texture_1.TextureWrap.ClampToEdge;\n          let repeatY = Texture_1.TextureWrap.ClampToEdge;\n\n          if (direction === 'x') {\n            repeatX = Texture_1.TextureWrap.Repeat;\n          } else if (direction === 'y') {\n            repeatY = Texture_1.TextureWrap.Repeat;\n          } else if (direction === 'xy') {\n            repeatX = Texture_1.TextureWrap.Repeat;\n            repeatY = Texture_1.TextureWrap.Repeat;\n          }\n\n          const mipMaps = min !== 'Nearest' && min !== 'Linear';\n          pageImage = {\n            file,\n            width,\n            height,\n            format,\n            mipMaps,\n            min,\n            max,\n            direction,\n            repeatX,\n            repeatY\n          };\n          pageData.push(pageImage);\n        } else {\n          const name = line;\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n          const rotate = tuple[0] === 'true';\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n          const left = parseInt(tuple[0], 10);\n          const top = parseInt(tuple[1], 10);\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n          const width = parseInt(tuple[0], 10);\n          const height = parseInt(tuple[1], 10);\n          const region = {\n            name,\n            rotate,\n            left,\n            top,\n            width,\n            height,\n            page: pageImage\n          };\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n          if (tuple.length === 4) {\n            region.splits = tuple.map(i => parseInt(i, 10));\n            i++;\n            line = lines[i];\n            tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n            if (tuple.length === 4) {\n              region.pads = tuple.map(i => parseInt(i, 10));\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(s => s.trim());\n            }\n          }\n\n          region.originalWidth = parseInt(tuple[0], 10);\n          region.originalHeight = parseInt(tuple[1], 10);\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n          region.offsetX = parseInt(tuple[0], 10);\n          region.offsetY = parseInt(tuple[1], 10);\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n          region.index = parseInt(tuple[0], 10);\n          regionsData.push(region);\n        }\n\n        i++;\n      }\n\n      for (let page of pageData) {\n        page.texture = yield Texture_1.Texture.load(gl, page.file, textureOptions);\n        page.invTexWidth = 1 / page.texture.width;\n        page.invTexHeight = 1 / page.texture.height;\n      }\n\n      const regions = [];\n\n      for (let regionData of regionsData) {\n        const {\n          left: x,\n          top: y\n        } = regionData;\n        const width = regionData.rotate ? regionData.height : regionData.width;\n        const height = regionData.rotate ? regionData.width : regionData.height;\n        const {\n          texture,\n          invTexWidth,\n          invTexHeight\n        } = regionData.page;\n        regions.push(new TextureRegion_1.TextureRegion(texture, x, y, width, height, regionData, invTexWidth, invTexHeight, regionData.rotate));\n      }\n\n      return new TextureAtlas(pages, regions);\n    });\n  }\n\n}\n\nexports.TextureAtlas = TextureAtlas;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","TextureAtlas","Texture_1","require","TextureRegion_1","concatAndResolveUrl","url","concat","url1","split","url2","url3","i","l","length","pop","push","join","constructor","pages","regions","dispose","page","getPages","getRegions","findRegion","name","index","region","undefined","findRegions","filter","sort","a","b","load","gl","packFileUrl","textureOptions","packFileContent","fetch","res","text","pageData","regionsData","pageImage","lines","tuple","line","trim","file","map","s","width","parseInt","height","format","min","max","direction","repeatX","TextureWrap","ClampToEdge","repeatY","Repeat","mipMaps","rotate","left","top","splits","pads","originalWidth","originalHeight","offsetX","offsetY","texture","Texture","invTexWidth","invTexHeight","regionData","x","y","TextureRegion"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/TextureAtlas.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextureAtlas = void 0;\nconst Texture_1 = require(\"./Texture\");\nconst TextureRegion_1 = require(\"./TextureRegion\");\nfunction concatAndResolveUrl(url, concat) {\n    let url1 = url.split('/');\n    let url2 = concat.split('/');\n    let url3 = [];\n    for (let i = 0, l = url1.length; i < l; i++) {\n        if (url1[i] === '..') {\n            url3.pop();\n        }\n        else if (url1[i] === '.') {\n            continue;\n        }\n        else {\n            url3.push(url1[i]);\n        }\n    }\n    for (let i = 0, l = url2.length; i < l; i++) {\n        if (url2[i] === '..') {\n            url3.pop();\n        }\n        else if (url2[i] === '.') {\n            continue;\n        }\n        else {\n            url3.push(url2[i]);\n        }\n    }\n    return url3.join('/');\n}\nclass TextureAtlas {\n    constructor(pages, regions) {\n        this.pages = pages;\n        this.regions = regions;\n    }\n    dispose() {\n        for (let page of this.pages) {\n            page.dispose();\n        }\n    }\n    getPages() {\n        return this.pages;\n    }\n    getRegions() {\n        return this.regions;\n    }\n    findRegion(name, index) {\n        for (let i = 0; i < this.regions.length; i++) {\n            let region = this.regions[i];\n            if (region.name !== name)\n                continue;\n            if (index !== undefined && region.index !== index)\n                continue;\n            return region;\n        }\n        return null;\n    }\n    findRegions(name) {\n        return this.regions.filter(region => region.name === name).sort((a, b) => a.index - b.index);\n    }\n    static load(gl, packFileUrl, textureOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const packFileContent = yield fetch(packFileUrl).then(res => res.text());\n            const pageData = [];\n            const pages = [];\n            const regionsData = [];\n            let pageImage;\n            const lines = packFileContent.split('\\n');\n            let i = 0;\n            let tuple;\n            while (true) {\n                let line = lines[i];\n                if (line === undefined) {\n                    break;\n                }\n                if (line.trim().length === 0) {\n                    pageImage = null;\n                }\n                else if (pageImage === null) {\n                    const file = concatAndResolveUrl(packFileUrl, `../${line}`);\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    const width = parseInt(tuple[0], 10);\n                    const height = parseInt(tuple[1], 10);\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    const format = tuple[0];\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    const [min, max] = tuple;\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    const direction = tuple[0];\n                    let repeatX = Texture_1.TextureWrap.ClampToEdge;\n                    let repeatY = Texture_1.TextureWrap.ClampToEdge;\n                    if (direction === 'x') {\n                        repeatX = Texture_1.TextureWrap.Repeat;\n                    }\n                    else if (direction === 'y') {\n                        repeatY = Texture_1.TextureWrap.Repeat;\n                    }\n                    else if (direction === 'xy') {\n                        repeatX = Texture_1.TextureWrap.Repeat;\n                        repeatY = Texture_1.TextureWrap.Repeat;\n                    }\n                    const mipMaps = min !== 'Nearest' && min !== 'Linear';\n                    pageImage = {\n                        file,\n                        width,\n                        height,\n                        format,\n                        mipMaps,\n                        min,\n                        max,\n                        direction,\n                        repeatX,\n                        repeatY\n                    };\n                    pageData.push(pageImage);\n                }\n                else {\n                    const name = line;\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    const rotate = tuple[0] === 'true';\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    const left = parseInt(tuple[0], 10);\n                    const top = parseInt(tuple[1], 10);\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    const width = parseInt(tuple[0], 10);\n                    const height = parseInt(tuple[1], 10);\n                    const region = {\n                        name,\n                        rotate,\n                        left,\n                        top,\n                        width,\n                        height,\n                        page: pageImage\n                    };\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    if (tuple.length === 4) {\n                        region.splits = tuple.map(i => parseInt(i, 10));\n                        i++;\n                        line = lines[i];\n                        tuple = line\n                            .split(':')[1]\n                            .split(',')\n                            .map(s => s.trim());\n                        if (tuple.length === 4) {\n                            region.pads = tuple.map(i => parseInt(i, 10));\n                            i++;\n                            line = lines[i];\n                            tuple = line\n                                .split(':')[1]\n                                .split(',')\n                                .map(s => s.trim());\n                        }\n                    }\n                    region.originalWidth = parseInt(tuple[0], 10);\n                    region.originalHeight = parseInt(tuple[1], 10);\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    region.offsetX = parseInt(tuple[0], 10);\n                    region.offsetY = parseInt(tuple[1], 10);\n                    i++;\n                    line = lines[i];\n                    tuple = line\n                        .split(':')[1]\n                        .split(',')\n                        .map(s => s.trim());\n                    region.index = parseInt(tuple[0], 10);\n                    regionsData.push(region);\n                }\n                i++;\n            }\n            for (let page of pageData) {\n                page.texture = yield Texture_1.Texture.load(gl, page.file, textureOptions);\n                page.invTexWidth = 1 / page.texture.width;\n                page.invTexHeight = 1 / page.texture.height;\n            }\n            const regions = [];\n            for (let regionData of regionsData) {\n                const { left: x, top: y } = regionData;\n                const width = regionData.rotate ? regionData.height : regionData.width;\n                const height = regionData.rotate ? regionData.width : regionData.height;\n                const { texture, invTexWidth, invTexHeight } = regionData.page;\n                regions.push(new TextureRegion_1.TextureRegion(texture, x, y, width, height, regionData, invTexWidth, invTexHeight, regionData.rotate));\n            }\n            return new TextureAtlas(pages, regions);\n        });\n    }\n}\nexports.TextureAtlas = TextureAtlas;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}