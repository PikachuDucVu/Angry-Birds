{"ast":null,"code":"import loadTexture from './loadTexture';\nimport TextureRegion from './TextureRegion';\n\nfunction concatAndResolveUrl(url, concat) {\n  let url1 = url.split('/');\n  let url2 = concat.split('/');\n  let url3 = [];\n\n  for (let i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (let i = 0, l = url2.length; i < l; i++) {\n    if (url2[i] === '..') {\n      url3.pop();\n    } else if (url2[i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nconst TextureWrap = {\n  ClampToEdge: 0,\n  Repeat: 1\n};\nexport default (async (gl, packFileUrl, textureOptions) => {\n  const packFileContent = await fetch(packFileUrl).then(res => res.text());\n  const pages = [];\n  const regionsData = [];\n  let pageImage;\n  const lines = packFileContent.split('\\n');\n  let i = 0;\n  let tuple;\n\n  while (true) {\n    let line = lines[i];\n\n    if (line === undefined) {\n      break;\n    }\n\n    if (line.trim().length === 0) {\n      pageImage = null;\n    } else if (pageImage === null) {\n      const file = concatAndResolveUrl(packFileUrl, `../${line}`);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const format = tuple[0];\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const [min, max] = tuple;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const direction = tuple[0];\n      let repeatX = TextureWrap.ClampToEdge;\n      let repeatY = TextureWrap.ClampToEdge;\n\n      if (direction === 'x') {\n        repeatX = TextureWrap.Repeat;\n      } else if (direction === 'y') {\n        repeatY = TextureWrap.Repeat;\n      } else if (direction === 'xy') {\n        repeatX = TextureWrap.Repeat;\n        repeatY = TextureWrap.Repeat;\n      }\n\n      const mipMaps = min !== 'Nearest' && min !== 'Linear';\n      pageImage = {\n        file,\n        width,\n        height,\n        format,\n        mipMaps,\n        min,\n        max,\n        direction,\n        repeatX,\n        repeatY\n      };\n      pages.push(pageImage);\n    } else {\n      const name = line;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const rotate = tuple[0] === 'true';\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const left = parseInt(tuple[0], 10);\n      const top = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      const region = {\n        name,\n        rotate,\n        left,\n        top,\n        width,\n        height,\n        page: pageImage\n      };\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n      if (tuple.length === 4) {\n        region.splits = tuple.map(i => parseInt(i, 10));\n        i++;\n        line = lines[i];\n        tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n        if (tuple.length === 4) {\n          region.pads = tuple.map(i => parseInt(i, 10));\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n        }\n      }\n\n      region.originalWidth = parseInt(tuple[0], 10);\n      region.originalHeight = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.offsetX = parseInt(tuple[0], 10);\n      region.offsetY = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.index = parseInt(tuple[0], 10);\n      regionsData.push(region);\n    }\n\n    i++;\n  }\n\n  for (let page of pages) {\n    page.texture = await loadTexture(gl, page.file, textureOptions);\n    page.invTexWidth = 1 / page.texture.width;\n    page.invTexHeight = 1 / page.texture.height;\n  }\n\n  const regions = [];\n\n  for (let regionData of regionsData) {\n    const {\n      left: x,\n      top: y\n    } = regionData;\n    const width = regionData.rotate ? regionData.height : regionData.width;\n    const height = regionData.rotate ? regionData.width : regionData.height;\n    const {\n      texture,\n      invTexWidth,\n      invTexHeight\n    } = regionData.page;\n    regions.push(new TextureRegion(texture, x, y, width, height, regionData, invTexWidth, invTexHeight, regionData.rotate));\n  }\n\n  return {\n    getPages() {\n      return pages;\n    },\n\n    getRegions() {\n      return regions;\n    },\n\n    findRegion(name, index) {\n      for (let i = 0; i < regions.length; i++) {\n        let region = regions[i];\n        if (region.name !== name) continue;\n        if (index !== undefined && region.index !== index) continue;\n        return region;\n      }\n\n      return null;\n    },\n\n    findRegions(name) {\n      return regions.filter(region => region.name === name).sort((a, b) => a.index - b.index);\n    }\n\n  };\n});","map":{"version":3,"names":["loadTexture","TextureRegion","concatAndResolveUrl","url","concat","url1","split","url2","url3","i","l","length","pop","push","join","TextureWrap","ClampToEdge","Repeat","gl","packFileUrl","textureOptions","packFileContent","fetch","then","res","text","pages","regionsData","pageImage","lines","tuple","line","undefined","trim","file","map","s","width","parseInt","height","format","min","max","direction","repeatX","repeatY","mipMaps","name","rotate","left","top","region","page","splits","pads","originalWidth","originalHeight","offsetX","offsetY","index","texture","invTexWidth","invTexHeight","regions","regionData","x","y","getPages","getRegions","findRegion","findRegions","filter","sort","a","b"],"sources":["D:/projects/test-game/node_modules/gdxjs/lib/loadAtlas.js"],"sourcesContent":["import loadTexture from './loadTexture';\nimport TextureRegion from './TextureRegion';\n\nfunction concatAndResolveUrl(url, concat) {\n  let url1 = url.split('/');\n  let url2 = concat.split('/');\n  let url3 = [];\n\n  for (let i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (let i = 0, l = url2.length; i < l; i++) {\n    if (url2[i] === '..') {\n      url3.pop();\n    } else if (url2[i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nconst TextureWrap = {\n  ClampToEdge: 0,\n  Repeat: 1\n};\nexport default (async (gl, packFileUrl, textureOptions) => {\n  const packFileContent = await fetch(packFileUrl).then(res => res.text());\n  const pages = [];\n  const regionsData = [];\n  let pageImage;\n  const lines = packFileContent.split('\\n');\n  let i = 0;\n  let tuple;\n\n  while (true) {\n    let line = lines[i];\n\n    if (line === undefined) {\n      break;\n    }\n\n    if (line.trim().length === 0) {\n      pageImage = null;\n    } else if (pageImage === null) {\n      const file = concatAndResolveUrl(packFileUrl, `../${line}`);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const format = tuple[0];\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const [min, max] = tuple;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const direction = tuple[0];\n      let repeatX = TextureWrap.ClampToEdge;\n      let repeatY = TextureWrap.ClampToEdge;\n\n      if (direction === 'x') {\n        repeatX = TextureWrap.Repeat;\n      } else if (direction === 'y') {\n        repeatY = TextureWrap.Repeat;\n      } else if (direction === 'xy') {\n        repeatX = TextureWrap.Repeat;\n        repeatY = TextureWrap.Repeat;\n      }\n\n      const mipMaps = min !== 'Nearest' && min !== 'Linear';\n      pageImage = {\n        file,\n        width,\n        height,\n        format,\n        mipMaps,\n        min,\n        max,\n        direction,\n        repeatX,\n        repeatY\n      };\n      pages.push(pageImage);\n    } else {\n      const name = line;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const rotate = tuple[0] === 'true';\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const left = parseInt(tuple[0], 10);\n      const top = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      const region = {\n        name,\n        rotate,\n        left,\n        top,\n        width,\n        height,\n        page: pageImage\n      };\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n      if (tuple.length === 4) {\n        region.splits = tuple.map(i => parseInt(i, 10));\n        i++;\n        line = lines[i];\n        tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n        if (tuple.length === 4) {\n          region.pads = tuple.map(i => parseInt(i, 10));\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n        }\n      }\n\n      region.originalWidth = parseInt(tuple[0], 10);\n      region.originalHeight = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.offsetX = parseInt(tuple[0], 10);\n      region.offsetY = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.index = parseInt(tuple[0], 10);\n      regionsData.push(region);\n    }\n\n    i++;\n  }\n\n  for (let page of pages) {\n    page.texture = await loadTexture(gl, page.file, textureOptions);\n    page.invTexWidth = 1 / page.texture.width;\n    page.invTexHeight = 1 / page.texture.height;\n  }\n\n  const regions = [];\n\n  for (let regionData of regionsData) {\n    const {\n      left: x,\n      top: y\n    } = regionData;\n    const width = regionData.rotate ? regionData.height : regionData.width;\n    const height = regionData.rotate ? regionData.width : regionData.height;\n    const {\n      texture,\n      invTexWidth,\n      invTexHeight\n    } = regionData.page;\n    regions.push(new TextureRegion(texture, x, y, width, height, regionData, invTexWidth, invTexHeight, regionData.rotate));\n  }\n\n  return {\n    getPages() {\n      return pages;\n    },\n\n    getRegions() {\n      return regions;\n    },\n\n    findRegion(name, index) {\n      for (let i = 0; i < regions.length; i++) {\n        let region = regions[i];\n        if (region.name !== name) continue;\n        if (index !== undefined && region.index !== index) continue;\n        return region;\n      }\n\n      return null;\n    },\n\n    findRegions(name) {\n      return regions.filter(region => region.name === name).sort((a, b) => a.index - b.index);\n    }\n\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}