{"ast":null,"code":"/**\n * A mesh class that wraps VBO and IBO. Mostly used internally.\n * \n * @module kami-mesh-buffer\n */\nvar Class = require('klasse');\n\nvar BaseObject = require('kami-util').BaseObject; //TODO: decouple into VBO + IBO utilities \n\n/**\n * \n *\n * @class  Mesh\n */\n\n\nvar Mesh = new Class({\n  /**\n   * A write-only property which sets both vertices and indices \n   * flag to dirty or not. \n   *\n   * @property dirty\n   * @type {Boolean}\n   * @writeOnly\n   */\n  dirty: {\n    set: function (val) {\n      this.verticesDirty = val;\n      this.indicesDirty = val;\n    }\n  },\n\n  /**\n   * Creates a new Mesh with the provided parameters.\n   *\n   * If numIndices is 0 or falsy, no index buffer will be used\n   * and indices will be an empty ArrayBuffer and a null indexBuffer.\n   * \n   * If isStatic is true, then vertexUsage and indexUsage will\n   * be set to gl.STATIC_DRAW. Otherwise they will use gl.DYNAMIC_DRAW.\n   * You may want to adjust these after initialization for further control.\n   * \n   * @param  {WebGLContext}  context the context for management\n   * @param  {Boolean} isStatic      a hint as to whether this geometry is static\n   * @param  {[type]}  numVerts      [description]\n   * @param  {[type]}  numIndices    [description]\n   * @param  {[type]}  vertexAttribs [description]\n   * @return {[type]}                [description]\n   */\n  initialize: function Mesh(context, isStatic, numVerts, numIndices, vertexAttribs) {\n    //TODO: use options here...\n    if (!numVerts) throw \"numVerts not specified, must be > 0\";\n    BaseObject.call(this, context);\n    this.gl = this.context.gl;\n    this.numVerts = null;\n    this.numIndices = null;\n    this.vertices = null;\n    this.indices = null;\n    this.vertexBuffer = null;\n    this.indexBuffer = null;\n    this.verticesDirty = true;\n    this.indicesDirty = true;\n    this.indexUsage = null;\n    this.vertexUsage = null;\n    /** \n     * @property\n     * @private\n     */\n\n    this._vertexAttribs = null;\n    /** \n     * The stride for one vertex _in bytes_. \n     * \n     * @property {Number} vertexStride\n     */\n\n    this.vertexStride = null;\n    this.numVerts = numVerts;\n    this.numIndices = numIndices || 0;\n    this.vertexUsage = isStatic ? this.gl.STATIC_DRAW : this.gl.DYNAMIC_DRAW;\n    this.indexUsage = isStatic ? this.gl.STATIC_DRAW : this.gl.DYNAMIC_DRAW;\n    this._vertexAttribs = vertexAttribs || [];\n    this.indicesDirty = true;\n    this.verticesDirty = true; //determine the vertex stride based on given attributes\n\n    var totalNumComponents = 0;\n\n    for (var i = 0; i < this._vertexAttribs.length; i++) totalNumComponents += this._vertexAttribs[i].offsetCount;\n\n    this.vertexStride = totalNumComponents * 4; // in bytes\n\n    this.vertices = new Float32Array(this.numVerts);\n    this.indices = new Uint16Array(this.numIndices); //add this VBO to the managed cache\n\n    this.context.addManagedObject(this);\n    this.create();\n  },\n  //recreates the buffers on context loss\n  create: function () {\n    this.gl = this.context.gl;\n    var gl = this.gl;\n    this.vertexBuffer = gl.createBuffer(); //ignore index buffer if we haven't specified any\n\n    this.indexBuffer = this.numIndices > 0 ? gl.createBuffer() : null;\n    this.dirty = true;\n  },\n  destroy: function () {\n    this.vertices = null;\n    this.indices = null;\n    if (this.vertexBuffer && this.gl) this.gl.deleteBuffer(this.vertexBuffer);\n    if (this.indexBuffer && this.gl) this.gl.deleteBuffer(this.indexBuffer);\n    this.vertexBuffer = null;\n    this.indexBuffer = null;\n    if (this.context) this.context.removeManagedObject(this);\n    this.gl = null;\n    this.context = null;\n  },\n  _updateBuffers: function (ignoreBind, subDataLength) {\n    var gl = this.gl; //bind our index data, if we have any\n\n    if (this.numIndices > 0) {\n      if (!ignoreBind) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); //update the index data\n\n      if (this.indicesDirty) {\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, this.indexUsage);\n        this.indicesDirty = false;\n      }\n    } //bind our vertex data\n\n\n    if (!ignoreBind) gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); //update our vertex data\n\n    if (this.verticesDirty) {\n      if (subDataLength) {\n        // TODO: When decoupling VBO/IBO be sure to give better subData support..\n        var view = this.vertices.subarray(0, subDataLength);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n      } else {\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, this.vertexUsage);\n      }\n\n      this.verticesDirty = false;\n    }\n  },\n  draw: function (primitiveType, count, offset, subDataLength) {\n    if (count === 0) return;\n    var gl = this.gl;\n    offset = offset || 0; //binds and updates our buffers. pass ignoreBind as true\n    //to avoid binding unnecessarily\n\n    this._updateBuffers(true, subDataLength);\n\n    if (this.numIndices > 0) {\n      gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2); //* Uint16Array.BYTES_PER_ELEMENT\n    } else gl.drawArrays(primitiveType, offset, count);\n  },\n  //binds this mesh's vertex attributes for the given shader\n  bind: function (shader) {\n    var gl = this.gl;\n    var offset = 0;\n    var stride = this.vertexStride; //bind and update our vertex data before binding attributes\n\n    this._updateBuffers(); //for each attribtue\n\n\n    for (var i = 0; i < this._vertexAttribs.length; i++) {\n      var a = this._vertexAttribs[i]; //location of the attribute\n\n      var loc = a.location === null ? shader.getAttributeLocation(a.name) : a.location; //TODO: We may want to skip unfound attribs\n      // if (loc!==0 && !loc)\n      // \tconsole.warn(\"WARN:\", a.name, \"is not enabled\");\n      //first, enable the vertex array\n\n      gl.enableVertexAttribArray(loc); //then specify our vertex format\n\n      gl.vertexAttribPointer(loc, a.numComponents, a.type || gl.FLOAT, a.normalize, stride, offset); //and increase the offset...\n\n      offset += a.offsetCount * 4; //in bytes\n    }\n  },\n  unbind: function (shader) {\n    var gl = this.gl; //for each attribtue\n\n    for (var i = 0; i < this._vertexAttribs.length; i++) {\n      var a = this._vertexAttribs[i]; //location of the attribute\n\n      var loc = a.location === null ? shader.getAttributeLocation(a.name) : a.location; //first, enable the vertex array\n\n      gl.disableVertexAttribArray(loc);\n    }\n  }\n});\nMesh.Attrib = new Class({\n  name: null,\n  numComponents: null,\n  location: null,\n  type: null,\n\n  /**\n   * Mesh vertex attribute holder.\n   * \n   * Location is optional and for advanced users that\n   * want vertex arrays to match across shaders. Any non-numerical\n   * value will be converted to null, and ignored. If a numerical\n   * value is given, it will override the position of this attribute\n   * when given to a mesh.\n   *\n   * @class  Mesh.Attrib\n   * @constructor\n   * @param {String} name the name of the attribute\n   * @param {Number} numComponents the number of components, e.g. 2 for vec2\n   * @param {Number} location optional attribute index location\n   * @param {Number} type defaults to GL_FLOAT \n   * @param {Number} normalize whether to normalize to 0-1, default false\n   */\n  initialize: function (name, numComponents, location, type, normalize, offsetCount) {\n    this.name = name;\n    this.numComponents = numComponents;\n    this.location = typeof location === \"number\" ? location : null;\n    this.type = type;\n    this.normalize = Boolean(normalize);\n    this.offsetCount = typeof offsetCount === \"number\" ? offsetCount : this.numComponents;\n  }\n});\nmodule.exports = Mesh;","map":{"version":3,"names":["Class","require","BaseObject","Mesh","dirty","set","val","verticesDirty","indicesDirty","initialize","context","isStatic","numVerts","numIndices","vertexAttribs","call","gl","vertices","indices","vertexBuffer","indexBuffer","indexUsage","vertexUsage","_vertexAttribs","vertexStride","STATIC_DRAW","DYNAMIC_DRAW","totalNumComponents","i","length","offsetCount","Float32Array","Uint16Array","addManagedObject","create","createBuffer","destroy","deleteBuffer","removeManagedObject","_updateBuffers","ignoreBind","subDataLength","bindBuffer","ELEMENT_ARRAY_BUFFER","bufferData","ARRAY_BUFFER","view","subarray","bufferSubData","draw","primitiveType","count","offset","drawElements","UNSIGNED_SHORT","drawArrays","bind","shader","stride","a","loc","location","getAttributeLocation","name","enableVertexAttribArray","vertexAttribPointer","numComponents","type","FLOAT","normalize","unbind","disableVertexAttribArray","Attrib","Boolean","module","exports"],"sources":["D:/projects/test-game/node_modules/kami-mesh-buffer/index.js"],"sourcesContent":["/**\n * A mesh class that wraps VBO and IBO. Mostly used internally.\n * \n * @module kami-mesh-buffer\n */\n\nvar Class = require('klasse');\nvar BaseObject = require('kami-util').BaseObject;\n\n//TODO: decouple into VBO + IBO utilities \n/**\n * \n *\n * @class  Mesh\n */\nvar Mesh = new Class({\n\n\n\t/**\n\t * A write-only property which sets both vertices and indices \n\t * flag to dirty or not. \n\t *\n\t * @property dirty\n\t * @type {Boolean}\n\t * @writeOnly\n\t */\n\tdirty: {\n\t\tset: function(val) {\n\t\t\tthis.verticesDirty = val;\n\t\t\tthis.indicesDirty = val;\n\t\t}\n\t},\n\n\t/**\n\t * Creates a new Mesh with the provided parameters.\n\t *\n\t * If numIndices is 0 or falsy, no index buffer will be used\n\t * and indices will be an empty ArrayBuffer and a null indexBuffer.\n\t * \n\t * If isStatic is true, then vertexUsage and indexUsage will\n\t * be set to gl.STATIC_DRAW. Otherwise they will use gl.DYNAMIC_DRAW.\n\t * You may want to adjust these after initialization for further control.\n\t * \n\t * @param  {WebGLContext}  context the context for management\n\t * @param  {Boolean} isStatic      a hint as to whether this geometry is static\n\t * @param  {[type]}  numVerts      [description]\n\t * @param  {[type]}  numIndices    [description]\n\t * @param  {[type]}  vertexAttribs [description]\n\t * @return {[type]}                [description]\n\t */\n\tinitialize: function Mesh(context, isStatic, numVerts, numIndices, vertexAttribs) {\n\t\t//TODO: use options here...\n\t\tif (!numVerts)\n\t\t\tthrow \"numVerts not specified, must be > 0\";\n\n\t\tBaseObject.call(this, context);\n\n\t\tthis.gl = this.context.gl;\n\t\t\n\t\tthis.numVerts = null;\n\t\tthis.numIndices = null;\n\t\t\n\t\tthis.vertices = null;\n\t\tthis.indices = null;\n\t\tthis.vertexBuffer = null;\n\t\tthis.indexBuffer = null;\n\n\t\tthis.verticesDirty = true;\n\t\tthis.indicesDirty = true;\n\t\tthis.indexUsage = null;\n\t\tthis.vertexUsage = null;\n\n\t\t/** \n\t\t * @property\n\t\t * @private\n\t\t */\n\t\tthis._vertexAttribs = null;\n\n\t\t/** \n\t\t * The stride for one vertex _in bytes_. \n\t\t * \n\t\t * @property {Number} vertexStride\n\t\t */\n\t\tthis.vertexStride = null;\n\n\t\tthis.numVerts = numVerts;\n\t\tthis.numIndices = numIndices || 0;\n\t\tthis.vertexUsage = isStatic ? this.gl.STATIC_DRAW : this.gl.DYNAMIC_DRAW;\n\t\tthis.indexUsage  = isStatic ? this.gl.STATIC_DRAW : this.gl.DYNAMIC_DRAW;\n\t\tthis._vertexAttribs = vertexAttribs || [];\n\t\t\n\t\tthis.indicesDirty = true;\n\t\tthis.verticesDirty = true;\n\n\t\t//determine the vertex stride based on given attributes\n\t\tvar totalNumComponents = 0;\n\t\tfor (var i=0; i<this._vertexAttribs.length; i++)\n\t\t\ttotalNumComponents += this._vertexAttribs[i].offsetCount;\n\t\tthis.vertexStride = totalNumComponents * 4; // in bytes\n\n\t\tthis.vertices = new Float32Array(this.numVerts);\n\t\tthis.indices = new Uint16Array(this.numIndices);\n\n\t\t//add this VBO to the managed cache\n\t\tthis.context.addManagedObject(this);\n\n\t\tthis.create();\n\t},\n\n\t//recreates the buffers on context loss\n\tcreate: function() {\n\t\tthis.gl = this.context.gl;\n\t\tvar gl = this.gl;\n\t\tthis.vertexBuffer = gl.createBuffer();\n\n\t\t//ignore index buffer if we haven't specified any\n\t\tthis.indexBuffer = this.numIndices > 0\n\t\t\t\t\t? gl.createBuffer()\n\t\t\t\t\t: null;\n\n\t\tthis.dirty = true;\n\t},\n\n\tdestroy: function() {\n\t\tthis.vertices = null;\n\t\tthis.indices = null;\n\t\tif (this.vertexBuffer && this.gl)\n\t\t\tthis.gl.deleteBuffer(this.vertexBuffer);\n\t\tif (this.indexBuffer && this.gl)\n\t\t\tthis.gl.deleteBuffer(this.indexBuffer);\n\t\tthis.vertexBuffer = null;\n\t\tthis.indexBuffer = null;\n\t\tif (this.context)\n\t\t\tthis.context.removeManagedObject(this);\n\t\tthis.gl = null;\n\t\tthis.context = null;\n\t},\n\n\t_updateBuffers: function(ignoreBind, subDataLength) {\n\t\tvar gl = this.gl;\n\n\t\t//bind our index data, if we have any\n\t\tif (this.numIndices > 0) {\n\t\t\tif (!ignoreBind)\n\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n\t\t\t//update the index data\n\t\t\tif (this.indicesDirty) {\n\t\t\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, this.indexUsage);\n\t\t\t\tthis.indicesDirty = false;\n\t\t\t}\n\t\t}\n\n\t\t//bind our vertex data\n\t\tif (!ignoreBind)\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n\t\t//update our vertex data\n\t\tif (this.verticesDirty) {\n\t\t\tif (subDataLength) {\n\t\t\t\t// TODO: When decoupling VBO/IBO be sure to give better subData support..\n\t\t\t\tvar view = this.vertices.subarray(0, subDataLength);\n\t\t\t\tgl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n\t\t\t} else {\n\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, this.vertices, this.vertexUsage);\t\n\t\t\t}\n\n\t\t\t\n\t\t\tthis.verticesDirty = false;\n\t\t}\n\t},\n\n\tdraw: function(primitiveType, count, offset, subDataLength) {\n\t\tif (count === 0)\n\t\t\treturn;\n\n\t\tvar gl = this.gl;\n\t\t\n\t\toffset = offset || 0;\n\n\t\t//binds and updates our buffers. pass ignoreBind as true\n\t\t//to avoid binding unnecessarily\n\t\tthis._updateBuffers(true, subDataLength);\n\n\t\tif (this.numIndices > 0) { \n\t\t\tgl.drawElements(primitiveType, count, \n\t\t\t\t\t\tgl.UNSIGNED_SHORT, offset * 2); //* Uint16Array.BYTES_PER_ELEMENT\n\t\t} else\n\t\t\tgl.drawArrays(primitiveType, offset, count);\n\t},\n\n\t//binds this mesh's vertex attributes for the given shader\n\tbind: function(shader) {\n\t\tvar gl = this.gl;\n\n\t\tvar offset = 0;\n\t\tvar stride = this.vertexStride;\n\n\t\t//bind and update our vertex data before binding attributes\n\t\tthis._updateBuffers();\n\n\t\t//for each attribtue\n\t\tfor (var i=0; i<this._vertexAttribs.length; i++) {\n\t\t\tvar a = this._vertexAttribs[i];\n\n\t\t\t//location of the attribute\n\t\t\tvar loc = a.location === null \n\t\t\t\t\t? shader.getAttributeLocation(a.name)\n\t\t\t\t\t: a.location;\n\n\t\t\t//TODO: We may want to skip unfound attribs\n\t\t\t// if (loc!==0 && !loc)\n\t\t\t// \tconsole.warn(\"WARN:\", a.name, \"is not enabled\");\n\n\t\t\t//first, enable the vertex array\n\t\t\tgl.enableVertexAttribArray(loc);\n\n\t\t\t//then specify our vertex format\n\t\t\tgl.vertexAttribPointer(loc, a.numComponents, a.type || gl.FLOAT, \n\t\t\t\t\t\t\t\t   a.normalize, stride, offset);\n\n\t\t\t//and increase the offset...\n\t\t\toffset += a.offsetCount * 4; //in bytes\n\t\t}\n\t},\n\n\tunbind: function(shader) {\n\t\tvar gl = this.gl;\n\n\t\t//for each attribtue\n\t\tfor (var i=0; i<this._vertexAttribs.length; i++) {\n\t\t\tvar a = this._vertexAttribs[i];\n\n\t\t\t//location of the attribute\n\t\t\tvar loc = a.location === null \n\t\t\t\t\t? shader.getAttributeLocation(a.name)\n\t\t\t\t\t: a.location;\n\n\t\t\t//first, enable the vertex array\n\t\t\tgl.disableVertexAttribArray(loc);\n\t\t}\n\t}\n});\n\nMesh.Attrib = new Class({\n\n\tname: null,\n\tnumComponents: null,\n\tlocation: null,\n\ttype: null,\n\n\t/**\n\t * Mesh vertex attribute holder.\n\t * \n\t * Location is optional and for advanced users that\n\t * want vertex arrays to match across shaders. Any non-numerical\n\t * value will be converted to null, and ignored. If a numerical\n\t * value is given, it will override the position of this attribute\n\t * when given to a mesh.\n\t *\n\t * @class  Mesh.Attrib\n\t * @constructor\n\t * @param {String} name the name of the attribute\n\t * @param {Number} numComponents the number of components, e.g. 2 for vec2\n\t * @param {Number} location optional attribute index location\n\t * @param {Number} type defaults to GL_FLOAT \n\t * @param {Number} normalize whether to normalize to 0-1, default false\n\t */\n\tinitialize: function(name, numComponents, location, type, normalize, offsetCount) {\n\t\tthis.name = name;\n\t\tthis.numComponents = numComponents;\n\t\tthis.location = typeof location === \"number\" ? location : null;\n\t\tthis.type = type;\n\t\tthis.normalize = Boolean(normalize);\n\t\tthis.offsetCount = typeof offsetCount === \"number\" ? offsetCount : this.numComponents;\n\t}\n});\n\n\nmodule.exports = Mesh;"],"mappings":"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"},"metadata":{},"sourceType":"script"}