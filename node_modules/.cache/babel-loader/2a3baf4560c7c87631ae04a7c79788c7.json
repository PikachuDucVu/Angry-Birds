{"ast":null,"code":"/**\n * An abstract batcher for dynamic geometry. This handles\n * the basics, like setting blend functions, color, and so forth.\n * \n * @module kami-base-batch\n */\nvar Class = require('klasse');\n\nvar Mesh = require('kami-mesh-buffer');\n\nvar BaseObject = require('kami-util').BaseObject;\n\nvar colorToFloat = require('number-util').colorToFloat;\n\nvar BaseMixins = require('./mixins');\n/** \n * A batcher, typically used for quads (2 tris, indexed), but may\n * also be used for other dynamic types of geometry. This is generally\n * not static; the vertex buffers are using DYNAMIC_DRAW for performance.\n * \n * This is used internally; users should look at \n * {{#crossLink \"SpriteBatch\"}}{{/crossLink}} instead, which inherits from this\n * class. \n * \n * The batcher itself is not managed by WebGLContext; however, it makes\n * use of Mesh and Texture which will be managed. For this reason, the batcher\n * does not hold a direct reference to the GL state.\n *\n * Subclasses must implement the following:  \n * {{#crossLink \"BaseBatch/_createShader:method\"}}{{/crossLink}}  \n * {{#crossLink \"BaseBatch/_createVertexAttributes:method\"}}{{/crossLink}}  \n * {{#crossLink \"BaseBatch/getVertexSize:method\"}}{{/crossLink}}  \n * \n * @class BaseBatch\n * @protected\n * @abstract\n * \n * @constructor\n * @param {WebGLContext} context the context this batcher belongs to\n * @param {Object} options the options\n * @param {Number} options.size the optional size of this batch, i.e. max number of quads\n * @default  500\n */\n\n\nvar BaseBatch = new Class({\n  Mixins: BaseMixins,\n  //Constructor\n  initialize: function BaseBatch(context, options) {\n    BaseObject.call(this, context);\n    options = options || {};\n\n    var shader = this._createShader();\n\n    this.idx = 0;\n    this.mesh = this._createMesh(options.size); //set up the properties for our base batch...\n\n    BaseMixins.call(this, this.context.gl, shader);\n  },\n\n  /**\n   * Called from the constructor to create a new Mesh \n   * based on the expected batch size. Should set up\n   * verts & indices properly.\n   *\n   * Users should not call this directly; instead, it\n   * should only be implemented by subclasses.\n   * \n   * @method _createMesh\n   * @param {Number} size the size passed through the constructor\n   */\n  _createMesh: function (size) {\n    size = size || 500; // 65535 is max index, so 65535 / 6 = 10922.\n\n    if (size > 10922) throw \"Can't have more than 10922 sprites per batch: \" + size; //the total number of floats in our batch\n\n    var numVerts = size * 4 * this.getVertexSize(); //the total number of indices in our batch\n\n    var numIndices = size * 6;\n    var gl = this.context.gl; //vertex data\n\n    this.vertices = new Float32Array(numVerts); //index data\n\n    this.indices = new Uint16Array(numIndices);\n\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n      this.indices[i + 0] = j + 0;\n      this.indices[i + 1] = j + 1;\n      this.indices[i + 2] = j + 2;\n      this.indices[i + 3] = j + 0;\n      this.indices[i + 4] = j + 2;\n      this.indices[i + 5] = j + 3;\n    }\n\n    var mesh = new Mesh(this.context, false, numVerts, numIndices, this._createVertexAttributes());\n    mesh.vertices = this.vertices;\n    mesh.indices = this.indices;\n    mesh.vertexUsage = gl.DYNAMIC_DRAW;\n    mesh.indexUsage = gl.STATIC_DRAW;\n    mesh.dirty = true;\n    return mesh;\n  },\n\n  /**\n   * Returns a shader for this batch. If you plan to support\n   * multiple instances of your batch, it may or may not be wise\n   * to use a shared shader to save resources.\n   * \n   * This method initially throws an error; so it must be overridden by\n   * subclasses of BaseBatch.\n   *\n   * @method  _createShader\n   * @return {Number} the size of a vertex, in # of floats\n   */\n  _createShader: function () {\n    throw \"_createShader not implemented\";\n  },\n\n  /**\n   * Returns an array of vertex attributes for this mesh; \n   * subclasses should implement this with the attributes \n   * expected for their batch.\n   *\n   * This method initially throws an error; so it must be overridden by\n   * subclasses of BaseBatch.\n   *\n   * @method _createVertexAttributes\n   * @return {Array} an array of Mesh.VertexAttrib objects\n   */\n  _createVertexAttributes: function () {\n    throw \"_createVertexAttributes not implemented\";\n  },\n\n  /**\n   * Returns the number of floats per vertex for this batcher.\n   * \n   * This method initially throws an error; so it must be overridden by\n   * subclasses of BaseBatch.\n   *\n   * @method  getVertexSize\n   * @return {Number} the size of a vertex, in # of floats\n   */\n  getVertexSize: function () {\n    throw \"getVertexSize not implemented\";\n  },\n\n  /** \n   * Begins the sprite batch. This will bind the shader\n   * and mesh. Subclasses may want to disable depth or \n   * set up blending.\n   *\n   * @method  begin\n   */\n  begin: function () {\n    if (this.drawing) throw \"batch.end() must be called before begin\";\n    this.drawing = true;\n    this.shader.bind(); //bind the attributes now to avoid redundant calls\n\n    this.mesh.bind(this.shader);\n\n    if (this._blendingEnabled) {\n      var gl = this.context.gl;\n      gl.enable(gl.BLEND);\n    }\n  },\n\n  /** \n   * Ends the sprite batch. This will flush any remaining \n   * data and set GL state back to normal.\n   * \n   * @method  end\n   */\n  end: function () {\n    if (!this.drawing) throw \"batch.begin() must be called before end\";\n    if (this.idx > 0) this.flush();\n    this.drawing = false;\n    this.mesh.unbind(this.shader);\n\n    if (this._blendingEnabled) {\n      var gl = this.context.gl;\n      gl.disable(gl.BLEND);\n    }\n  },\n\n  /** \n   * Called before rendering to bind new textures.\n   * This method does nothing by default.\n   *\n   * @method  _preRender\n   */\n  _preRender: function () {},\n\n  /**\n   * Flushes the batch by pushing the current data\n   * to GL.\n   * \n   * @method flush\n   */\n  flush: function () {\n    if (this.idx === 0) return;\n    var gl = this.context.gl; //premultiplied alpha\n\n    if (this._blendingEnabled) {\n      //set either to null if you want to call your own \n      //blendFunc or blendFuncSeparate\n      if (this._blendSrc && this._blendDst) gl.blendFunc(this._blendSrc, this._blendDst);\n    }\n\n    this._preRender(); //number of sprites in batch\n\n\n    var numComponents = this.getVertexSize();\n    var spriteCount = this.idx / (numComponents * 4); //draw the sprites\n\n    this.mesh.verticesDirty = true;\n    this.mesh.draw(gl.TRIANGLES, spriteCount * 6, 0, this.idx);\n    this.idx = 0;\n  },\n\n  /**\n   * Destroys the batch, deleting its buffers and removing it from the\n   * WebGLContext management. Trying to use this\n   * batch after destroying it can lead to unpredictable behaviour.\n   *\n   * If `ownsShader` is true, this will also delete the `defaultShader` object.\n   * \n   * @method destroy\n   */\n  destroy: function () {\n    this.vertices = null;\n    this.indices = null;\n    this.maxVertices = 0;\n    if (this.ownsShader && this.defaultShader) this.defaultShader.destroy();\n    this.defaultShader = null;\n    this._shader = null; // remove reference to whatever shader is currently being used\n\n    if (this.mesh) this.mesh.destroy();\n    this.mesh = null;\n  }\n});\nmodule.exports = BaseBatch;","map":{"version":3,"names":["Class","require","Mesh","BaseObject","colorToFloat","BaseMixins","BaseBatch","Mixins","initialize","context","options","call","shader","_createShader","idx","mesh","_createMesh","size","gl","numVerts","getVertexSize","numIndices","vertices","Float32Array","indices","Uint16Array","i","j","_createVertexAttributes","vertexUsage","DYNAMIC_DRAW","indexUsage","STATIC_DRAW","dirty","begin","drawing","bind","_blendingEnabled","enable","BLEND","end","flush","unbind","disable","_preRender","_blendSrc","_blendDst","blendFunc","numComponents","spriteCount","verticesDirty","draw","TRIANGLES","destroy","maxVertices","ownsShader","defaultShader","_shader","module","exports"],"sources":["D:/projects/test-game/node_modules/kami-base-batch/index.js"],"sourcesContent":["/**\n * An abstract batcher for dynamic geometry. This handles\n * the basics, like setting blend functions, color, and so forth.\n * \n * @module kami-base-batch\n */\n\nvar Class = require('klasse');\nvar Mesh = require('kami-mesh-buffer');\nvar BaseObject = require('kami-util').BaseObject;\n\nvar colorToFloat = require('number-util').colorToFloat;\n\nvar BaseMixins = require('./mixins');\n\n/** \n * A batcher, typically used for quads (2 tris, indexed), but may\n * also be used for other dynamic types of geometry. This is generally\n * not static; the vertex buffers are using DYNAMIC_DRAW for performance.\n * \n * This is used internally; users should look at \n * {{#crossLink \"SpriteBatch\"}}{{/crossLink}} instead, which inherits from this\n * class. \n * \n * The batcher itself is not managed by WebGLContext; however, it makes\n * use of Mesh and Texture which will be managed. For this reason, the batcher\n * does not hold a direct reference to the GL state.\n *\n * Subclasses must implement the following:  \n * {{#crossLink \"BaseBatch/_createShader:method\"}}{{/crossLink}}  \n * {{#crossLink \"BaseBatch/_createVertexAttributes:method\"}}{{/crossLink}}  \n * {{#crossLink \"BaseBatch/getVertexSize:method\"}}{{/crossLink}}  \n * \n * @class BaseBatch\n * @protected\n * @abstract\n * \n * @constructor\n * @param {WebGLContext} context the context this batcher belongs to\n * @param {Object} options the options\n * @param {Number} options.size the optional size of this batch, i.e. max number of quads\n * @default  500\n */\nvar BaseBatch = new Class({\n\n\tMixins: BaseMixins,\n\n\t//Constructor\n\tinitialize: function BaseBatch(context, options) {\n\t\tBaseObject.call(this, context);\n\t\toptions = options||{};\n\n\t\tvar shader = this._createShader();\n\t\t\n\t\tthis.idx = 0;\n\n\t\tthis.mesh = this._createMesh(options.size);\n\n\t\t//set up the properties for our base batch...\n\t\tBaseMixins.call(this, this.context.gl, shader);\n\t},\n\n\t/**\n\t * Called from the constructor to create a new Mesh \n\t * based on the expected batch size. Should set up\n\t * verts & indices properly.\n\t *\n\t * Users should not call this directly; instead, it\n\t * should only be implemented by subclasses.\n\t * \n\t * @method _createMesh\n\t * @param {Number} size the size passed through the constructor\n\t */\n\t_createMesh: function(size) {\n\t\tsize = size||500;\n\t\t// 65535 is max index, so 65535 / 6 = 10922.\n\t\tif (size > 10922)\n\t\t\tthrow \"Can't have more than 10922 sprites per batch: \" + size;\n\t\t\n\t\t//the total number of floats in our batch\n\t\tvar numVerts = size * 4 * this.getVertexSize();\n\t\t//the total number of indices in our batch\n\t\tvar numIndices = size * 6;\n\t\tvar gl = this.context.gl;\n\n\t\t//vertex data\n\t\tthis.vertices = new Float32Array(numVerts);\n\t\t//index data\n\t\tthis.indices = new Uint16Array(numIndices); \n\t\t\n\t\tfor (var i=0, j=0; i < numIndices; i += 6, j += 4) \n\t\t{\n\t\t\tthis.indices[i + 0] = j + 0; \n\t\t\tthis.indices[i + 1] = j + 1;\n\t\t\tthis.indices[i + 2] = j + 2;\n\t\t\tthis.indices[i + 3] = j + 0;\n\t\t\tthis.indices[i + 4] = j + 2;\n\t\t\tthis.indices[i + 5] = j + 3;\n\t\t}\n\n\t\tvar mesh = new Mesh(this.context, false, \n\t\t\t\t\t\tnumVerts, numIndices, this._createVertexAttributes());\n\t\tmesh.vertices = this.vertices;\n\t\tmesh.indices = this.indices;\n\t\tmesh.vertexUsage = gl.DYNAMIC_DRAW;\n\t\tmesh.indexUsage = gl.STATIC_DRAW;\n\t\tmesh.dirty = true;\n\t\treturn mesh;\n\t},\n\n\t/**\n\t * Returns a shader for this batch. If you plan to support\n\t * multiple instances of your batch, it may or may not be wise\n\t * to use a shared shader to save resources.\n\t * \n\t * This method initially throws an error; so it must be overridden by\n\t * subclasses of BaseBatch.\n\t *\n\t * @method  _createShader\n\t * @return {Number} the size of a vertex, in # of floats\n\t */\n\t_createShader: function() {\n\t\tthrow \"_createShader not implemented\"\n\t},\t\n\n\t/**\n\t * Returns an array of vertex attributes for this mesh; \n\t * subclasses should implement this with the attributes \n\t * expected for their batch.\n\t *\n\t * This method initially throws an error; so it must be overridden by\n\t * subclasses of BaseBatch.\n\t *\n\t * @method _createVertexAttributes\n\t * @return {Array} an array of Mesh.VertexAttrib objects\n\t */\n\t_createVertexAttributes: function() {\n\t\tthrow \"_createVertexAttributes not implemented\";\n\t},\n\n\n\t/**\n\t * Returns the number of floats per vertex for this batcher.\n\t * \n\t * This method initially throws an error; so it must be overridden by\n\t * subclasses of BaseBatch.\n\t *\n\t * @method  getVertexSize\n\t * @return {Number} the size of a vertex, in # of floats\n\t */\n\tgetVertexSize: function() {\n\t\tthrow \"getVertexSize not implemented\";\n\t},\n\n\t\n\t/** \n\t * Begins the sprite batch. This will bind the shader\n\t * and mesh. Subclasses may want to disable depth or \n\t * set up blending.\n\t *\n\t * @method  begin\n\t */\n\tbegin: function()  {\n\t\tif (this.drawing) \n\t\t\tthrow \"batch.end() must be called before begin\";\n\t\tthis.drawing = true;\n\n\t\tthis.shader.bind();\n\n\t\t//bind the attributes now to avoid redundant calls\n\t\tthis.mesh.bind(this.shader);\n\n\t\tif (this._blendingEnabled) {\n\t\t\tvar gl = this.context.gl;\n\t\t\tgl.enable(gl.BLEND);\n\t\t}\n\t},\n\n\t/** \n\t * Ends the sprite batch. This will flush any remaining \n\t * data and set GL state back to normal.\n\t * \n\t * @method  end\n\t */\n\tend: function()  {\n\t\tif (!this.drawing)\n\t\t\tthrow \"batch.begin() must be called before end\";\n\t\tif (this.idx > 0)\n\t\t\tthis.flush();\n\t\tthis.drawing = false;\n\n\t\tthis.mesh.unbind(this.shader);\n\n\t\tif (this._blendingEnabled) {\n\t\t\tvar gl = this.context.gl;\n\t\t\tgl.disable(gl.BLEND);\n\t\t}\n\t},\n\n\t/** \n\t * Called before rendering to bind new textures.\n\t * This method does nothing by default.\n\t *\n\t * @method  _preRender\n\t */\n\t_preRender: function()  {\n\t},\n\n\t/**\n\t * Flushes the batch by pushing the current data\n\t * to GL.\n\t * \n\t * @method flush\n\t */\n\tflush: function()  {\n\t\tif (this.idx===0)\n\t\t\treturn;\n\n\t\tvar gl = this.context.gl;\n\n\t\t//premultiplied alpha\n\t\tif (this._blendingEnabled) {\n\t\t\t//set either to null if you want to call your own \n\t\t\t//blendFunc or blendFuncSeparate\n\t\t\tif (this._blendSrc && this._blendDst)\n\t\t\t\tgl.blendFunc(this._blendSrc, this._blendDst); \n\t\t}\n\n\t\tthis._preRender();\n\n\t\t//number of sprites in batch\n\t\tvar numComponents = this.getVertexSize();\n\t\tvar spriteCount = (this.idx / (numComponents * 4));\n\t\t\n\t\t//draw the sprites\n\t\tthis.mesh.verticesDirty = true;\n\t\tthis.mesh.draw(gl.TRIANGLES, spriteCount * 6, 0, this.idx);\n\n\t\tthis.idx = 0;\n\t},\n\n\t/**\n\t * Destroys the batch, deleting its buffers and removing it from the\n\t * WebGLContext management. Trying to use this\n\t * batch after destroying it can lead to unpredictable behaviour.\n\t *\n\t * If `ownsShader` is true, this will also delete the `defaultShader` object.\n\t * \n\t * @method destroy\n\t */\n\tdestroy: function() {\n\t\tthis.vertices = null;\n\t\tthis.indices = null;\n\t\tthis.maxVertices = 0;\n\n\t\tif (this.ownsShader && this.defaultShader)\n\t\t\tthis.defaultShader.destroy();\n\t\tthis.defaultShader = null;\n\t\tthis._shader = null; // remove reference to whatever shader is currently being used\n\n\t\tif (this.mesh) \n\t\t\tthis.mesh.destroy();\n\t\tthis.mesh = null;\n\t}\n});\n\nmodule.exports = BaseBatch;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}