{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GlyphLayout = void 0;\n\nvar GlyphRun_1 = require(\"./GlyphRun\");\n\nvar Utils_1 = require(\"./Utils\");\n\nvar GlyphLayout = /*#__PURE__*/function () {\n  function GlyphLayout(font, str, start, end, color, targetWidth, hAlign, wrap, truncate) {\n    var _this = this;\n\n    _classCallCheck(this, GlyphLayout);\n\n    this.epsilon = 0.0001;\n    this.glyphRunPool = Utils_1.Pools.get('GlyphRun', function () {\n      return new GlyphRun_1.GlyphRun();\n    });\n    this.colorStack = new Array(4);\n    this.runs = [];\n    this.colors = [];\n\n    this.setText = function (font, str, start, end, color, targetWidth, hAlign, wrap, truncate) {\n      _this.reset();\n\n      var fontData = font.data;\n\n      if (start === end) {\n        // Empty string.\n        _this.height = fontData.capHeight;\n        return;\n      } // Avoid wrapping one line per character, which is very inefficient.\n\n\n      if (wrap) targetWidth = Math.max(targetWidth, fontData.spaceXadvance * 3);\n      var wrapOrTruncate = wrap || truncate != null;\n      var currentColor = color.toIntBits();\n      var nextColor = currentColor;\n\n      _this.colors.shift();\n\n      var markupEnabled = fontData.markupEnabled;\n      if (markupEnabled) _this.colorStack.push(currentColor);\n      var isLastRun = false;\n      var y = 0;\n      var down = fontData.down;\n      var lineRun = null; // Collects glyphs for the current line.\n\n      var lastGlyph = null; // Last glyph of the previous run on the same line, used for kerning between runs.\n\n      var runStart = start;\n\n      while (true) {\n        var runEnd = void 0;\n        var newline = false;\n\n        if (start === end) {\n          // End of text.\n          if (runStart === end) break; // No run to process, we're done.\n\n          runEnd = end; // Process the final run.\n\n          isLastRun = true;\n        } else {\n          // Each run is delimited by newline or left square bracket.\n          switch (str.charAt(start++)) {\n            case '\\n':\n              // End of line.\n              runEnd = start - 1;\n              newline = true;\n              break;\n            // Fall through.\n\n            default:\n              continue;\n          }\n        } // eslint-disable-next-line no-labels\n\n\n        runEnded: {\n          // Store the run that has ended.\n          var run = _this.glyphRunPool.obtain();\n\n          run.x = 0;\n          run.y = y;\n          fontData.getGlyphs(run, str, runStart, runEnd, lastGlyph);\n          _this.glyphCount += run.glyphs.length;\n\n          if (nextColor !== currentColor) {\n            // Can only be different if markupEnabled.\n            if (_this.colors[_this.colors.length - 2] === _this.glyphCount) {\n              // Consecutive color changes, or after an empty run, or at the beginning of the string.\n              _this.colors[_this.colors.length - 1] = nextColor;\n            } else {\n              _this.colors.push(_this.glyphCount);\n\n              _this.colors.push(nextColor);\n            }\n\n            currentColor = nextColor;\n          }\n\n          if (run.glyphs.length === 0) {\n            _this.glyphRunPool.free(run);\n\n            if (!lineRun) break; // Otherwise wrap and truncate must still be processed for lineRun.\n          } else if (!lineRun) {\n            lineRun = run;\n\n            _this.runs.push(lineRun);\n          } else {\n            lineRun.appendRun(run);\n\n            _this.glyphRunPool.free(run);\n          }\n\n          if (newline || isLastRun) {\n            _this.setLastGlyphXAdvance(fontData, lineRun);\n\n            lastGlyph = null;\n          } else lastGlyph = lineRun.glyphs[lineRun.glyphs.length - 1];\n\n          if (!wrapOrTruncate || lineRun.glyphs.length === 0) {\n            // eslint-disable-next-line no-labels\n            break runEnded; // No wrap or truncate, or no glyphs.\n          }\n\n          if (newline || isLastRun) {\n            // Wrap or truncate. First xadvance is the first glyph's X offset relative to the drawing position.\n            var runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.\n\n            for (var i = 2; i < lineRun.xAdvances.length; i++) {\n              var glyph = lineRun.glyphs[i - 1];\n\n              var glyphWidth = _this.getGlyphWidth(glyph, fontData);\n\n              if (runWidth + glyphWidth - _this.epsilon <= targetWidth) {\n                // Glyph fits.\n                runWidth += lineRun.xAdvances[i];\n                continue;\n              }\n\n              if (truncate != null) {\n                // Truncate.\n                _this.truncate(fontData, lineRun, targetWidth, truncate);\n\n                break;\n              } // Wrap.\n\n\n              var wrapIndex = fontData.getWrapIndex(lineRun.glyphs, i);\n\n              if (wrapIndex === 0 && lineRun.x === 0 || // Require at least one glyph per line.\n              wrapIndex >= lineRun.glyphs.length) {\n                // Wrap at least the glyph that didn't fit.\n                wrapIndex = i - 1;\n              }\n\n              lineRun = _this.wrap(fontData, lineRun, wrapIndex); // eslint-disable-next-line no-labels\n\n              if (!lineRun) break runEnded; // All wrapped glyphs were whitespace.\n\n              _this.runs.push(lineRun);\n\n              y += down;\n              lineRun.x = 0;\n              lineRun.y = y; // Start the wrap loop again, another wrap might be necessary.\n\n              runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.\n\n              i = 1;\n            }\n          }\n        }\n\n        if (newline) {\n          lineRun = null;\n          lastGlyph = null; // Next run will be on the next line.\n\n          if (runEnd === runStart) // Blank line.\n            y += down * fontData.blankLineScale;else y += down;\n        }\n\n        runStart = start;\n      }\n\n      _this.height = fontData.capHeight + Math.abs(y);\n\n      _this.calculateWidths(fontData);\n\n      _this.alignRuns(targetWidth, hAlign); // Clear the color stack.\n\n\n      if (markupEnabled) _this.colorStack.length = 0;\n    };\n\n    this.calculateWidths = function (fontData) {\n      var _a;\n\n      var width = 0;\n\n      var runsItems = _toConsumableArray(_this.runs);\n\n      for (var i = 0, n = _this.runs.length; i < n; i++) {\n        var run = runsItems[i];\n        var xAdvances = run.xAdvances;\n        var runWidth = run.x + xAdvances[0];\n        var max = 0; // run.x is needed to ensure floats are rounded same as above.\n\n        var glyphs = run.glyphs;\n\n        for (var ii = 0; ii < run.glyphs.length;) {\n          var glyph = glyphs[ii];\n\n          var glyphWidth = _this.getGlyphWidth(glyph, fontData);\n\n          max = Math.max(max, runWidth + glyphWidth); // A glyph can extend past the right edge of subsequent glyphs.\n\n          ii++;\n          runWidth += (_a = xAdvances[ii]) !== null && _a !== void 0 ? _a : 0;\n        }\n\n        run.width = Math.max(runWidth, max) - run.x;\n        width = Math.max(width, run.x + (isNaN(run.width) ? runWidth : run.width));\n      }\n\n      _this.width = width;\n    };\n\n    this.alignRuns = function (targetWidth, halign) {\n      if ((halign & Utils_1.Align.left) === 0) {\n        // Not left aligned, so must be center or right aligned.\n        var center = (halign & Utils_1.Align.center) !== 0;\n\n        var runsItems = _toConsumableArray(_this.runs);\n\n        for (var i = 0, n = _this.runs.length; i < n; i++) {\n          var run = runsItems[i];\n          run.x += center ? 0.5 * (targetWidth - run.width) : targetWidth - run.width;\n        }\n      }\n    };\n    /** @param truncate May be empty string. */\n\n\n    this.truncate = function (fontData, run, targetWidth, truncate) {\n      var glyphCount = run.glyphs.length; // Determine truncate string size.\n\n      var truncateRun = _this.glyphRunPool.obtain();\n\n      fontData.getGlyphs(truncateRun, truncate, 0, truncate.length, null);\n      var truncateWidth = 0;\n\n      if (truncateRun.xAdvances.length > 0) {\n        _this.setLastGlyphXAdvance(fontData, truncateRun);\n\n        var _xAdvances = truncateRun.xAdvances; // Skip first for tight bounds.\n\n        for (var i = 1; i < truncateRun.xAdvances.length; i++) {\n          truncateWidth += _xAdvances[i];\n        }\n      }\n\n      targetWidth -= truncateWidth; // Determine visible glyphs.\n\n      var count = 0;\n      var width = run.x;\n      var xAdvances = run.xAdvances;\n\n      while (count < run.xAdvances.length) {\n        var xAdvance = xAdvances[count];\n        width += xAdvance;\n        if (width > targetWidth) break;\n        count++;\n      }\n\n      if (count > 1) {\n        // Some run glyphs fit, append truncate glyphs.\n        if (count - 1 >= 0 && run.glyphs.length > count - 1) {\n          for (var _i = count - 1; _i < run.glyphs.length; _i++) {\n            run.glyphs.splice(_i, 1);\n          }\n        }\n\n        if (count >= 0 && run.xAdvances.length > count) {\n          for (var _i2 = count; _i2 < run.xAdvances.length; _i2++) {\n            run.xAdvances.splice(_i2, 1);\n          }\n        }\n\n        _this.setLastGlyphXAdvance(fontData, run);\n\n        if (truncateRun.xAdvances.length > 0) {\n          Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 1, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length - 1);\n        }\n      } else {\n        // No run glyphs fit, use only truncate glyphs.\n        run.glyphs.length = 0;\n        run.xAdvances.length = 0; // run.xAdvances.addAll(truncateRun.xAdvances);\n\n        Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 0, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length);\n      }\n\n      var droppedGlyphCount = glyphCount - run.glyphs.length;\n\n      if (droppedGlyphCount > 0) {\n        _this.glyphCount -= droppedGlyphCount;\n\n        if (fontData.markupEnabled) {\n          while (_this.colors.length > 2 && _this.colors[_this.colors.length - 2] >= _this.glyphCount) {\n            _this.colors.length -= 2;\n          }\n        }\n      }\n\n      Utils_1.Utils.arrayCopy(truncateRun.glyphs, 0, run.glyphs, run.glyphs.length, truncateRun.glyphs.length);\n      _this.glyphCount += truncate.length;\n\n      _this.glyphRunPool.free(truncateRun);\n    };\n    /** Sets the xadvance of the last glyph to use its width instead of xadvance. */\n\n\n    this.setLastGlyphXAdvance = function (fontData, run) {\n      var last = run.glyphs[run.glyphs.length - 1];\n      if (!last.fixedWidth) run.xAdvances[run.xAdvances.length - 1] = _this.getGlyphWidth(last, fontData);\n    };\n    /** Returns the distance from the glyph's drawing position to the right edge of the glyph. */\n\n\n    this.getGlyphWidth = function (glyph, fontData) {\n      return (glyph.width + glyph.xoffset) * fontData.scaleX - fontData.padRight;\n    };\n    /** Returns an X offset for the first glyph so when drawn, none of it is left of the line's drawing position. */\n\n\n    this.getLineOffset = function (glyphs, fontData) {\n      return -glyphs[0].xoffset * fontData.scaleX - fontData.padLeft;\n    };\n\n    this.reset = function () {\n      _this.glyphRunPool.freeAll(_this.runs);\n\n      _this.runs.length = 0;\n      _this.colors.length = 0;\n      _this.glyphCount = 0;\n      _this.width = 0;\n      _this.height = 0;\n    };\n\n    this.setText(font, str, start, end, color, targetWidth, hAlign, wrap, truncate);\n  }\n  /** Breaks a run into two runs at the specified wrapIndex.\r\n   * @return May be null if second run is all whitespace. */\n\n\n  _createClass(GlyphLayout, [{\n    key: \"wrap\",\n    value: function wrap(fontData, first, wrapIndex) {\n      var glyphCount = first.glyphs.length;\n      var glyphs2 = first.glyphs; // Starts with all the glyphs.\n\n      var xAdvances2 = first.xAdvances; // Starts with all the xadvances.\n      // Skip whitespace before the wrap index.\n\n      var firstEnd = wrapIndex;\n\n      for (; firstEnd > 0; firstEnd--) {\n        if (!fontData.isWhitespace(glyphs2[firstEnd - 1].id)) break;\n      } // Skip whitespace after the wrap index.\n\n\n      var secondStart = wrapIndex;\n\n      for (; secondStart < glyphCount; secondStart++) {\n        if (!fontData.isWhitespace(glyphs2[secondStart].id)) break;\n      } // Copy wrapped glyphs and xadvances to second run.\n      // The second run will contain the remaining glyph data, so swap instances rather than copying.\n\n\n      var second;\n\n      if (secondStart < glyphCount) {\n        second = this.glyphRunPool.obtain();\n        var glyphs1 = second.glyphs; // Starts empty.\n\n        Utils_1.Utils.arrayCopy(glyphs2, 0, glyphs1, glyphs1.length, firstEnd); // glyphs2.removeRange(0, secondStart - 1);\n\n        glyphs2.splice(0, secondStart - 1 + 1);\n        first.glyphs = glyphs1;\n        second.glyphs = glyphs2;\n        var xAdvances1 = second.xAdvances; // Starts empty.\n\n        Utils_1.Utils.arrayCopy(xAdvances2, 0, xAdvances1, xAdvances1.length, firstEnd + 1); // xAdvances2.removeRange(1, secondStart); // Leave first entry to be overwritten by next line.\n\n        xAdvances2.splice(1, secondStart); // Leave first entry to be overwritten by next line.\n\n        xAdvances2[0] = this.getLineOffset(glyphs2, fontData);\n        first.xAdvances = xAdvances1;\n        second.xAdvances = xAdvances2;\n        var firstGlyphCount = first.glyphs.length; // After wrapping it.\n\n        var secondGlyphCount = second.glyphs.length;\n        var droppedGlyphCount = glyphCount - firstGlyphCount - secondGlyphCount;\n        this.glyphCount -= droppedGlyphCount;\n\n        if (fontData.markupEnabled && droppedGlyphCount > 0) {\n          var reductionThreshold = this.glyphCount - secondGlyphCount;\n\n          for (var i = this.colors.length - 2; i >= 2; i -= 2) {\n            // i >= 1 because first 2 values always determine the base color.\n            var colorChangeIndex = this.colors[i];\n            if (colorChangeIndex <= reductionThreshold) break;\n            this.colors[i] = colorChangeIndex - droppedGlyphCount;\n          }\n        }\n      } else {\n        // Second run is empty, just trim whitespace glyphs from end of first run.\n        glyphs2 = glyphs2.slice(0, firstEnd);\n        xAdvances2 = xAdvances2.slice(0, firstEnd + 1);\n\n        var _droppedGlyphCount = secondStart - firstEnd;\n\n        if (_droppedGlyphCount > 0) {\n          this.glyphCount -= _droppedGlyphCount;\n\n          if (fontData.markupEnabled && this.colors[this.colors.length - 2] > this.glyphCount) {\n            // Many color changes can be hidden in the dropped whitespace, so keep only the very last color entry.\n            var lastColor = this.colors[this.colors.length - 1];\n\n            while (this.colors[this.colors.length - 2] > this.glyphCount) {\n              this.colors.length -= 2;\n            }\n\n            this.colors[this.colors.length - 2] = this.glyphCount; // Update color change index.\n\n            this.colors[this.colors.length - 1] = lastColor; // Update color entry.\n          }\n        }\n      }\n\n      if (firstEnd === 0) {\n        // If the first run is now empty, remove it.\n        this.glyphRunPool.free(first);\n        this.runs.pop();\n      } else this.setLastGlyphXAdvance(fontData, first);\n\n      return second;\n    }\n  }]);\n\n  return GlyphLayout;\n}();\n\nexports.GlyphLayout = GlyphLayout;","map":{"version":3,"names":["Object","defineProperty","exports","value","GlyphLayout","GlyphRun_1","require","Utils_1","font","str","start","end","color","targetWidth","hAlign","wrap","truncate","epsilon","glyphRunPool","Pools","get","GlyphRun","colorStack","Array","runs","colors","setText","reset","fontData","data","height","capHeight","Math","max","spaceXadvance","wrapOrTruncate","currentColor","toIntBits","nextColor","shift","markupEnabled","push","isLastRun","y","down","lineRun","lastGlyph","runStart","runEnd","newline","charAt","runEnded","run","obtain","x","getGlyphs","glyphCount","glyphs","length","free","appendRun","setLastGlyphXAdvance","runWidth","xAdvances","i","glyph","glyphWidth","getGlyphWidth","wrapIndex","getWrapIndex","blankLineScale","abs","calculateWidths","alignRuns","_a","width","runsItems","n","ii","isNaN","halign","Align","left","center","truncateRun","truncateWidth","count","xAdvance","splice","Utils","arrayCopy","droppedGlyphCount","last","fixedWidth","xoffset","scaleX","padRight","getLineOffset","padLeft","freeAll","first","glyphs2","xAdvances2","firstEnd","isWhitespace","id","secondStart","second","glyphs1","xAdvances1","firstGlyphCount","secondGlyphCount","reductionThreshold","colorChangeIndex","slice","lastColor","pop"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/GlyphLayout.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GlyphLayout = void 0;\r\nconst GlyphRun_1 = require(\"./GlyphRun\");\r\nconst Utils_1 = require(\"./Utils\");\r\nclass GlyphLayout {\r\n    constructor(font, str, start, end, color, targetWidth, hAlign, wrap, truncate) {\r\n        this.epsilon = 0.0001;\r\n        this.glyphRunPool = Utils_1.Pools.get('GlyphRun', () => new GlyphRun_1.GlyphRun());\r\n        this.colorStack = new Array(4);\r\n        this.runs = [];\r\n        this.colors = [];\r\n        this.setText = (font, str, start, end, color, targetWidth, hAlign, wrap, truncate) => {\r\n            this.reset();\r\n            const fontData = font.data;\r\n            if (start === end) {\r\n                // Empty string.\r\n                this.height = fontData.capHeight;\r\n                return;\r\n            }\r\n            // Avoid wrapping one line per character, which is very inefficient.\r\n            if (wrap)\r\n                targetWidth = Math.max(targetWidth, fontData.spaceXadvance * 3);\r\n            const wrapOrTruncate = wrap || truncate != null;\r\n            let currentColor = color.toIntBits();\r\n            let nextColor = currentColor;\r\n            this.colors.shift();\r\n            const markupEnabled = fontData.markupEnabled;\r\n            if (markupEnabled)\r\n                this.colorStack.push(currentColor);\r\n            let isLastRun = false;\r\n            let y = 0;\r\n            let down = fontData.down;\r\n            let lineRun = null; // Collects glyphs for the current line.\r\n            let lastGlyph = null; // Last glyph of the previous run on the same line, used for kerning between runs.\r\n            let runStart = start;\r\n            while (true) {\r\n                let runEnd;\r\n                let newline = false;\r\n                if (start === end) {\r\n                    // End of text.\r\n                    if (runStart === end)\r\n                        break; // No run to process, we're done.\r\n                    runEnd = end; // Process the final run.\r\n                    isLastRun = true;\r\n                }\r\n                else {\r\n                    // Each run is delimited by newline or left square bracket.\r\n                    switch (str.charAt(start++)) {\r\n                        case '\\n': // End of line.\r\n                            runEnd = start - 1;\r\n                            newline = true;\r\n                            break;\r\n                        // Fall through.\r\n                        default:\r\n                            continue;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-labels\r\n                runEnded: {\r\n                    // Store the run that has ended.\r\n                    const run = this.glyphRunPool.obtain();\r\n                    run.x = 0;\r\n                    run.y = y;\r\n                    fontData.getGlyphs(run, str, runStart, runEnd, lastGlyph);\r\n                    this.glyphCount += run.glyphs.length;\r\n                    if (nextColor !== currentColor) {\r\n                        // Can only be different if markupEnabled.\r\n                        if (this.colors[this.colors.length - 2] === this.glyphCount) {\r\n                            // Consecutive color changes, or after an empty run, or at the beginning of the string.\r\n                            this.colors[this.colors.length - 1] = nextColor;\r\n                        }\r\n                        else {\r\n                            this.colors.push(this.glyphCount);\r\n                            this.colors.push(nextColor);\r\n                        }\r\n                        currentColor = nextColor;\r\n                    }\r\n                    if (run.glyphs.length === 0) {\r\n                        this.glyphRunPool.free(run);\r\n                        if (!lineRun)\r\n                            break; // Otherwise wrap and truncate must still be processed for lineRun.\r\n                    }\r\n                    else if (!lineRun) {\r\n                        lineRun = run;\r\n                        this.runs.push(lineRun);\r\n                    }\r\n                    else {\r\n                        lineRun.appendRun(run);\r\n                        this.glyphRunPool.free(run);\r\n                    }\r\n                    if (newline || isLastRun) {\r\n                        this.setLastGlyphXAdvance(fontData, lineRun);\r\n                        lastGlyph = null;\r\n                    }\r\n                    else\r\n                        lastGlyph = lineRun.glyphs[lineRun.glyphs.length - 1];\r\n                    if (!wrapOrTruncate || lineRun.glyphs.length === 0) {\r\n                        // eslint-disable-next-line no-labels\r\n                        break runEnded; // No wrap or truncate, or no glyphs.\r\n                    }\r\n                    if (newline || isLastRun) {\r\n                        // Wrap or truncate. First xadvance is the first glyph's X offset relative to the drawing position.\r\n                        let runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.\r\n                        for (let i = 2; i < lineRun.xAdvances.length; i++) {\r\n                            const glyph = lineRun.glyphs[i - 1];\r\n                            let glyphWidth = this.getGlyphWidth(glyph, fontData);\r\n                            if (runWidth + glyphWidth - this.epsilon <= targetWidth) {\r\n                                // Glyph fits.\r\n                                runWidth += lineRun.xAdvances[i];\r\n                                continue;\r\n                            }\r\n                            if (truncate != null) {\r\n                                // Truncate.\r\n                                this.truncate(fontData, lineRun, targetWidth, truncate);\r\n                                break;\r\n                            }\r\n                            // Wrap.\r\n                            let wrapIndex = fontData.getWrapIndex(lineRun.glyphs, i);\r\n                            if ((wrapIndex === 0 && lineRun.x === 0) || // Require at least one glyph per line.\r\n                                wrapIndex >= lineRun.glyphs.length) {\r\n                                // Wrap at least the glyph that didn't fit.\r\n                                wrapIndex = i - 1;\r\n                            }\r\n                            lineRun = this.wrap(fontData, lineRun, wrapIndex);\r\n                            // eslint-disable-next-line no-labels\r\n                            if (!lineRun)\r\n                                break runEnded; // All wrapped glyphs were whitespace.\r\n                            this.runs.push(lineRun);\r\n                            y += down;\r\n                            lineRun.x = 0;\r\n                            lineRun.y = y;\r\n                            // Start the wrap loop again, another wrap might be necessary.\r\n                            runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.\r\n                            i = 1;\r\n                        }\r\n                    }\r\n                }\r\n                if (newline) {\r\n                    lineRun = null;\r\n                    lastGlyph = null;\r\n                    // Next run will be on the next line.\r\n                    if (runEnd === runStart)\r\n                        // Blank line.\r\n                        y += down * fontData.blankLineScale;\r\n                    else\r\n                        y += down;\r\n                }\r\n                runStart = start;\r\n            }\r\n            this.height = fontData.capHeight + Math.abs(y);\r\n            this.calculateWidths(fontData);\r\n            this.alignRuns(targetWidth, hAlign);\r\n            // Clear the color stack.\r\n            if (markupEnabled)\r\n                this.colorStack.length = 0;\r\n        };\r\n        this.calculateWidths = (fontData) => {\r\n            var _a;\r\n            let width = 0;\r\n            const runsItems = [...this.runs];\r\n            for (let i = 0, n = this.runs.length; i < n; i++) {\r\n                const run = runsItems[i];\r\n                const xAdvances = run.xAdvances;\r\n                let runWidth = run.x + xAdvances[0];\r\n                let max = 0; // run.x is needed to ensure floats are rounded same as above.\r\n                const glyphs = run.glyphs;\r\n                for (let ii = 0; ii < run.glyphs.length;) {\r\n                    const glyph = glyphs[ii];\r\n                    const glyphWidth = this.getGlyphWidth(glyph, fontData);\r\n                    max = Math.max(max, runWidth + glyphWidth); // A glyph can extend past the right edge of subsequent glyphs.\r\n                    ii++;\r\n                    runWidth += (_a = xAdvances[ii]) !== null && _a !== void 0 ? _a : 0;\r\n                }\r\n                run.width = Math.max(runWidth, max) - run.x;\r\n                width = Math.max(width, run.x + (isNaN(run.width) ? runWidth : run.width));\r\n            }\r\n            this.width = width;\r\n        };\r\n        this.alignRuns = (targetWidth, halign) => {\r\n            if ((halign & Utils_1.Align.left) === 0) {\r\n                // Not left aligned, so must be center or right aligned.\r\n                const center = (halign & Utils_1.Align.center) !== 0;\r\n                const runsItems = [...this.runs];\r\n                for (let i = 0, n = this.runs.length; i < n; i++) {\r\n                    const run = runsItems[i];\r\n                    run.x += center ? 0.5 * (targetWidth - run.width) : targetWidth - run.width;\r\n                }\r\n            }\r\n        };\r\n        /** @param truncate May be empty string. */\r\n        this.truncate = (fontData, run, targetWidth, truncate) => {\r\n            let glyphCount = run.glyphs.length;\r\n            // Determine truncate string size.\r\n            const truncateRun = this.glyphRunPool.obtain();\r\n            fontData.getGlyphs(truncateRun, truncate, 0, truncate.length, null);\r\n            let truncateWidth = 0;\r\n            if (truncateRun.xAdvances.length > 0) {\r\n                this.setLastGlyphXAdvance(fontData, truncateRun);\r\n                const xAdvances = truncateRun.xAdvances;\r\n                // Skip first for tight bounds.\r\n                for (let i = 1; i < truncateRun.xAdvances.length; i++) {\r\n                    truncateWidth += xAdvances[i];\r\n                }\r\n            }\r\n            targetWidth -= truncateWidth;\r\n            // Determine visible glyphs.\r\n            let count = 0;\r\n            let width = run.x;\r\n            const xAdvances = run.xAdvances;\r\n            while (count < run.xAdvances.length) {\r\n                const xAdvance = xAdvances[count];\r\n                width += xAdvance;\r\n                if (width > targetWidth)\r\n                    break;\r\n                count++;\r\n            }\r\n            if (count > 1) {\r\n                // Some run glyphs fit, append truncate glyphs.\r\n                if (count - 1 >= 0 && run.glyphs.length > count - 1) {\r\n                    for (let i = count - 1; i < run.glyphs.length; i++) {\r\n                        run.glyphs.splice(i, 1);\r\n                    }\r\n                }\r\n                if (count >= 0 && run.xAdvances.length > count) {\r\n                    for (let i = count; i < run.xAdvances.length; i++) {\r\n                        run.xAdvances.splice(i, 1);\r\n                    }\r\n                }\r\n                this.setLastGlyphXAdvance(fontData, run);\r\n                if (truncateRun.xAdvances.length > 0) {\r\n                    Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 1, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length - 1);\r\n                }\r\n            }\r\n            else {\r\n                // No run glyphs fit, use only truncate glyphs.\r\n                run.glyphs.length = 0;\r\n                run.xAdvances.length = 0;\r\n                // run.xAdvances.addAll(truncateRun.xAdvances);\r\n                Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 0, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length);\r\n            }\r\n            const droppedGlyphCount = glyphCount - run.glyphs.length;\r\n            if (droppedGlyphCount > 0) {\r\n                this.glyphCount -= droppedGlyphCount;\r\n                if (fontData.markupEnabled) {\r\n                    while (this.colors.length > 2 && this.colors[this.colors.length - 2] >= this.glyphCount)\r\n                        this.colors.length -= 2;\r\n                }\r\n            }\r\n            Utils_1.Utils.arrayCopy(truncateRun.glyphs, 0, run.glyphs, run.glyphs.length, truncateRun.glyphs.length);\r\n            this.glyphCount += truncate.length;\r\n            this.glyphRunPool.free(truncateRun);\r\n        };\r\n        /** Sets the xadvance of the last glyph to use its width instead of xadvance. */\r\n        this.setLastGlyphXAdvance = (fontData, run) => {\r\n            const last = run.glyphs[run.glyphs.length - 1];\r\n            if (!last.fixedWidth)\r\n                run.xAdvances[run.xAdvances.length - 1] = this.getGlyphWidth(last, fontData);\r\n        };\r\n        /** Returns the distance from the glyph's drawing position to the right edge of the glyph. */\r\n        this.getGlyphWidth = (glyph, fontData) => {\r\n            return (glyph.width + glyph.xoffset) * fontData.scaleX - fontData.padRight;\r\n        };\r\n        /** Returns an X offset for the first glyph so when drawn, none of it is left of the line's drawing position. */\r\n        this.getLineOffset = (glyphs, fontData) => {\r\n            return -glyphs[0].xoffset * fontData.scaleX - fontData.padLeft;\r\n        };\r\n        this.reset = () => {\r\n            this.glyphRunPool.freeAll(this.runs);\r\n            this.runs.length = 0;\r\n            this.colors.length = 0;\r\n            this.glyphCount = 0;\r\n            this.width = 0;\r\n            this.height = 0;\r\n        };\r\n        this.setText(font, str, start, end, color, targetWidth, hAlign, wrap, truncate);\r\n    }\r\n    /** Breaks a run into two runs at the specified wrapIndex.\r\n     * @return May be null if second run is all whitespace. */\r\n    wrap(fontData, first, wrapIndex) {\r\n        const glyphCount = first.glyphs.length;\r\n        let glyphs2 = first.glyphs; // Starts with all the glyphs.\r\n        let xAdvances2 = first.xAdvances; // Starts with all the xadvances.\r\n        // Skip whitespace before the wrap index.\r\n        let firstEnd = wrapIndex;\r\n        for (; firstEnd > 0; firstEnd--)\r\n            if (!fontData.isWhitespace(glyphs2[firstEnd - 1].id))\r\n                break;\r\n        // Skip whitespace after the wrap index.\r\n        let secondStart = wrapIndex;\r\n        for (; secondStart < glyphCount; secondStart++)\r\n            if (!fontData.isWhitespace(glyphs2[secondStart].id))\r\n                break;\r\n        // Copy wrapped glyphs and xadvances to second run.\r\n        // The second run will contain the remaining glyph data, so swap instances rather than copying.\r\n        let second;\r\n        if (secondStart < glyphCount) {\r\n            second = this.glyphRunPool.obtain();\r\n            const glyphs1 = second.glyphs; // Starts empty.\r\n            Utils_1.Utils.arrayCopy(glyphs2, 0, glyphs1, glyphs1.length, firstEnd);\r\n            // glyphs2.removeRange(0, secondStart - 1);\r\n            glyphs2.splice(0, secondStart - 1 + 1);\r\n            first.glyphs = glyphs1;\r\n            second.glyphs = glyphs2;\r\n            const xAdvances1 = second.xAdvances; // Starts empty.\r\n            Utils_1.Utils.arrayCopy(xAdvances2, 0, xAdvances1, xAdvances1.length, firstEnd + 1);\r\n            // xAdvances2.removeRange(1, secondStart); // Leave first entry to be overwritten by next line.\r\n            xAdvances2.splice(1, secondStart); // Leave first entry to be overwritten by next line.\r\n            xAdvances2[0] = this.getLineOffset(glyphs2, fontData);\r\n            first.xAdvances = xAdvances1;\r\n            second.xAdvances = xAdvances2;\r\n            const firstGlyphCount = first.glyphs.length; // After wrapping it.\r\n            const secondGlyphCount = second.glyphs.length;\r\n            const droppedGlyphCount = glyphCount - firstGlyphCount - secondGlyphCount;\r\n            this.glyphCount -= droppedGlyphCount;\r\n            if (fontData.markupEnabled && droppedGlyphCount > 0) {\r\n                const reductionThreshold = this.glyphCount - secondGlyphCount;\r\n                for (let i = this.colors.length - 2; i >= 2; i -= 2) {\r\n                    // i >= 1 because first 2 values always determine the base color.\r\n                    const colorChangeIndex = this.colors[i];\r\n                    if (colorChangeIndex <= reductionThreshold)\r\n                        break;\r\n                    this.colors[i] = colorChangeIndex - droppedGlyphCount;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Second run is empty, just trim whitespace glyphs from end of first run.\r\n            glyphs2 = glyphs2.slice(0, firstEnd);\r\n            xAdvances2 = xAdvances2.slice(0, firstEnd + 1);\r\n            const droppedGlyphCount = secondStart - firstEnd;\r\n            if (droppedGlyphCount > 0) {\r\n                this.glyphCount -= droppedGlyphCount;\r\n                if (fontData.markupEnabled && this.colors[this.colors.length - 2] > this.glyphCount) {\r\n                    // Many color changes can be hidden in the dropped whitespace, so keep only the very last color entry.\r\n                    const lastColor = this.colors[this.colors.length - 1];\r\n                    while (this.colors[this.colors.length - 2] > this.glyphCount)\r\n                        this.colors.length -= 2;\r\n                    this.colors[this.colors.length - 2] = this.glyphCount; // Update color change index.\r\n                    this.colors[this.colors.length - 1] = lastColor; // Update color entry.\r\n                }\r\n            }\r\n        }\r\n        if (firstEnd === 0) {\r\n            // If the first run is now empty, remove it.\r\n            this.glyphRunPool.free(first);\r\n            this.runs.pop();\r\n        }\r\n        else\r\n            this.setLastGlyphXAdvance(fontData, first);\r\n        return second;\r\n    }\r\n}\r\nexports.GlyphLayout = GlyphLayout;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}