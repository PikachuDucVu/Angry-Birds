{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GlyphLayout = void 0;\n\nconst GlyphRun_1 = require(\"./GlyphRun\");\n\nconst Utils_1 = require(\"./Utils\");\n\nclass GlyphLayout {\n  constructor(font, str, start, end, color, targetWidth, hAlign, wrap, truncate) {\n    this.epsilon = 0.0001;\n    this.glyphRunPool = Utils_1.Pools.get('GlyphRun', () => new GlyphRun_1.GlyphRun());\n    this.colorStack = new Array(4);\n    this.runs = [];\n    this.colors = [];\n\n    this.setText = (font, str, start, end, color, targetWidth, hAlign, wrap, truncate) => {\n      this.reset();\n      const fontData = font.data;\n\n      if (start === end) {\n        // Empty string.\n        this.height = fontData.capHeight;\n        return;\n      } // Avoid wrapping one line per character, which is very inefficient.\n\n\n      if (wrap) targetWidth = Math.max(targetWidth, fontData.spaceXadvance * 3);\n      const wrapOrTruncate = wrap || truncate != null;\n      let currentColor = color.toIntBits();\n      let nextColor = currentColor;\n      this.colors.shift();\n      const markupEnabled = fontData.markupEnabled;\n      if (markupEnabled) this.colorStack.push(currentColor);\n      let isLastRun = false;\n      let y = 0;\n      let down = fontData.down;\n      let lineRun = null; // Collects glyphs for the current line.\n\n      let lastGlyph = null; // Last glyph of the previous run on the same line, used for kerning between runs.\n\n      let runStart = start;\n\n      while (true) {\n        let runEnd;\n        let newline = false;\n\n        if (start === end) {\n          // End of text.\n          if (runStart === end) break; // No run to process, we're done.\n\n          runEnd = end; // Process the final run.\n\n          isLastRun = true;\n        } else {\n          // Each run is delimited by newline or left square bracket.\n          switch (str.charAt(start++)) {\n            case '\\n':\n              // End of line.\n              runEnd = start - 1;\n              newline = true;\n              break;\n            // Fall through.\n\n            default:\n              continue;\n          }\n        } // eslint-disable-next-line no-labels\n\n\n        runEnded: {\n          // Store the run that has ended.\n          const run = this.glyphRunPool.obtain();\n          run.x = 0;\n          run.y = y;\n          fontData.getGlyphs(run, str, runStart, runEnd, lastGlyph);\n          this.glyphCount += run.glyphs.length;\n\n          if (nextColor !== currentColor) {\n            // Can only be different if markupEnabled.\n            if (this.colors[this.colors.length - 2] === this.glyphCount) {\n              // Consecutive color changes, or after an empty run, or at the beginning of the string.\n              this.colors[this.colors.length - 1] = nextColor;\n            } else {\n              this.colors.push(this.glyphCount);\n              this.colors.push(nextColor);\n            }\n\n            currentColor = nextColor;\n          }\n\n          if (run.glyphs.length === 0) {\n            this.glyphRunPool.free(run);\n            if (!lineRun) break; // Otherwise wrap and truncate must still be processed for lineRun.\n          } else if (!lineRun) {\n            lineRun = run;\n            this.runs.push(lineRun);\n          } else {\n            lineRun.appendRun(run);\n            this.glyphRunPool.free(run);\n          }\n\n          if (newline || isLastRun) {\n            this.setLastGlyphXAdvance(fontData, lineRun);\n            lastGlyph = null;\n          } else lastGlyph = lineRun.glyphs[lineRun.glyphs.length - 1];\n\n          if (!wrapOrTruncate || lineRun.glyphs.length === 0) {\n            // eslint-disable-next-line no-labels\n            break runEnded; // No wrap or truncate, or no glyphs.\n          }\n\n          if (newline || isLastRun) {\n            // Wrap or truncate. First xadvance is the first glyph's X offset relative to the drawing position.\n            let runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.\n\n            for (let i = 2; i < lineRun.xAdvances.length; i++) {\n              const glyph = lineRun.glyphs[i - 1];\n              let glyphWidth = this.getGlyphWidth(glyph, fontData);\n\n              if (runWidth + glyphWidth - this.epsilon <= targetWidth) {\n                // Glyph fits.\n                runWidth += lineRun.xAdvances[i];\n                continue;\n              }\n\n              if (truncate != null) {\n                // Truncate.\n                this.truncate(fontData, lineRun, targetWidth, truncate);\n                break;\n              } // Wrap.\n\n\n              let wrapIndex = fontData.getWrapIndex(lineRun.glyphs, i);\n\n              if (wrapIndex === 0 && lineRun.x === 0 || // Require at least one glyph per line.\n              wrapIndex >= lineRun.glyphs.length) {\n                // Wrap at least the glyph that didn't fit.\n                wrapIndex = i - 1;\n              }\n\n              lineRun = this.wrap(fontData, lineRun, wrapIndex); // eslint-disable-next-line no-labels\n\n              if (!lineRun) break runEnded; // All wrapped glyphs were whitespace.\n\n              this.runs.push(lineRun);\n              y += down;\n              lineRun.x = 0;\n              lineRun.y = y; // Start the wrap loop again, another wrap might be necessary.\n\n              runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.\n\n              i = 1;\n            }\n          }\n        }\n\n        if (newline) {\n          lineRun = null;\n          lastGlyph = null; // Next run will be on the next line.\n\n          if (runEnd === runStart) // Blank line.\n            y += down * fontData.blankLineScale;else y += down;\n        }\n\n        runStart = start;\n      }\n\n      this.height = fontData.capHeight + Math.abs(y);\n      this.calculateWidths(fontData);\n      this.alignRuns(targetWidth, hAlign); // Clear the color stack.\n\n      if (markupEnabled) this.colorStack.length = 0;\n    };\n\n    this.calculateWidths = fontData => {\n      var _a;\n\n      let width = 0;\n      const runsItems = [...this.runs];\n\n      for (let i = 0, n = this.runs.length; i < n; i++) {\n        const run = runsItems[i];\n        const xAdvances = run.xAdvances;\n        let runWidth = run.x + xAdvances[0];\n        let max = 0; // run.x is needed to ensure floats are rounded same as above.\n\n        const glyphs = run.glyphs;\n\n        for (let ii = 0; ii < run.glyphs.length;) {\n          const glyph = glyphs[ii];\n          const glyphWidth = this.getGlyphWidth(glyph, fontData);\n          max = Math.max(max, runWidth + glyphWidth); // A glyph can extend past the right edge of subsequent glyphs.\n\n          ii++;\n          runWidth += (_a = xAdvances[ii]) !== null && _a !== void 0 ? _a : 0;\n        }\n\n        run.width = Math.max(runWidth, max) - run.x;\n        width = Math.max(width, run.x + (isNaN(run.width) ? runWidth : run.width));\n      }\n\n      this.width = width;\n    };\n\n    this.alignRuns = (targetWidth, halign) => {\n      if ((halign & Utils_1.Align.left) === 0) {\n        // Not left aligned, so must be center or right aligned.\n        const center = (halign & Utils_1.Align.center) !== 0;\n        const runsItems = [...this.runs];\n\n        for (let i = 0, n = this.runs.length; i < n; i++) {\n          const run = runsItems[i];\n          run.x += center ? 0.5 * (targetWidth - run.width) : targetWidth - run.width;\n        }\n      }\n    };\n    /** @param truncate May be empty string. */\n\n\n    this.truncate = (fontData, run, targetWidth, truncate) => {\n      let glyphCount = run.glyphs.length; // Determine truncate string size.\n\n      const truncateRun = this.glyphRunPool.obtain();\n      fontData.getGlyphs(truncateRun, truncate, 0, truncate.length, null);\n      let truncateWidth = 0;\n\n      if (truncateRun.xAdvances.length > 0) {\n        this.setLastGlyphXAdvance(fontData, truncateRun);\n        const xAdvances = truncateRun.xAdvances; // Skip first for tight bounds.\n\n        for (let i = 1; i < truncateRun.xAdvances.length; i++) {\n          truncateWidth += xAdvances[i];\n        }\n      }\n\n      targetWidth -= truncateWidth; // Determine visible glyphs.\n\n      let count = 0;\n      let width = run.x;\n      const xAdvances = run.xAdvances;\n\n      while (count < run.xAdvances.length) {\n        const xAdvance = xAdvances[count];\n        width += xAdvance;\n        if (width > targetWidth) break;\n        count++;\n      }\n\n      if (count > 1) {\n        // Some run glyphs fit, append truncate glyphs.\n        if (count - 1 >= 0 && run.glyphs.length > count - 1) {\n          for (let i = count - 1; i < run.glyphs.length; i++) {\n            run.glyphs.splice(i, 1);\n          }\n        }\n\n        if (count >= 0 && run.xAdvances.length > count) {\n          for (let i = count; i < run.xAdvances.length; i++) {\n            run.xAdvances.splice(i, 1);\n          }\n        }\n\n        this.setLastGlyphXAdvance(fontData, run);\n\n        if (truncateRun.xAdvances.length > 0) {\n          Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 1, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length - 1);\n        }\n      } else {\n        // No run glyphs fit, use only truncate glyphs.\n        run.glyphs.length = 0;\n        run.xAdvances.length = 0; // run.xAdvances.addAll(truncateRun.xAdvances);\n\n        Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 0, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length);\n      }\n\n      const droppedGlyphCount = glyphCount - run.glyphs.length;\n\n      if (droppedGlyphCount > 0) {\n        this.glyphCount -= droppedGlyphCount;\n\n        if (fontData.markupEnabled) {\n          while (this.colors.length > 2 && this.colors[this.colors.length - 2] >= this.glyphCount) this.colors.length -= 2;\n        }\n      }\n\n      Utils_1.Utils.arrayCopy(truncateRun.glyphs, 0, run.glyphs, run.glyphs.length, truncateRun.glyphs.length);\n      this.glyphCount += truncate.length;\n      this.glyphRunPool.free(truncateRun);\n    };\n    /** Sets the xadvance of the last glyph to use its width instead of xadvance. */\n\n\n    this.setLastGlyphXAdvance = (fontData, run) => {\n      const last = run.glyphs[run.glyphs.length - 1];\n      if (!last.fixedWidth) run.xAdvances[run.xAdvances.length - 1] = this.getGlyphWidth(last, fontData);\n    };\n    /** Returns the distance from the glyph's drawing position to the right edge of the glyph. */\n\n\n    this.getGlyphWidth = (glyph, fontData) => {\n      return (glyph.width + glyph.xoffset) * fontData.scaleX - fontData.padRight;\n    };\n    /** Returns an X offset for the first glyph so when drawn, none of it is left of the line's drawing position. */\n\n\n    this.getLineOffset = (glyphs, fontData) => {\n      return -glyphs[0].xoffset * fontData.scaleX - fontData.padLeft;\n    };\n\n    this.reset = () => {\n      this.glyphRunPool.freeAll(this.runs);\n      this.runs.length = 0;\n      this.colors.length = 0;\n      this.glyphCount = 0;\n      this.width = 0;\n      this.height = 0;\n    };\n\n    this.setText(font, str, start, end, color, targetWidth, hAlign, wrap, truncate);\n  }\n  /** Breaks a run into two runs at the specified wrapIndex.\n   * @return May be null if second run is all whitespace. */\n\n\n  wrap(fontData, first, wrapIndex) {\n    const glyphCount = first.glyphs.length;\n    let glyphs2 = first.glyphs; // Starts with all the glyphs.\n\n    let xAdvances2 = first.xAdvances; // Starts with all the xadvances.\n    // Skip whitespace before the wrap index.\n\n    let firstEnd = wrapIndex;\n\n    for (; firstEnd > 0; firstEnd--) if (!fontData.isWhitespace(glyphs2[firstEnd - 1].id)) break; // Skip whitespace after the wrap index.\n\n\n    let secondStart = wrapIndex;\n\n    for (; secondStart < glyphCount; secondStart++) if (!fontData.isWhitespace(glyphs2[secondStart].id)) break; // Copy wrapped glyphs and xadvances to second run.\n    // The second run will contain the remaining glyph data, so swap instances rather than copying.\n\n\n    let second;\n\n    if (secondStart < glyphCount) {\n      second = this.glyphRunPool.obtain();\n      const glyphs1 = second.glyphs; // Starts empty.\n\n      Utils_1.Utils.arrayCopy(glyphs2, 0, glyphs1, glyphs1.length, firstEnd); // glyphs2.removeRange(0, secondStart - 1);\n\n      glyphs2.splice(0, secondStart - 1 + 1);\n      first.glyphs = glyphs1;\n      second.glyphs = glyphs2;\n      const xAdvances1 = second.xAdvances; // Starts empty.\n\n      Utils_1.Utils.arrayCopy(xAdvances2, 0, xAdvances1, xAdvances1.length, firstEnd + 1); // xAdvances2.removeRange(1, secondStart); // Leave first entry to be overwritten by next line.\n\n      xAdvances2.splice(1, secondStart); // Leave first entry to be overwritten by next line.\n\n      xAdvances2[0] = this.getLineOffset(glyphs2, fontData);\n      first.xAdvances = xAdvances1;\n      second.xAdvances = xAdvances2;\n      const firstGlyphCount = first.glyphs.length; // After wrapping it.\n\n      const secondGlyphCount = second.glyphs.length;\n      const droppedGlyphCount = glyphCount - firstGlyphCount - secondGlyphCount;\n      this.glyphCount -= droppedGlyphCount;\n\n      if (fontData.markupEnabled && droppedGlyphCount > 0) {\n        const reductionThreshold = this.glyphCount - secondGlyphCount;\n\n        for (let i = this.colors.length - 2; i >= 2; i -= 2) {\n          // i >= 1 because first 2 values always determine the base color.\n          const colorChangeIndex = this.colors[i];\n          if (colorChangeIndex <= reductionThreshold) break;\n          this.colors[i] = colorChangeIndex - droppedGlyphCount;\n        }\n      }\n    } else {\n      // Second run is empty, just trim whitespace glyphs from end of first run.\n      glyphs2 = glyphs2.slice(0, firstEnd);\n      xAdvances2 = xAdvances2.slice(0, firstEnd + 1);\n      const droppedGlyphCount = secondStart - firstEnd;\n\n      if (droppedGlyphCount > 0) {\n        this.glyphCount -= droppedGlyphCount;\n\n        if (fontData.markupEnabled && this.colors[this.colors.length - 2] > this.glyphCount) {\n          // Many color changes can be hidden in the dropped whitespace, so keep only the very last color entry.\n          const lastColor = this.colors[this.colors.length - 1];\n\n          while (this.colors[this.colors.length - 2] > this.glyphCount) this.colors.length -= 2;\n\n          this.colors[this.colors.length - 2] = this.glyphCount; // Update color change index.\n\n          this.colors[this.colors.length - 1] = lastColor; // Update color entry.\n        }\n      }\n    }\n\n    if (firstEnd === 0) {\n      // If the first run is now empty, remove it.\n      this.glyphRunPool.free(first);\n      this.runs.pop();\n    } else this.setLastGlyphXAdvance(fontData, first);\n\n    return second;\n  }\n\n}\n\nexports.GlyphLayout = GlyphLayout;","map":{"version":3,"names":["Object","defineProperty","exports","value","GlyphLayout","GlyphRun_1","require","Utils_1","constructor","font","str","start","end","color","targetWidth","hAlign","wrap","truncate","epsilon","glyphRunPool","Pools","get","GlyphRun","colorStack","Array","runs","colors","setText","reset","fontData","data","height","capHeight","Math","max","spaceXadvance","wrapOrTruncate","currentColor","toIntBits","nextColor","shift","markupEnabled","push","isLastRun","y","down","lineRun","lastGlyph","runStart","runEnd","newline","charAt","runEnded","run","obtain","x","getGlyphs","glyphCount","glyphs","length","free","appendRun","setLastGlyphXAdvance","runWidth","xAdvances","i","glyph","glyphWidth","getGlyphWidth","wrapIndex","getWrapIndex","blankLineScale","abs","calculateWidths","alignRuns","_a","width","runsItems","n","ii","isNaN","halign","Align","left","center","truncateRun","truncateWidth","count","xAdvance","splice","Utils","arrayCopy","droppedGlyphCount","last","fixedWidth","xoffset","scaleX","padRight","getLineOffset","padLeft","freeAll","first","glyphs2","xAdvances2","firstEnd","isWhitespace","id","secondStart","second","glyphs1","xAdvances1","firstGlyphCount","secondGlyphCount","reductionThreshold","colorChangeIndex","slice","lastColor","pop"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/GlyphLayout.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GlyphLayout = void 0;\nconst GlyphRun_1 = require(\"./GlyphRun\");\nconst Utils_1 = require(\"./Utils\");\nclass GlyphLayout {\n    constructor(font, str, start, end, color, targetWidth, hAlign, wrap, truncate) {\n        this.epsilon = 0.0001;\n        this.glyphRunPool = Utils_1.Pools.get('GlyphRun', () => new GlyphRun_1.GlyphRun());\n        this.colorStack = new Array(4);\n        this.runs = [];\n        this.colors = [];\n        this.setText = (font, str, start, end, color, targetWidth, hAlign, wrap, truncate) => {\n            this.reset();\n            const fontData = font.data;\n            if (start === end) {\n                // Empty string.\n                this.height = fontData.capHeight;\n                return;\n            }\n            // Avoid wrapping one line per character, which is very inefficient.\n            if (wrap)\n                targetWidth = Math.max(targetWidth, fontData.spaceXadvance * 3);\n            const wrapOrTruncate = wrap || truncate != null;\n            let currentColor = color.toIntBits();\n            let nextColor = currentColor;\n            this.colors.shift();\n            const markupEnabled = fontData.markupEnabled;\n            if (markupEnabled)\n                this.colorStack.push(currentColor);\n            let isLastRun = false;\n            let y = 0;\n            let down = fontData.down;\n            let lineRun = null; // Collects glyphs for the current line.\n            let lastGlyph = null; // Last glyph of the previous run on the same line, used for kerning between runs.\n            let runStart = start;\n            while (true) {\n                let runEnd;\n                let newline = false;\n                if (start === end) {\n                    // End of text.\n                    if (runStart === end)\n                        break; // No run to process, we're done.\n                    runEnd = end; // Process the final run.\n                    isLastRun = true;\n                }\n                else {\n                    // Each run is delimited by newline or left square bracket.\n                    switch (str.charAt(start++)) {\n                        case '\\n': // End of line.\n                            runEnd = start - 1;\n                            newline = true;\n                            break;\n                        // Fall through.\n                        default:\n                            continue;\n                    }\n                }\n                // eslint-disable-next-line no-labels\n                runEnded: {\n                    // Store the run that has ended.\n                    const run = this.glyphRunPool.obtain();\n                    run.x = 0;\n                    run.y = y;\n                    fontData.getGlyphs(run, str, runStart, runEnd, lastGlyph);\n                    this.glyphCount += run.glyphs.length;\n                    if (nextColor !== currentColor) {\n                        // Can only be different if markupEnabled.\n                        if (this.colors[this.colors.length - 2] === this.glyphCount) {\n                            // Consecutive color changes, or after an empty run, or at the beginning of the string.\n                            this.colors[this.colors.length - 1] = nextColor;\n                        }\n                        else {\n                            this.colors.push(this.glyphCount);\n                            this.colors.push(nextColor);\n                        }\n                        currentColor = nextColor;\n                    }\n                    if (run.glyphs.length === 0) {\n                        this.glyphRunPool.free(run);\n                        if (!lineRun)\n                            break; // Otherwise wrap and truncate must still be processed for lineRun.\n                    }\n                    else if (!lineRun) {\n                        lineRun = run;\n                        this.runs.push(lineRun);\n                    }\n                    else {\n                        lineRun.appendRun(run);\n                        this.glyphRunPool.free(run);\n                    }\n                    if (newline || isLastRun) {\n                        this.setLastGlyphXAdvance(fontData, lineRun);\n                        lastGlyph = null;\n                    }\n                    else\n                        lastGlyph = lineRun.glyphs[lineRun.glyphs.length - 1];\n                    if (!wrapOrTruncate || lineRun.glyphs.length === 0) {\n                        // eslint-disable-next-line no-labels\n                        break runEnded; // No wrap or truncate, or no glyphs.\n                    }\n                    if (newline || isLastRun) {\n                        // Wrap or truncate. First xadvance is the first glyph's X offset relative to the drawing position.\n                        let runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.\n                        for (let i = 2; i < lineRun.xAdvances.length; i++) {\n                            const glyph = lineRun.glyphs[i - 1];\n                            let glyphWidth = this.getGlyphWidth(glyph, fontData);\n                            if (runWidth + glyphWidth - this.epsilon <= targetWidth) {\n                                // Glyph fits.\n                                runWidth += lineRun.xAdvances[i];\n                                continue;\n                            }\n                            if (truncate != null) {\n                                // Truncate.\n                                this.truncate(fontData, lineRun, targetWidth, truncate);\n                                break;\n                            }\n                            // Wrap.\n                            let wrapIndex = fontData.getWrapIndex(lineRun.glyphs, i);\n                            if ((wrapIndex === 0 && lineRun.x === 0) || // Require at least one glyph per line.\n                                wrapIndex >= lineRun.glyphs.length) {\n                                // Wrap at least the glyph that didn't fit.\n                                wrapIndex = i - 1;\n                            }\n                            lineRun = this.wrap(fontData, lineRun, wrapIndex);\n                            // eslint-disable-next-line no-labels\n                            if (!lineRun)\n                                break runEnded; // All wrapped glyphs were whitespace.\n                            this.runs.push(lineRun);\n                            y += down;\n                            lineRun.x = 0;\n                            lineRun.y = y;\n                            // Start the wrap loop again, another wrap might be necessary.\n                            runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.\n                            i = 1;\n                        }\n                    }\n                }\n                if (newline) {\n                    lineRun = null;\n                    lastGlyph = null;\n                    // Next run will be on the next line.\n                    if (runEnd === runStart)\n                        // Blank line.\n                        y += down * fontData.blankLineScale;\n                    else\n                        y += down;\n                }\n                runStart = start;\n            }\n            this.height = fontData.capHeight + Math.abs(y);\n            this.calculateWidths(fontData);\n            this.alignRuns(targetWidth, hAlign);\n            // Clear the color stack.\n            if (markupEnabled)\n                this.colorStack.length = 0;\n        };\n        this.calculateWidths = (fontData) => {\n            var _a;\n            let width = 0;\n            const runsItems = [...this.runs];\n            for (let i = 0, n = this.runs.length; i < n; i++) {\n                const run = runsItems[i];\n                const xAdvances = run.xAdvances;\n                let runWidth = run.x + xAdvances[0];\n                let max = 0; // run.x is needed to ensure floats are rounded same as above.\n                const glyphs = run.glyphs;\n                for (let ii = 0; ii < run.glyphs.length;) {\n                    const glyph = glyphs[ii];\n                    const glyphWidth = this.getGlyphWidth(glyph, fontData);\n                    max = Math.max(max, runWidth + glyphWidth); // A glyph can extend past the right edge of subsequent glyphs.\n                    ii++;\n                    runWidth += (_a = xAdvances[ii]) !== null && _a !== void 0 ? _a : 0;\n                }\n                run.width = Math.max(runWidth, max) - run.x;\n                width = Math.max(width, run.x + (isNaN(run.width) ? runWidth : run.width));\n            }\n            this.width = width;\n        };\n        this.alignRuns = (targetWidth, halign) => {\n            if ((halign & Utils_1.Align.left) === 0) {\n                // Not left aligned, so must be center or right aligned.\n                const center = (halign & Utils_1.Align.center) !== 0;\n                const runsItems = [...this.runs];\n                for (let i = 0, n = this.runs.length; i < n; i++) {\n                    const run = runsItems[i];\n                    run.x += center ? 0.5 * (targetWidth - run.width) : targetWidth - run.width;\n                }\n            }\n        };\n        /** @param truncate May be empty string. */\n        this.truncate = (fontData, run, targetWidth, truncate) => {\n            let glyphCount = run.glyphs.length;\n            // Determine truncate string size.\n            const truncateRun = this.glyphRunPool.obtain();\n            fontData.getGlyphs(truncateRun, truncate, 0, truncate.length, null);\n            let truncateWidth = 0;\n            if (truncateRun.xAdvances.length > 0) {\n                this.setLastGlyphXAdvance(fontData, truncateRun);\n                const xAdvances = truncateRun.xAdvances;\n                // Skip first for tight bounds.\n                for (let i = 1; i < truncateRun.xAdvances.length; i++) {\n                    truncateWidth += xAdvances[i];\n                }\n            }\n            targetWidth -= truncateWidth;\n            // Determine visible glyphs.\n            let count = 0;\n            let width = run.x;\n            const xAdvances = run.xAdvances;\n            while (count < run.xAdvances.length) {\n                const xAdvance = xAdvances[count];\n                width += xAdvance;\n                if (width > targetWidth)\n                    break;\n                count++;\n            }\n            if (count > 1) {\n                // Some run glyphs fit, append truncate glyphs.\n                if (count - 1 >= 0 && run.glyphs.length > count - 1) {\n                    for (let i = count - 1; i < run.glyphs.length; i++) {\n                        run.glyphs.splice(i, 1);\n                    }\n                }\n                if (count >= 0 && run.xAdvances.length > count) {\n                    for (let i = count; i < run.xAdvances.length; i++) {\n                        run.xAdvances.splice(i, 1);\n                    }\n                }\n                this.setLastGlyphXAdvance(fontData, run);\n                if (truncateRun.xAdvances.length > 0) {\n                    Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 1, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length - 1);\n                }\n            }\n            else {\n                // No run glyphs fit, use only truncate glyphs.\n                run.glyphs.length = 0;\n                run.xAdvances.length = 0;\n                // run.xAdvances.addAll(truncateRun.xAdvances);\n                Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 0, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length);\n            }\n            const droppedGlyphCount = glyphCount - run.glyphs.length;\n            if (droppedGlyphCount > 0) {\n                this.glyphCount -= droppedGlyphCount;\n                if (fontData.markupEnabled) {\n                    while (this.colors.length > 2 && this.colors[this.colors.length - 2] >= this.glyphCount)\n                        this.colors.length -= 2;\n                }\n            }\n            Utils_1.Utils.arrayCopy(truncateRun.glyphs, 0, run.glyphs, run.glyphs.length, truncateRun.glyphs.length);\n            this.glyphCount += truncate.length;\n            this.glyphRunPool.free(truncateRun);\n        };\n        /** Sets the xadvance of the last glyph to use its width instead of xadvance. */\n        this.setLastGlyphXAdvance = (fontData, run) => {\n            const last = run.glyphs[run.glyphs.length - 1];\n            if (!last.fixedWidth)\n                run.xAdvances[run.xAdvances.length - 1] = this.getGlyphWidth(last, fontData);\n        };\n        /** Returns the distance from the glyph's drawing position to the right edge of the glyph. */\n        this.getGlyphWidth = (glyph, fontData) => {\n            return (glyph.width + glyph.xoffset) * fontData.scaleX - fontData.padRight;\n        };\n        /** Returns an X offset for the first glyph so when drawn, none of it is left of the line's drawing position. */\n        this.getLineOffset = (glyphs, fontData) => {\n            return -glyphs[0].xoffset * fontData.scaleX - fontData.padLeft;\n        };\n        this.reset = () => {\n            this.glyphRunPool.freeAll(this.runs);\n            this.runs.length = 0;\n            this.colors.length = 0;\n            this.glyphCount = 0;\n            this.width = 0;\n            this.height = 0;\n        };\n        this.setText(font, str, start, end, color, targetWidth, hAlign, wrap, truncate);\n    }\n    /** Breaks a run into two runs at the specified wrapIndex.\n     * @return May be null if second run is all whitespace. */\n    wrap(fontData, first, wrapIndex) {\n        const glyphCount = first.glyphs.length;\n        let glyphs2 = first.glyphs; // Starts with all the glyphs.\n        let xAdvances2 = first.xAdvances; // Starts with all the xadvances.\n        // Skip whitespace before the wrap index.\n        let firstEnd = wrapIndex;\n        for (; firstEnd > 0; firstEnd--)\n            if (!fontData.isWhitespace(glyphs2[firstEnd - 1].id))\n                break;\n        // Skip whitespace after the wrap index.\n        let secondStart = wrapIndex;\n        for (; secondStart < glyphCount; secondStart++)\n            if (!fontData.isWhitespace(glyphs2[secondStart].id))\n                break;\n        // Copy wrapped glyphs and xadvances to second run.\n        // The second run will contain the remaining glyph data, so swap instances rather than copying.\n        let second;\n        if (secondStart < glyphCount) {\n            second = this.glyphRunPool.obtain();\n            const glyphs1 = second.glyphs; // Starts empty.\n            Utils_1.Utils.arrayCopy(glyphs2, 0, glyphs1, glyphs1.length, firstEnd);\n            // glyphs2.removeRange(0, secondStart - 1);\n            glyphs2.splice(0, secondStart - 1 + 1);\n            first.glyphs = glyphs1;\n            second.glyphs = glyphs2;\n            const xAdvances1 = second.xAdvances; // Starts empty.\n            Utils_1.Utils.arrayCopy(xAdvances2, 0, xAdvances1, xAdvances1.length, firstEnd + 1);\n            // xAdvances2.removeRange(1, secondStart); // Leave first entry to be overwritten by next line.\n            xAdvances2.splice(1, secondStart); // Leave first entry to be overwritten by next line.\n            xAdvances2[0] = this.getLineOffset(glyphs2, fontData);\n            first.xAdvances = xAdvances1;\n            second.xAdvances = xAdvances2;\n            const firstGlyphCount = first.glyphs.length; // After wrapping it.\n            const secondGlyphCount = second.glyphs.length;\n            const droppedGlyphCount = glyphCount - firstGlyphCount - secondGlyphCount;\n            this.glyphCount -= droppedGlyphCount;\n            if (fontData.markupEnabled && droppedGlyphCount > 0) {\n                const reductionThreshold = this.glyphCount - secondGlyphCount;\n                for (let i = this.colors.length - 2; i >= 2; i -= 2) {\n                    // i >= 1 because first 2 values always determine the base color.\n                    const colorChangeIndex = this.colors[i];\n                    if (colorChangeIndex <= reductionThreshold)\n                        break;\n                    this.colors[i] = colorChangeIndex - droppedGlyphCount;\n                }\n            }\n        }\n        else {\n            // Second run is empty, just trim whitespace glyphs from end of first run.\n            glyphs2 = glyphs2.slice(0, firstEnd);\n            xAdvances2 = xAdvances2.slice(0, firstEnd + 1);\n            const droppedGlyphCount = secondStart - firstEnd;\n            if (droppedGlyphCount > 0) {\n                this.glyphCount -= droppedGlyphCount;\n                if (fontData.markupEnabled && this.colors[this.colors.length - 2] > this.glyphCount) {\n                    // Many color changes can be hidden in the dropped whitespace, so keep only the very last color entry.\n                    const lastColor = this.colors[this.colors.length - 1];\n                    while (this.colors[this.colors.length - 2] > this.glyphCount)\n                        this.colors.length -= 2;\n                    this.colors[this.colors.length - 2] = this.glyphCount; // Update color change index.\n                    this.colors[this.colors.length - 1] = lastColor; // Update color entry.\n                }\n            }\n        }\n        if (firstEnd === 0) {\n            // If the first run is now empty, remove it.\n            this.glyphRunPool.free(first);\n            this.runs.pop();\n        }\n        else\n            this.setLastGlyphXAdvance(fontData, first);\n        return second;\n    }\n}\nexports.GlyphLayout = GlyphLayout;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}