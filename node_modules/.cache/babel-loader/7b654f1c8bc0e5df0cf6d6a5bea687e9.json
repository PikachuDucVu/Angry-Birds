{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Color2Attribute = exports.ColorAttribute = exports.TexCoordAttribute = exports.Position3Attribute = exports.Position2Attribute = exports.VertexAttribute = exports.VertexAttributeType = exports.Mesh = void 0;\n\nconst Shader_1 = require(\"./Shader\");\n\nconst WebGL_1 = require(\"./WebGL\");\n\nclass Mesh {\n  constructor(context, attributes, maxVertices, maxIndices) {\n    this.attributes = attributes;\n    this.verticesLength = 0;\n    this.dirtyVertices = false;\n    this.indicesLength = 0;\n    this.dirtyIndices = false;\n    this.elementsPerVertex = 0;\n    this.context = context instanceof WebGL_1.ManagedWebGLRenderingContext ? context : new WebGL_1.ManagedWebGLRenderingContext(context);\n    this.elementsPerVertex = 0;\n\n    for (let i = 0; i < attributes.length; i++) {\n      this.elementsPerVertex += attributes[i].numElements;\n    }\n\n    this.vertices = new Float32Array(maxVertices * this.elementsPerVertex);\n    this.indices = new Uint16Array(maxIndices);\n    this.context.addRestorable(this);\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  maxVertices() {\n    return this.vertices.length / this.elementsPerVertex;\n  }\n\n  numVertices() {\n    return this.verticesLength / this.elementsPerVertex;\n  }\n\n  setVerticesLength(length) {\n    this.dirtyVertices = true;\n    this.verticesLength = length;\n  }\n\n  getVertices() {\n    return this.vertices;\n  }\n\n  maxIndices() {\n    return this.indices.length;\n  }\n\n  numIndices() {\n    return this.indicesLength;\n  }\n\n  setIndicesLength(length) {\n    this.dirtyIndices = true;\n    this.indicesLength = length;\n  }\n\n  getIndices() {\n    return this.indices;\n  }\n\n  getVertexSizeInFloats() {\n    let size = 0;\n\n    for (var i = 0; i < this.attributes.length; i++) {\n      let attribute = this.attributes[i];\n      size += attribute.numElements;\n    }\n\n    return size;\n  }\n\n  setVertices(vertices) {\n    this.dirtyVertices = true;\n    if (vertices.length > this.vertices.length) throw Error(\"Mesh can't store more than \" + this.maxVertices() + ' vertices');\n    this.vertices.set(vertices, 0);\n    this.verticesLength = vertices.length;\n  }\n\n  setIndices(indices) {\n    this.dirtyIndices = true;\n    if (indices.length > this.indices.length) throw Error(\"Mesh can't store more than \" + this.maxIndices() + ' indices');\n    this.indices.set(indices, 0);\n    this.indicesLength = indices.length;\n  }\n\n  draw(shader, primitiveType) {\n    this.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);\n  }\n\n  drawWithOffset(shader, primitiveType, offset, count) {\n    let gl = this.context.gl;\n    if (this.dirtyVertices || this.dirtyIndices) this.update();\n    this.bind(shader);\n\n    if (this.indicesLength > 0) {\n      gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);\n    } else {\n      gl.drawArrays(primitiveType, offset, count);\n    }\n\n    this.unbind(shader);\n  }\n\n  bind(shader) {\n    let gl = this.context.gl;\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n    let offset = 0;\n\n    for (let i = 0; i < this.attributes.length; i++) {\n      let attrib = this.attributes[i];\n      let location = shader.getAttributeLocation(attrib.name);\n      gl.enableVertexAttribArray(location);\n      gl.vertexAttribPointer(location, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);\n      offset += attrib.numElements;\n    }\n\n    if (this.indicesLength > 0) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n  }\n\n  unbind(shader) {\n    let gl = this.context.gl;\n\n    for (let i = 0; i < this.attributes.length; i++) {\n      let attrib = this.attributes[i];\n      let location = shader.getAttributeLocation(attrib.name);\n      gl.disableVertexAttribArray(location);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    if (this.indicesLength > 0) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  update() {\n    let gl = this.context.gl;\n\n    if (this.dirtyVertices) {\n      if (!this.verticesBuffer) {\n        this.verticesBuffer = gl.createBuffer();\n      }\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);\n      this.dirtyVertices = false;\n    }\n\n    if (this.dirtyIndices) {\n      if (!this.indicesBuffer) {\n        this.indicesBuffer = gl.createBuffer();\n      }\n\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);\n      this.dirtyIndices = false;\n    }\n  }\n\n  restore() {\n    this.verticesBuffer = null;\n    this.indicesBuffer = null;\n    this.update();\n  }\n\n  dispose() {\n    this.context.removeRestorable(this);\n    let gl = this.context.gl;\n    gl.deleteBuffer(this.verticesBuffer);\n    gl.deleteBuffer(this.indicesBuffer);\n  }\n\n}\n\nexports.Mesh = Mesh;\nvar VertexAttributeType;\n\n(function (VertexAttributeType) {\n  VertexAttributeType[VertexAttributeType[\"Float\"] = 0] = \"Float\";\n})(VertexAttributeType = exports.VertexAttributeType || (exports.VertexAttributeType = {}));\n\nclass VertexAttribute {\n  constructor(name, type, numElements) {\n    this.name = name;\n    this.type = type;\n    this.numElements = numElements;\n  }\n\n}\n\nexports.VertexAttribute = VertexAttribute;\n\nclass Position2Attribute extends VertexAttribute {\n  constructor() {\n    super(Shader_1.Shader.POSITION, VertexAttributeType.Float, 2);\n  }\n\n}\n\nexports.Position2Attribute = Position2Attribute;\n\nclass Position3Attribute extends VertexAttribute {\n  constructor() {\n    super(Shader_1.Shader.POSITION, VertexAttributeType.Float, 3);\n  }\n\n}\n\nexports.Position3Attribute = Position3Attribute;\n\nclass TexCoordAttribute extends VertexAttribute {\n  constructor() {\n    let unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    super(Shader_1.Shader.TEXCOORDS + (unit === 0 ? '' : unit), VertexAttributeType.Float, 2);\n  }\n\n}\n\nexports.TexCoordAttribute = TexCoordAttribute;\n\nclass ColorAttribute extends VertexAttribute {\n  constructor() {\n    super(Shader_1.Shader.COLOR, VertexAttributeType.Float, 4);\n  }\n\n}\n\nexports.ColorAttribute = ColorAttribute;\n\nclass Color2Attribute extends VertexAttribute {\n  constructor() {\n    super(Shader_1.Shader.COLOR2, VertexAttributeType.Float, 4);\n  }\n\n}\n\nexports.Color2Attribute = Color2Attribute;","map":{"version":3,"names":["Object","defineProperty","exports","value","Color2Attribute","ColorAttribute","TexCoordAttribute","Position3Attribute","Position2Attribute","VertexAttribute","VertexAttributeType","Mesh","Shader_1","require","WebGL_1","constructor","context","attributes","maxVertices","maxIndices","verticesLength","dirtyVertices","indicesLength","dirtyIndices","elementsPerVertex","ManagedWebGLRenderingContext","i","length","numElements","vertices","Float32Array","indices","Uint16Array","addRestorable","getAttributes","numVertices","setVerticesLength","getVertices","numIndices","setIndicesLength","getIndices","getVertexSizeInFloats","size","attribute","setVertices","Error","set","setIndices","draw","shader","primitiveType","drawWithOffset","offset","count","gl","update","bind","drawElements","UNSIGNED_SHORT","drawArrays","unbind","bindBuffer","ARRAY_BUFFER","verticesBuffer","attrib","location","getAttributeLocation","name","enableVertexAttribArray","vertexAttribPointer","FLOAT","ELEMENT_ARRAY_BUFFER","indicesBuffer","disableVertexAttribArray","createBuffer","bufferData","subarray","DYNAMIC_DRAW","restore","dispose","removeRestorable","deleteBuffer","type","Shader","POSITION","Float","unit","TEXCOORDS","COLOR","COLOR2"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/Mesh.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Color2Attribute = exports.ColorAttribute = exports.TexCoordAttribute = exports.Position3Attribute = exports.Position2Attribute = exports.VertexAttribute = exports.VertexAttributeType = exports.Mesh = void 0;\nconst Shader_1 = require(\"./Shader\");\nconst WebGL_1 = require(\"./WebGL\");\nclass Mesh {\n    constructor(context, attributes, maxVertices, maxIndices) {\n        this.attributes = attributes;\n        this.verticesLength = 0;\n        this.dirtyVertices = false;\n        this.indicesLength = 0;\n        this.dirtyIndices = false;\n        this.elementsPerVertex = 0;\n        this.context =\n            context instanceof WebGL_1.ManagedWebGLRenderingContext ? context : new WebGL_1.ManagedWebGLRenderingContext(context);\n        this.elementsPerVertex = 0;\n        for (let i = 0; i < attributes.length; i++) {\n            this.elementsPerVertex += attributes[i].numElements;\n        }\n        this.vertices = new Float32Array(maxVertices * this.elementsPerVertex);\n        this.indices = new Uint16Array(maxIndices);\n        this.context.addRestorable(this);\n    }\n    getAttributes() {\n        return this.attributes;\n    }\n    maxVertices() {\n        return this.vertices.length / this.elementsPerVertex;\n    }\n    numVertices() {\n        return this.verticesLength / this.elementsPerVertex;\n    }\n    setVerticesLength(length) {\n        this.dirtyVertices = true;\n        this.verticesLength = length;\n    }\n    getVertices() {\n        return this.vertices;\n    }\n    maxIndices() {\n        return this.indices.length;\n    }\n    numIndices() {\n        return this.indicesLength;\n    }\n    setIndicesLength(length) {\n        this.dirtyIndices = true;\n        this.indicesLength = length;\n    }\n    getIndices() {\n        return this.indices;\n    }\n    getVertexSizeInFloats() {\n        let size = 0;\n        for (var i = 0; i < this.attributes.length; i++) {\n            let attribute = this.attributes[i];\n            size += attribute.numElements;\n        }\n        return size;\n    }\n    setVertices(vertices) {\n        this.dirtyVertices = true;\n        if (vertices.length > this.vertices.length)\n            throw Error(\"Mesh can't store more than \" + this.maxVertices() + ' vertices');\n        this.vertices.set(vertices, 0);\n        this.verticesLength = vertices.length;\n    }\n    setIndices(indices) {\n        this.dirtyIndices = true;\n        if (indices.length > this.indices.length)\n            throw Error(\"Mesh can't store more than \" + this.maxIndices() + ' indices');\n        this.indices.set(indices, 0);\n        this.indicesLength = indices.length;\n    }\n    draw(shader, primitiveType) {\n        this.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);\n    }\n    drawWithOffset(shader, primitiveType, offset, count) {\n        let gl = this.context.gl;\n        if (this.dirtyVertices || this.dirtyIndices)\n            this.update();\n        this.bind(shader);\n        if (this.indicesLength > 0) {\n            gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);\n        }\n        else {\n            gl.drawArrays(primitiveType, offset, count);\n        }\n        this.unbind(shader);\n    }\n    bind(shader) {\n        let gl = this.context.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n        let offset = 0;\n        for (let i = 0; i < this.attributes.length; i++) {\n            let attrib = this.attributes[i];\n            let location = shader.getAttributeLocation(attrib.name);\n            gl.enableVertexAttribArray(location);\n            gl.vertexAttribPointer(location, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);\n            offset += attrib.numElements;\n        }\n        if (this.indicesLength > 0)\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n    }\n    unbind(shader) {\n        let gl = this.context.gl;\n        for (let i = 0; i < this.attributes.length; i++) {\n            let attrib = this.attributes[i];\n            let location = shader.getAttributeLocation(attrib.name);\n            gl.disableVertexAttribArray(location);\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        if (this.indicesLength > 0)\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    update() {\n        let gl = this.context.gl;\n        if (this.dirtyVertices) {\n            if (!this.verticesBuffer) {\n                this.verticesBuffer = gl.createBuffer();\n            }\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);\n            this.dirtyVertices = false;\n        }\n        if (this.dirtyIndices) {\n            if (!this.indicesBuffer) {\n                this.indicesBuffer = gl.createBuffer();\n            }\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);\n            this.dirtyIndices = false;\n        }\n    }\n    restore() {\n        this.verticesBuffer = null;\n        this.indicesBuffer = null;\n        this.update();\n    }\n    dispose() {\n        this.context.removeRestorable(this);\n        let gl = this.context.gl;\n        gl.deleteBuffer(this.verticesBuffer);\n        gl.deleteBuffer(this.indicesBuffer);\n    }\n}\nexports.Mesh = Mesh;\nvar VertexAttributeType;\n(function (VertexAttributeType) {\n    VertexAttributeType[VertexAttributeType[\"Float\"] = 0] = \"Float\";\n})(VertexAttributeType = exports.VertexAttributeType || (exports.VertexAttributeType = {}));\nclass VertexAttribute {\n    constructor(name, type, numElements) {\n        this.name = name;\n        this.type = type;\n        this.numElements = numElements;\n    }\n}\nexports.VertexAttribute = VertexAttribute;\nclass Position2Attribute extends VertexAttribute {\n    constructor() {\n        super(Shader_1.Shader.POSITION, VertexAttributeType.Float, 2);\n    }\n}\nexports.Position2Attribute = Position2Attribute;\nclass Position3Attribute extends VertexAttribute {\n    constructor() {\n        super(Shader_1.Shader.POSITION, VertexAttributeType.Float, 3);\n    }\n}\nexports.Position3Attribute = Position3Attribute;\nclass TexCoordAttribute extends VertexAttribute {\n    constructor(unit = 0) {\n        super(Shader_1.Shader.TEXCOORDS + (unit === 0 ? '' : unit), VertexAttributeType.Float, 2);\n    }\n}\nexports.TexCoordAttribute = TexCoordAttribute;\nclass ColorAttribute extends VertexAttribute {\n    constructor() {\n        super(Shader_1.Shader.COLOR, VertexAttributeType.Float, 4);\n    }\n}\nexports.ColorAttribute = ColorAttribute;\nclass Color2Attribute extends VertexAttribute {\n    constructor() {\n        super(Shader_1.Shader.COLOR2, VertexAttributeType.Float, 4);\n    }\n}\nexports.Color2Attribute = Color2Attribute;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}