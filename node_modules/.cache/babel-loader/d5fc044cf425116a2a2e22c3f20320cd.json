{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitmapFontData = void 0;\n\nconst Glyph_1 = require(\"./Glyph\");\n\nconst Texture_1 = require(\"./Texture\");\n\nconst TextureRegion_1 = require(\"./TextureRegion\");\n\nfunction concatAndResolveUrl(url, concat) {\n  let url1 = url.split('/');\n  let url2 = concat.split('/');\n  let url3 = [];\n\n  for (let i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (let i = 0, l = url2.length; i < l; i++) {\n    if (url2[i] === '..') {\n      url3.pop();\n    } else if (url2[i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nconst CHARACTER_MAX_VALUE = 65535;\n\nclass BitmapFontData {\n  /** Creates an empty BitmapFontData for configuration before calling {@link #load(FileHandle, boolean)}, to subclass, or to\r\n   * populate yourself, e.g. using stb-truetype or FreeType. */\n  constructor(fontFile, flip) {\n    /** The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of\r\n     * the first line, the cap height can be used to get the location of the baseline. */\n    this.capHeight = 1;\n    /** Multiplier for the line height of blank lines. down * blankLineHeight is used as the distance to move down for a blank\r\n     * line. */\n\n    this.blankLineScale = 1;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.glyphs = {};\n    /** The x-height, which is the distance from the top of most lowercase characters to the baseline. */\n\n    this.xHeight = 1;\n    this.xChars = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z'];\n    this.capChars = ['M', 'N', 'B', 'D', 'C', 'E', 'F', 'K', 'A', 'G', 'H', 'I', 'J', 'L', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\n    this.loadFont = gl => __awaiter(this, void 0, void 0, function* () {\n      console.log(\"vclll\");\n      if (this.imagePaths != null) return;\n      let i = 0;\n      let fileContent;\n      const res = yield fetch(this.fontFile);\n      fileContent = yield res.text();\n      const lines = fileContent.split(/\\r?\\n/).map(s => s.trim());\n\n      try {\n        let line = lines[i];\n        if (typeof line !== 'string') throw new Error('File is empty.');\n        line = line.substring(line.indexOf('padding=') + 8);\n        const padding = line.substring(0, line.indexOf(' ')).split(',', 4);\n        if (padding.length !== 4) throw new Error('Invalid padding.');\n        this.padTop = parseInt(padding[0]);\n        this.padRight = parseInt(padding[1]);\n        this.padBottom = parseInt(padding[2]);\n        this.padLeft = parseInt(padding[3]);\n        const padY = this.padTop + this.padBottom;\n        i++;\n        line = lines[i];\n        if (typeof line !== 'string') throw new Error('Missing common header.');\n        const common = line.split(' ', 9); // At most we want the 6th element; i.e. \"page=N\"\n        // At least lineHeight and base are required.\n\n        if (common.length < 3) throw new Error('Invalid common header.');\n        if (!common[1].startsWith('lineHeight=')) throw new Error('Missing: lineHeight');\n        this.lineHeight = parseInt(common[1].substring(11));\n        if (!common[2].startsWith('base=')) throw new Error('Missing: base');\n        const baseLine = parseInt(common[2].substring(5));\n        let pageCount = 1;\n\n        if (common.length >= 6 && common[5] != null && common[5].startsWith('pages=')) {\n          try {\n            pageCount = Math.max(1, parseInt(common[5].substring(6)));\n          } catch (_a) {// Use one page.\n          }\n        }\n\n        this.imagePaths = new Array(pageCount);\n        const imagePaths = []; // Read each page definition.\n\n        for (let p = 0; p < pageCount; p++) {\n          // Read each \"page\" info line.\n          i++;\n          line = lines[i];\n          if (typeof line !== 'string') throw new Error('Missing additional page definitions.'); // Expect ID to mean \"index\".\n\n          const idMatches = line.match(new RegExp('.*id=(\\\\d+)'));\n\n          if (idMatches && idMatches.length > 1) {\n            const id = idMatches[1];\n\n            try {\n              const pageID = parseInt(id);\n              if (pageID !== p) throw new Error('Page IDs must be indices starting at 0: ' + id);\n            } catch (_b) {}\n          }\n\n          const fileMatches = line.match(new RegExp('.*file=\"?([^\"]+)\"?'));\n          if (!fileMatches || fileMatches.length <= 1) throw new Error('Missing: file');\n          const fileName = fileMatches[1];\n          imagePaths[p] = fileName; // this.imagePaths[p] = fontFile.parent().child(fileName).path().replaceAll(\"\\\\\\\\\", \"/\");\n        }\n\n        this.descent = 0;\n\n        while (true) {\n          i++;\n          line = lines[i];\n          if (!line) break; // EOF\n\n          if (line.startsWith('kernings ')) break; // Starting kernings block.\n\n          if (line.startsWith('metrics ')) break; // Starting metrics block.\n\n          if (!line.startsWith('char ')) continue;\n          const glyph = new Glyph_1.Glyph();\n          const tokens = new StringTokenizer(line, '=');\n          tokens.nextToken();\n          tokens.nextToken();\n          const ch = parseInt(tokens.nextToken());\n          if (ch > 0 && ch > CHARACTER_MAX_VALUE) continue;\n          glyph.id = ch + '';\n          tokens.nextToken();\n          glyph.srcX = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          glyph.srcY = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          glyph.width = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          glyph.height = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          glyph.xoffset = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          if (this.flipped) glyph.yoffset = parseInt(tokens.nextToken());else glyph.yoffset = -(glyph.height + parseInt(tokens.nextToken()));\n          tokens.nextToken();\n          glyph.xadvance = parseInt(tokens.nextToken()); // Check for page safely, it could be omitted or invalid.\n\n          if (tokens.hasMoreTokens()) tokens.nextToken();\n\n          if (tokens.hasMoreTokens()) {\n            try {\n              glyph.page = parseInt(tokens.nextToken());\n            } catch (_c) {}\n          }\n\n          if (glyph.width > 0 && glyph.height > 0) this.descent = Math.min(baseLine + glyph.yoffset, this.descent);\n\n          if (ch <= 0) {\n            this.missingGlyph = glyph;\n          } else if (ch <= CHARACTER_MAX_VALUE) {\n            this.setGlyph(ch, glyph);\n          }\n        }\n\n        this.descent += this.padBottom;\n\n        while (true) {\n          i++;\n          line = lines[i];\n          if (typeof line !== 'string') break;\n          if (!line.startsWith('kerning ')) break;\n          const tokens = new StringTokenizer(line, '=');\n          tokens.nextToken();\n          tokens.nextToken();\n          let first = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          let second = parseInt(tokens.nextToken());\n          if (first < 0 || first > CHARACTER_MAX_VALUE || second < 0 || second > CHARACTER_MAX_VALUE) continue;\n          const glyph = this.getGlyph(first + '');\n          tokens.nextToken();\n          const amount = parseInt(tokens.nextToken());\n\n          if (glyph) {\n            // Kernings may exist for glyph pairs not contained in the font.\n            glyph.setKerning(second, amount);\n          }\n        }\n\n        let hasMetricsOverride = false;\n        let overrideAscent = 0;\n        let overrideDescent = 0;\n        let overrideDown = 0;\n        let overrideCapHeight = 0;\n        let overrideLineHeight = 0;\n        let overrideSpaceXAdvance = 0;\n        let overrideXHeight = 0; // Metrics override\n\n        if (line != null && line.startsWith('metrics ')) {\n          hasMetricsOverride = true;\n          const tokens = new StringTokenizer(line, '=');\n          tokens.nextToken();\n          tokens.nextToken();\n          overrideAscent = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideDescent = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideDown = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideCapHeight = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideLineHeight = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideSpaceXAdvance = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideXHeight = parseFloat(tokens.nextToken());\n        }\n\n        let spaceGlyph = this.getGlyph('32');\n\n        if (!spaceGlyph) {\n          spaceGlyph = new Glyph_1.Glyph();\n          spaceGlyph.id = '32';\n          let xadvanceGlyph = this.getGlyph('l');\n          if (!xadvanceGlyph) xadvanceGlyph = this.getFirstGlyph();\n          spaceGlyph.xadvance = xadvanceGlyph.xadvance;\n          this.setGlyph(32, spaceGlyph); // space character ascii code\n        }\n\n        if (spaceGlyph.width === 0) {\n          spaceGlyph.width = this.padLeft + spaceGlyph.xadvance + this.padRight;\n          spaceGlyph.xoffset = -this.padLeft;\n        }\n\n        this.spaceXadvance = spaceGlyph.xadvance;\n        let xGlyph;\n\n        for (let i = 0; i < this.xChars.length; i++) {\n          xGlyph = this.getGlyph(this.xChars[i]);\n          if (xGlyph) break;\n        }\n\n        if (!xGlyph) xGlyph = this.getFirstGlyph();\n        this.xHeight = xGlyph.height - padY;\n        let capGlyph;\n\n        for (let i = 0; i < this.capChars.length; i++) {\n          capGlyph = this.getGlyph(this.capChars[i]);\n          if (capGlyph) break;\n        }\n\n        if (!capGlyph) {\n          const glyphValues = Object.values(this.glyphs);\n\n          for (let i = 0; i < glyphValues.length; i++) {\n            const page = glyphValues[i];\n            if (!page) continue;\n\n            for (let j = 0; j < page.length; j++) {\n              if (!page[j] || page[j].height === 0 || page[j].width === 0) continue;\n              this.capHeight = Math.max(this.capHeight, page[j].height);\n            }\n          }\n        } else this.capHeight = capGlyph.height;\n\n        this.capHeight -= padY;\n        this.ascent = baseLine - this.capHeight;\n        this.down = -this.lineHeight;\n\n        if (this.flipped) {\n          this.ascent = -this.ascent;\n          this.down = -this.down;\n        }\n\n        if (hasMetricsOverride) {\n          this.ascent = overrideAscent;\n          this.descent = overrideDescent;\n          this.down = overrideDown;\n          this.capHeight = overrideCapHeight;\n          this.lineHeight = overrideLineHeight;\n          this.spaceXadvance = overrideSpaceXAdvance;\n          this.xHeight = overrideXHeight;\n        } // Generate texture regions\n\n\n        const regionsData = [];\n        const glyphValues = Object.values(this.glyphs);\n\n        for (let i = 0; i < glyphValues.length; i++) {\n          const values = Object.values(glyphValues[i]);\n\n          for (let j = 0; j < values.length; j++) {\n            const region = {\n              id: values[j].id,\n              left: values[j].srcX,\n              top: values[j].srcY,\n              width: values[j].width,\n              height: values[j].height,\n              xoffset: values[j].xoffset,\n              yoffset: values[j].yoffset,\n              xadvance: values[j].xadvance,\n              page: imagePaths[values[j].page],\n              pageId: values[j].page\n            };\n            regionsData.push(region);\n          }\n        }\n\n        const pages = [];\n\n        for (let i = 0; i < pageCount; i++) {\n          const texture = yield Texture_1.Texture.load(gl, concatAndResolveUrl(this.fontFile, `../${imagePaths[i]}`));\n          const invTexWidth = 1 / texture.width;\n          const invTexHeight = 1 / texture.height;\n          pages.push({\n            texture,\n            invTexWidth,\n            invTexHeight\n          });\n        }\n\n        this.regions = [];\n\n        for (let regionData of regionsData) {\n          const left = regionData.left;\n          const top = regionData.top;\n          const width = regionData.width;\n          const height = regionData.height;\n          const {\n            texture,\n            invTexWidth,\n            invTexHeight\n          } = pages[regionData.pageId];\n          const region = new TextureRegion_1.TextureRegion(texture, left, top, width, height, regionData, invTexWidth, invTexHeight);\n          region.originalWidth = width;\n          region.originalHeight = height;\n          region.offsetX = 0;\n          region.offsetY = 0;\n          this.regions.push(region);\n        }\n      } catch (ex) {\n        console.error(ex);\n      }\n    });\n\n    this.setGlyphRegion = (glyph, region) => {\n      const texture = region.texture;\n      const invTexWidth = 1 / texture.width;\n      const invTexHeight = 1 / texture.height;\n      let offsetX = 0,\n          offsetY = 0;\n      const u = region.u;\n      const v = region.v;\n      const regionWidth = region.originalWidth;\n      const regionHeight = region.originalHeight; // if (region instanceof AtlasRegion) {\n      //    // Compensate for whitespace stripped from left and top edges.\n      //    AtlasRegion atlasRegion = (AtlasRegion)region;\n      //    offsetX = atlasRegion.offsetX;\n      //    offsetY = atlasRegion.originalHeight - atlasRegion.packedHeight - atlasRegion.offsetY;\n      // }\n\n      let x = glyph.srcX;\n      let x2 = glyph.srcX + glyph.width;\n      let y = glyph.srcY;\n      let y2 = glyph.srcY + glyph.height; // Shift glyph for left and top edge stripped whitespace. Clip glyph for right and bottom edge stripped whitespace.\n      // Note if the font region has padding, whitespace stripping must not be used.\n\n      if (offsetX > 0) {\n        x -= offsetX;\n\n        if (x < 0) {\n          glyph.width += x;\n          glyph.xoffset -= x;\n          x = 0;\n        }\n\n        x2 -= offsetX;\n\n        if (x2 > regionWidth) {\n          glyph.width -= x2 - regionWidth;\n          x2 = regionWidth;\n        }\n      }\n\n      if (offsetY > 0) {\n        y -= offsetY;\n\n        if (y < 0) {\n          glyph.height += y;\n          if (glyph.height < 0) glyph.height = 0;\n          y = 0;\n        }\n\n        y2 -= offsetY;\n\n        if (y2 > regionHeight) {\n          const amount = y2 - regionHeight;\n          glyph.height -= amount;\n          glyph.yoffset += amount;\n          y2 = regionHeight;\n        }\n      }\n\n      glyph.u = u + x * invTexWidth;\n      glyph.u2 = u + x2 * invTexWidth;\n\n      if (this.flipped) {\n        glyph.v = v + y * invTexHeight;\n        glyph.v2 = v + y2 * invTexHeight;\n      } else {\n        glyph.v2 = v + y * invTexHeight;\n        glyph.v = v + y2 * invTexHeight;\n      }\n    };\n    /** Sets the line height, which is the distance from one line of text to the next. */\n\n\n    this.setLineHeight = height => {\n      this.lineHeight = height * this.scaleY;\n      this.down = this.flipped ? this.lineHeight : -this.lineHeight;\n    };\n\n    this.setGlyph = (ch, glyph) => {\n      let page = this.glyphs[ch / Glyph_1.PAGE_SIZE];\n\n      if (!page) {\n        page = new Array(Glyph_1.PAGE_SIZE);\n        this.glyphs[ch / Glyph_1.PAGE_SIZE] = page; // this.glyphs[ch / PAGE_SIZE] = page = new Glyph[PAGE_SIZE];\n      }\n\n      page[ch & Glyph_1.PAGE_SIZE - 1] = glyph;\n    };\n\n    this.getFirstGlyph = () => {\n      const glyphValues = Object.values(this.glyphs);\n\n      for (let i = 0; i < glyphValues.length; i++) {\n        const page = glyphValues[i];\n        if (!page) continue;\n\n        for (let j = 0; j < page.length; j++) {\n          const glyph = page[j];\n          if (!glyph || glyph.height === 0 || glyph.width === 0) continue;\n          return glyph;\n        }\n      }\n    };\n    /** Returns true if the font has the glyph, or if the font has a {@link #missingGlyph}. */\n\n\n    this.hasGlyph = ch => {\n      if (this.missingGlyph) return true;\n      return this.getGlyph(ch) != null;\n    };\n    /** Returns the glyph for the specified character, or null if no such glyph exists. Note that\r\n     * {@link #getGlyphs(GlyphRun, CharSequence, int, int, Glyph)} should be be used to shape a string of characters into a list\r\n     * of glyphs. */\n\n\n    this.getGlyph = ch => {\n      const page = this.glyphs[ch.charCodeAt(0) / Glyph_1.PAGE_SIZE];\n      if (page != null) return page[ch.charCodeAt(0) & Glyph_1.PAGE_SIZE - 1];\n      return undefined;\n    };\n    /** Using the specified string, populates the glyphs and positions of the specified glyph run.\r\n     * @param str Characters to convert to glyphs. Will not contain newline or color tags. May contain \"[[\" for an escaped left\r\n     *           square bracket.\r\n     * @param lastGlyph The glyph immediately before this run, or null if this is run is the first on a line of text. Used tp\r\n     *           apply kerning between the specified glyph and the first glyph in this run. */\n\n\n    this.getGlyphs = (run, str, start, end, lastGlyph) => {\n      const max = end - start;\n      if (max === 0) return;\n      let markupEnabled = this.markupEnabled;\n      const scaleX = this.scaleX;\n      const glyphs = run.glyphs;\n      const xAdvances = run.xAdvances; // Guess at number of glyphs needed.\n      // glyphs.ensureCapacity(max);\n      // run.xAdvances.ensureCapacity(max + 1);\n\n      do {\n        const ch = str.charAt(start++);\n        if (ch === '\\r') continue; // Ignore.\n\n        let glyph = this.getGlyph(ch);\n\n        if (!glyph) {\n          if (!this.missingGlyph) continue;\n          glyph = this.missingGlyph;\n        }\n\n        glyphs.push(glyph);\n        xAdvances.push(!lastGlyph // First glyph on line, adjust the position so it isn't drawn left of 0.\n        ? glyph.fixedWidth ? 0 : -glyph.xoffset * scaleX - this.padLeft : (lastGlyph.xadvance + lastGlyph.getKerning(ch)) * scaleX);\n        lastGlyph = glyph; // \"[[\" is an escaped left square bracket, skip second character.\n\n        if (markupEnabled && ch === '[' && start < end && str.charAt(start) === '[') start++;\n      } while (start < end);\n\n      if (lastGlyph) {\n        const lastGlyphWidth = lastGlyph.fixedWidth ? lastGlyph.xadvance * scaleX : (lastGlyph.width + lastGlyph.xoffset) * scaleX - this.padRight;\n        xAdvances.push(lastGlyphWidth);\n      }\n    };\n    /** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\r\n     * (typically) moving toward the beginning of the glyphs array. */\n\n\n    this.getWrapIndex = (glyphs, start) => {\n      let i = start - 1;\n      const glyphsItems = glyphs;\n      let ch = glyphsItems[i].id;\n      if (this.isWhitespace(ch + '')) return i;\n      if (this.isBreakChar(ch + '')) i--;\n\n      for (; i > 0; i--) {\n        ch = glyphsItems[i].id;\n\n        if (this.isWhitespace(ch + '') || this.isBreakChar(ch + '')) {\n          return i + 1;\n        }\n      }\n\n      return 0;\n    };\n\n    this.isBreakChar = c => {\n      if (!this.breakChars) return false;\n      const character = String.fromCharCode(parseInt(c));\n\n      for (let i = 0; i < this.breakChars.length; i++) {\n        if (character === this.breakChars[i]) return true;\n      }\n\n      return false;\n    };\n\n    this.isWhitespace = c => {\n      const character = String.fromCharCode(parseInt(c));\n\n      switch (character) {\n        case '\\n':\n        case '\\r':\n        case '\\t':\n        case ' ':\n          return true;\n\n        default:\n          return false;\n      }\n    };\n    /** Returns the image path for the texture page at the given index (the \"id\" in the BMFont file). */\n\n\n    this.getImagePath = index => {\n      return this.imagePaths[index];\n    };\n\n    this.getImagePaths = () => {\n      return this.imagePaths;\n    };\n    /** Scales the font by the specified amounts on both axes\r\n     * <p>\r\n     * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}.\r\n     * The default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.\r\n     * @throws IllegalArgumentException if scaleX or scaleY is zero. */\n\n\n    this.setScale = (scaleX, scaleY) => {\n      if (scaleX === 0 || scaleY === 0) return;\n      const x = scaleX / this.scaleX;\n      const y = scaleY / this.scaleY;\n      this.lineHeight *= y;\n      this.spaceXadvance *= x;\n      this.xHeight *= y;\n      this.capHeight *= y;\n      this.ascent *= y;\n      this.descent *= y;\n      this.down *= y;\n      this.padLeft *= x;\n      this.padRight *= x;\n      this.padTop *= y;\n      this.padBottom *= y;\n      this.scaleX = scaleX;\n      this.scaleY = scaleY;\n    };\n    /** Sets the font's scale relative to the current scale.\r\n     * @see #setScale(float, float)\r\n     * @throws IllegalArgumentException if the resulting scale is zero. */\n\n\n    this.scale = amount => {\n      this.setScale(this.scaleX + amount, this.scaleY + amount);\n    };\n\n    this.fontFile = fontFile;\n    this.flipped = flip;\n  }\n  /** Scales the font by the specified amount in both directions.\r\n   * @see #setScale(float, float)\r\n   * @throws IllegalArgumentException if scaleX or scaleY is zero. */\n\n\n  setXYScale(scaleXY) {\n    this.setScale(scaleXY, scaleXY);\n  }\n\n}\n\nexports.BitmapFontData = BitmapFontData;\n\nclass StringTokenizer {\n  constructor(str, delimitter) {\n    this.strArray = [];\n    this.currentIndex = 0;\n    const strings = str.split(/\\s+/);\n\n    for (let i = 0; i < strings.length; i++) {\n      const st = strings[i];\n      this.strArray.push(...st.split(delimitter));\n    }\n  }\n\n  hasMoreTokens() {\n    return this.currentIndex >= this.strArray.length;\n  }\n\n  nextToken() {\n    return this.strArray[this.currentIndex++];\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","BitmapFontData","Glyph_1","require","Texture_1","TextureRegion_1","concatAndResolveUrl","url","concat","url1","split","url2","url3","i","l","length","pop","push","join","CHARACTER_MAX_VALUE","constructor","fontFile","flip","capHeight","blankLineScale","scaleX","scaleY","glyphs","xHeight","xChars","capChars","loadFont","gl","console","log","imagePaths","fileContent","res","fetch","text","lines","map","s","trim","line","Error","substring","indexOf","padding","padTop","parseInt","padRight","padBottom","padLeft","padY","common","startsWith","lineHeight","baseLine","pageCount","Math","max","_a","Array","p","idMatches","match","RegExp","id","pageID","_b","fileMatches","fileName","descent","glyph","Glyph","tokens","StringTokenizer","nextToken","ch","srcX","srcY","width","height","xoffset","flipped","yoffset","xadvance","hasMoreTokens","page","_c","min","missingGlyph","setGlyph","first","second","getGlyph","amount","setKerning","hasMetricsOverride","overrideAscent","overrideDescent","overrideDown","overrideCapHeight","overrideLineHeight","overrideSpaceXAdvance","overrideXHeight","parseFloat","spaceGlyph","xadvanceGlyph","getFirstGlyph","spaceXadvance","xGlyph","capGlyph","glyphValues","values","j","ascent","down","regionsData","region","left","top","pageId","pages","texture","Texture","load","invTexWidth","invTexHeight","regions","regionData","TextureRegion","originalWidth","originalHeight","offsetX","offsetY","ex","error","setGlyphRegion","u","v","regionWidth","regionHeight","x","x2","y","y2","u2","v2","setLineHeight","PAGE_SIZE","hasGlyph","charCodeAt","undefined","getGlyphs","run","str","start","end","lastGlyph","markupEnabled","xAdvances","charAt","fixedWidth","getKerning","lastGlyphWidth","getWrapIndex","glyphsItems","isWhitespace","isBreakChar","c","breakChars","character","String","fromCharCode","getImagePath","index","getImagePaths","setScale","scale","setXYScale","scaleXY","delimitter","strArray","currentIndex","strings","st"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/BitmapFontData.js"],"sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BitmapFontData = void 0;\r\nconst Glyph_1 = require(\"./Glyph\");\r\nconst Texture_1 = require(\"./Texture\");\r\nconst TextureRegion_1 = require(\"./TextureRegion\");\r\nfunction concatAndResolveUrl(url, concat) {\r\n    let url1 = url.split('/');\r\n    let url2 = concat.split('/');\r\n    let url3 = [];\r\n    for (let i = 0, l = url1.length; i < l; i++) {\r\n        if (url1[i] === '..') {\r\n            url3.pop();\r\n        }\r\n        else if (url1[i] === '.') {\r\n            continue;\r\n        }\r\n        else {\r\n            url3.push(url1[i]);\r\n        }\r\n    }\r\n    for (let i = 0, l = url2.length; i < l; i++) {\r\n        if (url2[i] === '..') {\r\n            url3.pop();\r\n        }\r\n        else if (url2[i] === '.') {\r\n            continue;\r\n        }\r\n        else {\r\n            url3.push(url2[i]);\r\n        }\r\n    }\r\n    return url3.join('/');\r\n}\r\nconst CHARACTER_MAX_VALUE = 65535;\r\nclass BitmapFontData {\r\n    /** Creates an empty BitmapFontData for configuration before calling {@link #load(FileHandle, boolean)}, to subclass, or to\r\n     * populate yourself, e.g. using stb-truetype or FreeType. */\r\n    constructor(fontFile, flip) {\r\n        /** The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of\r\n         * the first line, the cap height can be used to get the location of the baseline. */\r\n        this.capHeight = 1;\r\n        /** Multiplier for the line height of blank lines. down * blankLineHeight is used as the distance to move down for a blank\r\n         * line. */\r\n        this.blankLineScale = 1;\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.glyphs = {};\r\n        /** The x-height, which is the distance from the top of most lowercase characters to the baseline. */\r\n        this.xHeight = 1;\r\n        this.xChars = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z'];\r\n        this.capChars = [\r\n            'M',\r\n            'N',\r\n            'B',\r\n            'D',\r\n            'C',\r\n            'E',\r\n            'F',\r\n            'K',\r\n            'A',\r\n            'G',\r\n            'H',\r\n            'I',\r\n            'J',\r\n            'L',\r\n            'O',\r\n            'P',\r\n            'Q',\r\n            'R',\r\n            'S',\r\n            'T',\r\n            'U',\r\n            'V',\r\n            'W',\r\n            'X',\r\n            'Y',\r\n            'Z'\r\n        ];\r\n        this.loadFont = (gl) => __awaiter(this, void 0, void 0, function* () {\r\n            console.log(\r\n                \"vclll\"\r\n            );\r\n            if (this.imagePaths != null)\r\n                return;\r\n            let i = 0;\r\n            let fileContent;\r\n            const res = yield fetch(this.fontFile);\r\n            fileContent = yield res.text();\r\n            const lines = fileContent.split(/\\r?\\n/).map((s) => s.trim());\r\n            try {\r\n                let line = lines[i];\r\n                if (typeof line !== 'string')\r\n                    throw new Error('File is empty.');\r\n                line = line.substring(line.indexOf('padding=') + 8);\r\n                const padding = line.substring(0, line.indexOf(' ')).split(',', 4);\r\n                if (padding.length !== 4)\r\n                    throw new Error('Invalid padding.');\r\n                this.padTop = parseInt(padding[0]);\r\n                this.padRight = parseInt(padding[1]);\r\n                this.padBottom = parseInt(padding[2]);\r\n                this.padLeft = parseInt(padding[3]);\r\n                const padY = this.padTop + this.padBottom;\r\n                i++;\r\n                line = lines[i];\r\n                if (typeof line !== 'string')\r\n                    throw new Error('Missing common header.');\r\n                const common = line.split(' ', 9); // At most we want the 6th element; i.e. \"page=N\"\r\n                // At least lineHeight and base are required.\r\n                if (common.length < 3)\r\n                    throw new Error('Invalid common header.');\r\n                if (!common[1].startsWith('lineHeight='))\r\n                    throw new Error('Missing: lineHeight');\r\n                this.lineHeight = parseInt(common[1].substring(11));\r\n                if (!common[2].startsWith('base='))\r\n                    throw new Error('Missing: base');\r\n                const baseLine = parseInt(common[2].substring(5));\r\n                let pageCount = 1;\r\n                if (common.length >= 6 && common[5] != null && common[5].startsWith('pages=')) {\r\n                    try {\r\n                        pageCount = Math.max(1, parseInt(common[5].substring(6)));\r\n                    }\r\n                    catch (_a) {\r\n                        // Use one page.\r\n                    }\r\n                }\r\n                this.imagePaths = new Array(pageCount);\r\n                const imagePaths = [];\r\n                // Read each page definition.\r\n                for (let p = 0; p < pageCount; p++) {\r\n                    // Read each \"page\" info line.\r\n                    i++;\r\n                    line = lines[i];\r\n                    if (typeof line !== 'string')\r\n                        throw new Error('Missing additional page definitions.');\r\n                    // Expect ID to mean \"index\".\r\n                    const idMatches = line.match(new RegExp('.*id=(\\\\d+)'));\r\n                    if (idMatches && idMatches.length > 1) {\r\n                        const id = idMatches[1];\r\n                        try {\r\n                            const pageID = parseInt(id);\r\n                            if (pageID !== p)\r\n                                throw new Error('Page IDs must be indices starting at 0: ' + id);\r\n                        }\r\n                        catch (_b) { }\r\n                    }\r\n                    const fileMatches = line.match(new RegExp('.*file=\"?([^\"]+)\"?'));\r\n                    if (!fileMatches || fileMatches.length <= 1)\r\n                        throw new Error('Missing: file');\r\n                    const fileName = fileMatches[1];\r\n                    imagePaths[p] = fileName;\r\n                    // this.imagePaths[p] = fontFile.parent().child(fileName).path().replaceAll(\"\\\\\\\\\", \"/\");\r\n                }\r\n                this.descent = 0;\r\n                while (true) {\r\n                    i++;\r\n                    line = lines[i];\r\n                    if (!line)\r\n                        break; // EOF\r\n                    if (line.startsWith('kernings '))\r\n                        break; // Starting kernings block.\r\n                    if (line.startsWith('metrics '))\r\n                        break; // Starting metrics block.\r\n                    if (!line.startsWith('char '))\r\n                        continue;\r\n                    const glyph = new Glyph_1.Glyph();\r\n                    const tokens = new StringTokenizer(line, '=');\r\n                    tokens.nextToken();\r\n                    tokens.nextToken();\r\n                    const ch = parseInt(tokens.nextToken());\r\n                    if (ch > 0 && ch > CHARACTER_MAX_VALUE)\r\n                        continue;\r\n                    glyph.id = ch + '';\r\n                    tokens.nextToken();\r\n                    glyph.srcX = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    glyph.srcY = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    glyph.width = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    glyph.height = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    glyph.xoffset = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    if (this.flipped)\r\n                        glyph.yoffset = parseInt(tokens.nextToken());\r\n                    else\r\n                        glyph.yoffset = -(glyph.height + parseInt(tokens.nextToken()));\r\n                    tokens.nextToken();\r\n                    glyph.xadvance = parseInt(tokens.nextToken());\r\n                    // Check for page safely, it could be omitted or invalid.\r\n                    if (tokens.hasMoreTokens())\r\n                        tokens.nextToken();\r\n                    if (tokens.hasMoreTokens()) {\r\n                        try {\r\n                            glyph.page = parseInt(tokens.nextToken());\r\n                        }\r\n                        catch (_c) { }\r\n                    }\r\n                    if (glyph.width > 0 && glyph.height > 0)\r\n                        this.descent = Math.min(baseLine + glyph.yoffset, this.descent);\r\n                    if (ch <= 0) {\r\n                        this.missingGlyph = glyph;\r\n                    }\r\n                    else if (ch <= CHARACTER_MAX_VALUE) {\r\n                        this.setGlyph(ch, glyph);\r\n                    }\r\n                }\r\n                this.descent += this.padBottom;\r\n                while (true) {\r\n                    i++;\r\n                    line = lines[i];\r\n                    if (typeof line !== 'string')\r\n                        break;\r\n                    if (!line.startsWith('kerning '))\r\n                        break;\r\n                    const tokens = new StringTokenizer(line, '=');\r\n                    tokens.nextToken();\r\n                    tokens.nextToken();\r\n                    let first = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    let second = parseInt(tokens.nextToken());\r\n                    if (first < 0 || first > CHARACTER_MAX_VALUE || second < 0 || second > CHARACTER_MAX_VALUE)\r\n                        continue;\r\n                    const glyph = this.getGlyph(first + '');\r\n                    tokens.nextToken();\r\n                    const amount = parseInt(tokens.nextToken());\r\n                    if (glyph) {\r\n                        // Kernings may exist for glyph pairs not contained in the font.\r\n                        glyph.setKerning(second, amount);\r\n                    }\r\n                }\r\n                let hasMetricsOverride = false;\r\n                let overrideAscent = 0;\r\n                let overrideDescent = 0;\r\n                let overrideDown = 0;\r\n                let overrideCapHeight = 0;\r\n                let overrideLineHeight = 0;\r\n                let overrideSpaceXAdvance = 0;\r\n                let overrideXHeight = 0;\r\n                // Metrics override\r\n                if (line != null && line.startsWith('metrics ')) {\r\n                    hasMetricsOverride = true;\r\n                    const tokens = new StringTokenizer(line, '=');\r\n                    tokens.nextToken();\r\n                    tokens.nextToken();\r\n                    overrideAscent = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideDescent = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideDown = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideCapHeight = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideLineHeight = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideSpaceXAdvance = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideXHeight = parseFloat(tokens.nextToken());\r\n                }\r\n                let spaceGlyph = this.getGlyph('32');\r\n                if (!spaceGlyph) {\r\n                    spaceGlyph = new Glyph_1.Glyph();\r\n                    spaceGlyph.id = '32';\r\n                    let xadvanceGlyph = this.getGlyph('l');\r\n                    if (!xadvanceGlyph)\r\n                        xadvanceGlyph = this.getFirstGlyph();\r\n                    spaceGlyph.xadvance = xadvanceGlyph.xadvance;\r\n                    this.setGlyph(32, spaceGlyph); // space character ascii code\r\n                }\r\n                if (spaceGlyph.width === 0) {\r\n                    spaceGlyph.width = this.padLeft + spaceGlyph.xadvance + this.padRight;\r\n                    spaceGlyph.xoffset = -this.padLeft;\r\n                }\r\n                this.spaceXadvance = spaceGlyph.xadvance;\r\n                let xGlyph;\r\n                for (let i = 0; i < this.xChars.length; i++) {\r\n                    xGlyph = this.getGlyph(this.xChars[i]);\r\n                    if (xGlyph)\r\n                        break;\r\n                }\r\n                if (!xGlyph)\r\n                    xGlyph = this.getFirstGlyph();\r\n                this.xHeight = xGlyph.height - padY;\r\n                let capGlyph;\r\n                for (let i = 0; i < this.capChars.length; i++) {\r\n                    capGlyph = this.getGlyph(this.capChars[i]);\r\n                    if (capGlyph)\r\n                        break;\r\n                }\r\n                if (!capGlyph) {\r\n                    const glyphValues = Object.values(this.glyphs);\r\n                    for (let i = 0; i < glyphValues.length; i++) {\r\n                        const page = glyphValues[i];\r\n                        if (!page)\r\n                            continue;\r\n                        for (let j = 0; j < page.length; j++) {\r\n                            if (!page[j] || page[j].height === 0 || page[j].width === 0)\r\n                                continue;\r\n                            this.capHeight = Math.max(this.capHeight, page[j].height);\r\n                        }\r\n                    }\r\n                }\r\n                else\r\n                    this.capHeight = capGlyph.height;\r\n                this.capHeight -= padY;\r\n                this.ascent = baseLine - this.capHeight;\r\n                this.down = -this.lineHeight;\r\n                if (this.flipped) {\r\n                    this.ascent = -this.ascent;\r\n                    this.down = -this.down;\r\n                }\r\n                if (hasMetricsOverride) {\r\n                    this.ascent = overrideAscent;\r\n                    this.descent = overrideDescent;\r\n                    this.down = overrideDown;\r\n                    this.capHeight = overrideCapHeight;\r\n                    this.lineHeight = overrideLineHeight;\r\n                    this.spaceXadvance = overrideSpaceXAdvance;\r\n                    this.xHeight = overrideXHeight;\r\n                }\r\n                // Generate texture regions\r\n                const regionsData = [];\r\n                const glyphValues = Object.values(this.glyphs);\r\n                for (let i = 0; i < glyphValues.length; i++) {\r\n                    const values = Object.values(glyphValues[i]);\r\n                    for (let j = 0; j < values.length; j++) {\r\n                        const region = {\r\n                            id: values[j].id,\r\n                            left: values[j].srcX,\r\n                            top: values[j].srcY,\r\n                            width: values[j].width,\r\n                            height: values[j].height,\r\n                            xoffset: values[j].xoffset,\r\n                            yoffset: values[j].yoffset,\r\n                            xadvance: values[j].xadvance,\r\n                            page: imagePaths[values[j].page],\r\n                            pageId: values[j].page\r\n                        };\r\n                        regionsData.push(region);\r\n                    }\r\n                }\r\n                const pages = [];\r\n                for (let i = 0; i < pageCount; i++) {\r\n                    const texture = yield Texture_1.Texture.load(gl, concatAndResolveUrl(this.fontFile, `../${imagePaths[i]}`));\r\n                    const invTexWidth = 1 / texture.width;\r\n                    const invTexHeight = 1 / texture.height;\r\n                    pages.push({\r\n                        texture,\r\n                        invTexWidth,\r\n                        invTexHeight\r\n                    });\r\n                }\r\n                this.regions = [];\r\n                for (let regionData of regionsData) {\r\n                    const left = regionData.left;\r\n                    const top = regionData.top;\r\n                    const width = regionData.width;\r\n                    const height = regionData.height;\r\n                    const { texture, invTexWidth, invTexHeight } = pages[regionData.pageId];\r\n                    const region = new TextureRegion_1.TextureRegion(texture, left, top, width, height, regionData, invTexWidth, invTexHeight);\r\n                    region.originalWidth = width;\r\n                    region.originalHeight = height;\r\n                    region.offsetX = 0;\r\n                    region.offsetY = 0;\r\n                    this.regions.push(region);\r\n                }\r\n            }\r\n            catch (ex) {\r\n                console.error(ex);\r\n            }\r\n        });\r\n        this.setGlyphRegion = (glyph, region) => {\r\n            const texture = region.texture;\r\n            const invTexWidth = 1 / texture.width;\r\n            const invTexHeight = 1 / texture.height;\r\n            let offsetX = 0, offsetY = 0;\r\n            const u = region.u;\r\n            const v = region.v;\r\n            const regionWidth = region.originalWidth;\r\n            const regionHeight = region.originalHeight;\r\n            // if (region instanceof AtlasRegion) {\r\n            //    // Compensate for whitespace stripped from left and top edges.\r\n            //    AtlasRegion atlasRegion = (AtlasRegion)region;\r\n            //    offsetX = atlasRegion.offsetX;\r\n            //    offsetY = atlasRegion.originalHeight - atlasRegion.packedHeight - atlasRegion.offsetY;\r\n            // }\r\n            let x = glyph.srcX;\r\n            let x2 = glyph.srcX + glyph.width;\r\n            let y = glyph.srcY;\r\n            let y2 = glyph.srcY + glyph.height;\r\n            // Shift glyph for left and top edge stripped whitespace. Clip glyph for right and bottom edge stripped whitespace.\r\n            // Note if the font region has padding, whitespace stripping must not be used.\r\n            if (offsetX > 0) {\r\n                x -= offsetX;\r\n                if (x < 0) {\r\n                    glyph.width += x;\r\n                    glyph.xoffset -= x;\r\n                    x = 0;\r\n                }\r\n                x2 -= offsetX;\r\n                if (x2 > regionWidth) {\r\n                    glyph.width -= x2 - regionWidth;\r\n                    x2 = regionWidth;\r\n                }\r\n            }\r\n            if (offsetY > 0) {\r\n                y -= offsetY;\r\n                if (y < 0) {\r\n                    glyph.height += y;\r\n                    if (glyph.height < 0)\r\n                        glyph.height = 0;\r\n                    y = 0;\r\n                }\r\n                y2 -= offsetY;\r\n                if (y2 > regionHeight) {\r\n                    const amount = y2 - regionHeight;\r\n                    glyph.height -= amount;\r\n                    glyph.yoffset += amount;\r\n                    y2 = regionHeight;\r\n                }\r\n            }\r\n            glyph.u = u + x * invTexWidth;\r\n            glyph.u2 = u + x2 * invTexWidth;\r\n            if (this.flipped) {\r\n                glyph.v = v + y * invTexHeight;\r\n                glyph.v2 = v + y2 * invTexHeight;\r\n            }\r\n            else {\r\n                glyph.v2 = v + y * invTexHeight;\r\n                glyph.v = v + y2 * invTexHeight;\r\n            }\r\n        };\r\n        /** Sets the line height, which is the distance from one line of text to the next. */\r\n        this.setLineHeight = (height) => {\r\n            this.lineHeight = height * this.scaleY;\r\n            this.down = this.flipped ? this.lineHeight : -this.lineHeight;\r\n        };\r\n        this.setGlyph = (ch, glyph) => {\r\n            let page = this.glyphs[ch / Glyph_1.PAGE_SIZE];\r\n            if (!page) {\r\n                page = new Array(Glyph_1.PAGE_SIZE);\r\n                this.glyphs[ch / Glyph_1.PAGE_SIZE] = page;\r\n                // this.glyphs[ch / PAGE_SIZE] = page = new Glyph[PAGE_SIZE];\r\n            }\r\n            page[ch & (Glyph_1.PAGE_SIZE - 1)] = glyph;\r\n        };\r\n        this.getFirstGlyph = () => {\r\n            const glyphValues = Object.values(this.glyphs);\r\n            for (let i = 0; i < glyphValues.length; i++) {\r\n                const page = glyphValues[i];\r\n                if (!page)\r\n                    continue;\r\n                for (let j = 0; j < page.length; j++) {\r\n                    const glyph = page[j];\r\n                    if (!glyph || glyph.height === 0 || glyph.width === 0)\r\n                        continue;\r\n                    return glyph;\r\n                }\r\n            }\r\n        };\r\n        /** Returns true if the font has the glyph, or if the font has a {@link #missingGlyph}. */\r\n        this.hasGlyph = (ch) => {\r\n            if (this.missingGlyph)\r\n                return true;\r\n            return this.getGlyph(ch) != null;\r\n        };\r\n        /** Returns the glyph for the specified character, or null if no such glyph exists. Note that\r\n         * {@link #getGlyphs(GlyphRun, CharSequence, int, int, Glyph)} should be be used to shape a string of characters into a list\r\n         * of glyphs. */\r\n        this.getGlyph = (ch) => {\r\n            const page = this.glyphs[ch.charCodeAt(0) / Glyph_1.PAGE_SIZE];\r\n            if (page != null)\r\n                return page[ch.charCodeAt(0) & (Glyph_1.PAGE_SIZE - 1)];\r\n            return undefined;\r\n        };\r\n        /** Using the specified string, populates the glyphs and positions of the specified glyph run.\r\n         * @param str Characters to convert to glyphs. Will not contain newline or color tags. May contain \"[[\" for an escaped left\r\n         *           square bracket.\r\n         * @param lastGlyph The glyph immediately before this run, or null if this is run is the first on a line of text. Used tp\r\n         *           apply kerning between the specified glyph and the first glyph in this run. */\r\n        this.getGlyphs = (run, str, start, end, lastGlyph) => {\r\n            const max = end - start;\r\n            if (max === 0)\r\n                return;\r\n            let markupEnabled = this.markupEnabled;\r\n            const scaleX = this.scaleX;\r\n            const glyphs = run.glyphs;\r\n            const xAdvances = run.xAdvances;\r\n            // Guess at number of glyphs needed.\r\n            // glyphs.ensureCapacity(max);\r\n            // run.xAdvances.ensureCapacity(max + 1);\r\n            do {\r\n                const ch = str.charAt(start++);\r\n                if (ch === '\\r')\r\n                    continue; // Ignore.\r\n                let glyph = this.getGlyph(ch);\r\n                if (!glyph) {\r\n                    if (!this.missingGlyph)\r\n                        continue;\r\n                    glyph = this.missingGlyph;\r\n                }\r\n                glyphs.push(glyph);\r\n                xAdvances.push(!lastGlyph // First glyph on line, adjust the position so it isn't drawn left of 0.\r\n                    ? glyph.fixedWidth\r\n                        ? 0\r\n                        : -glyph.xoffset * scaleX - this.padLeft\r\n                    : (lastGlyph.xadvance + lastGlyph.getKerning(ch)) * scaleX);\r\n                lastGlyph = glyph;\r\n                // \"[[\" is an escaped left square bracket, skip second character.\r\n                if (markupEnabled && ch === '[' && start < end && str.charAt(start) === '[')\r\n                    start++;\r\n            } while (start < end);\r\n            if (lastGlyph) {\r\n                const lastGlyphWidth = lastGlyph.fixedWidth\r\n                    ? lastGlyph.xadvance * scaleX\r\n                    : (lastGlyph.width + lastGlyph.xoffset) * scaleX - this.padRight;\r\n                xAdvances.push(lastGlyphWidth);\r\n            }\r\n        };\r\n        /** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\r\n         * (typically) moving toward the beginning of the glyphs array. */\r\n        this.getWrapIndex = (glyphs, start) => {\r\n            let i = start - 1;\r\n            const glyphsItems = glyphs;\r\n            let ch = glyphsItems[i].id;\r\n            if (this.isWhitespace(ch + ''))\r\n                return i;\r\n            if (this.isBreakChar(ch + ''))\r\n                i--;\r\n            for (; i > 0; i--) {\r\n                ch = glyphsItems[i].id;\r\n                if (this.isWhitespace(ch + '') || this.isBreakChar(ch + '')) {\r\n                    return i + 1;\r\n                }\r\n            }\r\n            return 0;\r\n        };\r\n        this.isBreakChar = (c) => {\r\n            if (!this.breakChars)\r\n                return false;\r\n            const character = String.fromCharCode(parseInt(c));\r\n            for (let i = 0; i < this.breakChars.length; i++) {\r\n                if (character === this.breakChars[i])\r\n                    return true;\r\n            }\r\n            return false;\r\n        };\r\n        this.isWhitespace = (c) => {\r\n            const character = String.fromCharCode(parseInt(c));\r\n            switch (character) {\r\n                case '\\n':\r\n                case '\\r':\r\n                case '\\t':\r\n                case ' ':\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        };\r\n        /** Returns the image path for the texture page at the given index (the \"id\" in the BMFont file). */\r\n        this.getImagePath = (index) => {\r\n            return this.imagePaths[index];\r\n        };\r\n        this.getImagePaths = () => {\r\n            return this.imagePaths;\r\n        };\r\n        /** Scales the font by the specified amounts on both axes\r\n         * <p>\r\n         * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}.\r\n         * The default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.\r\n         * @throws IllegalArgumentException if scaleX or scaleY is zero. */\r\n        this.setScale = (scaleX, scaleY) => {\r\n            if (scaleX === 0 || scaleY === 0)\r\n                return;\r\n            const x = scaleX / this.scaleX;\r\n            const y = scaleY / this.scaleY;\r\n            this.lineHeight *= y;\r\n            this.spaceXadvance *= x;\r\n            this.xHeight *= y;\r\n            this.capHeight *= y;\r\n            this.ascent *= y;\r\n            this.descent *= y;\r\n            this.down *= y;\r\n            this.padLeft *= x;\r\n            this.padRight *= x;\r\n            this.padTop *= y;\r\n            this.padBottom *= y;\r\n            this.scaleX = scaleX;\r\n            this.scaleY = scaleY;\r\n        };\r\n        /** Sets the font's scale relative to the current scale.\r\n         * @see #setScale(float, float)\r\n         * @throws IllegalArgumentException if the resulting scale is zero. */\r\n        this.scale = (amount) => {\r\n            this.setScale(this.scaleX + amount, this.scaleY + amount);\r\n        };\r\n        this.fontFile = fontFile;\r\n        this.flipped = flip;\r\n    }\r\n    /** Scales the font by the specified amount in both directions.\r\n     * @see #setScale(float, float)\r\n     * @throws IllegalArgumentException if scaleX or scaleY is zero. */\r\n    setXYScale(scaleXY) {\r\n        this.setScale(scaleXY, scaleXY);\r\n    }\r\n}\r\nexports.BitmapFontData = BitmapFontData;\r\nclass StringTokenizer {\r\n    constructor(str, delimitter) {\r\n        this.strArray = [];\r\n        this.currentIndex = 0;\r\n        const strings = str.split(/\\s+/);\r\n        for (let i = 0; i < strings.length; i++) {\r\n            const st = strings[i];\r\n            this.strArray.push(...st.split(delimitter));\r\n        }\r\n    }\r\n    hasMoreTokens() {\r\n        return this.currentIndex >= this.strArray.length;\r\n    }\r\n    nextToken() {\r\n        return this.strArray[this.currentIndex++];\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}