{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitmapFontCache = void 0;\n\nconst GlyphLayout_1 = require(\"./GlyphLayout\");\n\nconst NumberUtils_1 = require(\"./NumberUtils\");\n\nconst Utils_1 = require(\"./Utils\");\n\nclass BitmapFontCache {\n  /** @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */\n  constructor(font, integer) {\n    this.tempColor = new Utils_1.Color(1, 1, 1, 1);\n    this.drawingTexts = [];\n    this.layouts = [];\n    this.pooledLayouts = [];\n    this.color = new Utils_1.Color(1, 1, 1, 1);\n    /** Sets the position of the text, relative to the position when the cached text was created.\n     * @param x The x coordinate\n     * @param y The y coordinate */\n\n    this.setPosition = (x, y) => {\n      this.translate(x - this.x, y - this.y);\n    };\n    /** Sets the position of the text, relative to its current position.\n     * @param xAmount The amount in x to move the text\n     * @param yAmount The amount in y to move the text */\n\n\n    this.translate = (xAmount, yAmount) => {\n      if (xAmount === 0 && yAmount === 0) return;\n\n      if (this.integer) {\n        xAmount = Math.round(xAmount);\n        yAmount = Math.round(yAmount);\n      }\n\n      this.x += xAmount;\n      this.y += yAmount;\n      const pageVertices = this.pageVertices;\n\n      for (let i = 0, n = pageVertices.length; i < n; i++) {\n        const vertices = pageVertices[i];\n\n        for (let ii = 0, nn = this.idx[i]; ii < nn; ii += 5) {\n          vertices[ii] += xAmount;\n          vertices[ii + 1] += yAmount;\n        }\n      }\n    };\n    /** Tints all text currently in the cache. Does not affect subsequently added text. */\n    // public tint = (tint: Color) => {\n    //    const newTint: number = tint.toFloatBits();\n    //    if (this.currentTint == newTint) return;\n    //    this.currentTint = newTint;\n    //    const pageVertices: number[][] = this.pageVertices;\n    //    const tempColor: Color = this.tempColor;\n    //    const tempGlyphCount: number[] = this.tempGlyphCount;\n    //    for (let i = 0; i < tempGlyphCount.length; i++) {\n    //       tempGlyphCount[i] = 0;\n    //    }\n    //    for (let i = 0, n = this.layouts.length; i < n; i++) {\n    //       const layout: GlyphLayout = this.layouts[i];\n    //       const colors: number[] = layout.colors;\n    //       let colorsIndex = 0,\n    //          nextColorGlyphIndex = 0,\n    //          glyphIndex = 0;\n    //       let lastColorFloatBits = 0;\n    //       for (let ii = 0, nn = layout.runs.length; ii < nn; ii++) {\n    //          const run: GlyphRun = layout.runs[ii];\n    //          const glyphs: Glyph[] = run.glyphs;\n    //          for (let iii = 0, nnn = run.glyphs.length; iii < nnn; iii++) {\n    //             if (glyphIndex++ === nextColorGlyphIndex) {\n    //                Color.abgr8888ToColor(tempColor, colors[++colorsIndex]);\n    //                lastColorFloatBits = tempColor.mul(tint).toFloatBits();\n    //                nextColorGlyphIndex = ++colorsIndex < colors.length ? colors[colorsIndex] : -1;\n    //             }\n    //             const page: number = glyphs[iii].page;\n    //             const offset = tempGlyphCount[page] * 20 + 2;\n    //             tempGlyphCount[page]++;\n    //             const vertices: number[] = pageVertices[page];\n    //             vertices[offset] = lastColorFloatBits;\n    //             vertices[offset + 5] = lastColorFloatBits;\n    //             vertices[offset + 10] = lastColorFloatBits;\n    //             vertices[offset + 15] = lastColorFloatBits;\n    //          }\n    //       }\n    //    }\n    // };\n\n    /** Sets the alpha component of all text currently in the cache. Does not affect subsequently added text. */\n    // public setAlphas = (alpha: number) => {\n    //    const alphaBits: number = (254 * alpha) << 24;\n    //    let prev = 0,\n    //       newColor = 0;\n    //    for (let j = 0, length = this.pageVertices.length; j < length; j++) {\n    //       const vertices: number[] = this.pageVertices[j];\n    //       for (let i = 2, n = this.idx[j]; i < n; i += 5) {\n    //          const c: number = vertices[i];\n    //          if (c == prev && i != 2) {\n    //             vertices[i] = newColor;\n    //          } else {\n    //             prev = c;\n    //             let rgba = NumberUtils.floatToIntColor(c);\n    //             rgba = (rgba & 0x00ffffff) | alphaBits;\n    //             newColor = NumberUtils.intToFloatColor(rgba);\n    //             vertices[i] = newColor;\n    //          }\n    //       }\n    //    }\n    // };\n\n\n    this.setColors = (r, g, b, a) => {\n      const intBits = 255 << 24 | 255 * b << 16 | 255 * g << 8 | 255 * r;\n      const value = NumberUtils_1.NumberUtil.intToFloatColor(intBits);\n\n      for (let j = 0, length = this.pageVertices.length; j < length; j++) {\n        const vertices = this.pageVertices[j];\n\n        for (let i = 2, n = this.idx[j]; i < n; i += 5) vertices[i] = value;\n      }\n    };\n    /** Returns the color used for subsequently added text. Modifying the color affects text subsequently added to the cache, but\n     * does not affect existing text currently in the cache. */\n\n\n    this.getColor = () => {\n      return this.color;\n    };\n    /** A convenience method for setting the cache color. The color can also be set by modifying {@link #getColor()}. */\n\n\n    this.setColor = (r, g, b, a) => {\n      this.color.set(r, g, b, a);\n    };\n    /** Removes all glyphs in the cache. */\n\n\n    this.clear = () => {\n      this.x = 0;\n      this.y = 0;\n      Utils_1.Pools.freeAll('GlyphLayout', this.pooledLayouts);\n      this.pooledLayouts.length = 0;\n      this.layouts.length = 0;\n\n      for (let i = 0, n = this.idx.length; i < n; i++) {\n        if (this.pageGlyphIndices != null) this.pageGlyphIndices[i].length = 0;\n        this.idx[i] = 0;\n      }\n    };\n\n    this.requireGlyphs = layout => {\n      if (this.pageVertices.length === 1) {\n        // Simple if we just have one page.\n        this.requirePageGlyphs(0, layout.glyphCount);\n      } else {\n        const tempGlyphCount = this.tempGlyphCount;\n\n        for (let i = 0; i < tempGlyphCount.length; i++) {\n          tempGlyphCount[i] = 0;\n        } // Determine # of glyphs in each page.\n\n\n        for (let i = 0, n = layout.runs.length; i < n; i++) {\n          const glyphs = layout.runs[i].glyphs;\n          const glyphItems = glyphs;\n\n          for (let ii = 0, nn = glyphs.length; ii < nn; ii++) tempGlyphCount[glyphItems[ii].page]++;\n        } // Require that many for each page.\n\n\n        for (let i = 0, n = tempGlyphCount.length; i < n; i++) this.requirePageGlyphs(i, tempGlyphCount[i]);\n      }\n    };\n\n    this.requirePageGlyphs = (page, glyphCount) => {\n      // if (this.pageGlyphIndices != null) {\n      //    if (glyphCount > this.pageGlyphIndices[page].length)\n      //       this.pageGlyphIndices[page].ensureCapacity(glyphCount - this.pageGlyphIndices[page].length);\n      // }\n      const vertexCount = this.idx[page] + glyphCount * 20;\n      const vertices = this.pageVertices[page];\n\n      if (!vertices) {\n        this.pageVertices[page] = new Array(vertexCount);\n      } else if (vertices.length < vertexCount) {\n        const newVertices = new Array(vertexCount);\n        Utils_1.Utils.arrayCopy(vertices, 0, newVertices, 0, this.idx[page]);\n        this.pageVertices[page] = newVertices;\n      }\n    };\n\n    this.setPageCount = pageCount => {\n      const newPageVertices = new Array(pageCount).fill([]);\n      Utils_1.Utils.arrayCopy(this.pageVertices, 0, newPageVertices, 0, this.pageVertices.length);\n      this.pageVertices = [...newPageVertices];\n      const newIdx = new Array(pageCount);\n      Utils_1.Utils.arrayCopy(this.idx, 0, newIdx, 0, this.idx.length);\n      this.idx = newIdx;\n      const newPageGlyphIndices = new Array(pageCount);\n      let pageGlyphIndicesLength = 0;\n\n      if (this.pageGlyphIndices != null) {\n        pageGlyphIndicesLength = this.pageGlyphIndices.length;\n        Utils_1.Utils.arrayCopy(this.pageGlyphIndices, 0, newPageGlyphIndices, 0, this.pageGlyphIndices.length);\n      }\n\n      for (let i = pageGlyphIndicesLength; i < pageCount; i++) newPageGlyphIndices[i] = [];\n\n      this.pageGlyphIndices = newPageGlyphIndices;\n      this.tempGlyphCount = new Array(pageCount);\n    };\n\n    this.addToCache = (layout, x, y) => {\n      const runCount = layout.runs.length;\n      if (runCount === 0) return; // Check if the number of font pages has changed.\n\n      if (this.pageVertices.length < this.font.regions.length) this.setPageCount(this.font.regions.length);\n      this.layouts.push(layout);\n      this.requireGlyphs(layout);\n      const colors = layout.colors;\n      let colorsIndex = 0,\n          nextColorGlyphIndex = 0,\n          glyphIndex = 0;\n      let lastColorFloatBits = 0;\n      this.drawingTexts.length = 0;\n\n      for (let i = 0; i < runCount; i++) {\n        const run = layout.runs[i];\n        const glyphs = run.glyphs;\n        const xAdvances = run.xAdvances;\n        let gx = x + run.x,\n            gy = y + run.y;\n\n        for (let ii = 0, nn = run.glyphs.length; ii < nn; ii++) {\n          if (glyphIndex++ === nextColorGlyphIndex) {\n            lastColorFloatBits = NumberUtils_1.NumberUtil.intToFloatColor(colors[++colorsIndex]);\n            nextColorGlyphIndex = ++colorsIndex < colors.length ? colors[colorsIndex] : -1;\n          }\n\n          gx += xAdvances[ii];\n          this.drawingTexts.push(glyphs[ii].id);\n          this.addGlyph(glyphs[ii], gx, gy, lastColorFloatBits);\n        }\n      }\n\n      const whiteIntBits = 255 << 24 | 255 << 16 | 255 << 8 | 255;\n      this.currentTint = NumberUtils_1.NumberUtil.intToFloatColor(whiteIntBits); // Cached glyphs have changed, reset the current tint.\n    };\n\n    this.addGlyph = (glyph, x, y, color) => {\n      let scaleX = this.font.data.scaleX,\n          scaleY = this.font.data.scaleY;\n      x += glyph.xoffset * scaleX;\n      y += glyph.yoffset * scaleY;\n      let width = glyph.width * scaleX,\n          height = glyph.height * scaleY;\n      let u = glyph.u,\n          u2 = glyph.u2,\n          v = glyph.v,\n          v2 = glyph.v2;\n\n      if (this.integer) {\n        x = Math.round(x);\n        y = Math.round(y);\n        width = Math.round(width);\n        height = Math.round(height);\n      }\n\n      let x2 = x + width,\n          y2 = y + height;\n      const page = glyph.page;\n      let idx = this.idx[page];\n      this.idx[page] += 20;\n      if (this.pageGlyphIndices != null) this.pageGlyphIndices[page].push(this.glyphCount++);\n      const vertices = this.pageVertices[page];\n      vertices[idx++] = x;\n      vertices[idx++] = y;\n      vertices[idx++] = color;\n      vertices[idx++] = u;\n      vertices[idx++] = v;\n      vertices[idx++] = x;\n      vertices[idx++] = y2;\n      vertices[idx++] = color;\n      vertices[idx++] = u;\n      vertices[idx++] = v2;\n      vertices[idx++] = x2;\n      vertices[idx++] = y2;\n      vertices[idx++] = color;\n      vertices[idx++] = u2;\n      vertices[idx++] = v2;\n      vertices[idx++] = x2;\n      vertices[idx++] = y;\n      vertices[idx++] = color;\n      vertices[idx++] = u2;\n      vertices[idx] = v;\n    }; // public GlyphLayout setText (CharSequence str, float x, float y) {\n    // \tclear();\n    // \treturn addText(str, x, y, 0, str.length(), 0, Align.left, false);\n    // }\n    // public GlyphLayout setText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {\n    // \tclear();\n    // \treturn addText(str, x, y, 0, str.length(), targetWidth, halign, wrap);\n    // }\n    // public GlyphLayout setText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign,\n    // \tboolean wrap) {\n    // \tclear();\n    // \treturn addText(str, x, y, start, end, targetWidth, halign, wrap);\n    // }\n\n\n    this.setText = (str, x, y, start, end, targetWidth, halign, wrap, truncate) => {\n      this.clear();\n      return this.addText(str, x, y, start, end, targetWidth, halign, wrap, truncate);\n    };\n\n    this.setTextToCache = (layout, x, y) => {\n      this.clear();\n      this.addTextToCache(layout, x, y);\n    }; // public GlyphLayout addText (CharSequence str, float x, float y) {\n    // \treturn addText(str, x, y, 0, str.length(), 0, Align.left, false, null);\n    // }\n    // public GlyphLayout addText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {\n    // \treturn addText(str, x, y, 0, str.length(), targetWidth, halign, wrap, null);\n    // }\n    // public GlyphLayout addText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign,\n    // \tboolean wrap) {\n    // \treturn addText(str, x, y, start, end, targetWidth, halign, wrap, null);\n    // }\n\n\n    this.addText = (str, x, y, start, end, targetWidth, halign, wrap, truncate) => {\n      const layout = Utils_1.Pools.obtain('GlyphLayout');\n      this.pooledLayouts.push(layout);\n      layout.setText(this.font, str, start, end, this.color, targetWidth, halign, wrap, truncate);\n      this.addTextToCache(layout, x, y);\n      return layout;\n    };\n\n    this.addTextToCache = (layout, x, y) => {\n      this.addToCache(layout, x, y + this.font.data.ascent);\n    };\n    /** Returns the x position of the cached string, relative to the position when the string was cached. */\n\n\n    this.getX = () => {\n      return this.x;\n    };\n    /** Returns the y position of the cached string, relative to the position when the string was cached. */\n\n\n    this.getY = () => {\n      return this.y;\n    };\n\n    this.getFont = () => {\n      return this.font;\n    };\n\n    this.setUseIntegerPositions = use => {\n      this.integer = use;\n    };\n    /** @return whether this font uses integer positions for drawing. */\n\n\n    this.usesIntegerPositions = () => {\n      return this.integer;\n    };\n\n    this.getVertices = page => {\n      return this.pageVertices[page];\n    };\n\n    this.getVertexCount = page => {\n      return this.idx[page];\n    };\n\n    this.getLayouts = () => {\n      return this.layouts;\n    };\n\n    this.font = font;\n    this.integer = integer;\n    const pageCount = font.regions.length;\n    if (pageCount === 0) console.log('The specified font must contain at least one texture page.');\n    this.pageVertices = new Array(pageCount).fill([]);\n    this.idx = new Array(pageCount);\n\n    if (pageCount > 1) {\n      // Contains the indices of the glyph in the cache as they are added.\n      this.pageGlyphIndices = new Array(pageCount);\n\n      for (let i = 0, n = this.pageGlyphIndices.length; i < n; i++) this.pageGlyphIndices[i] = [];\n    }\n\n    this.tempGlyphCount = new Array(pageCount);\n    Utils_1.Pools.get('GlyphLayout', () => new GlyphLayout_1.GlyphLayout(font, '', 0, 0, Utils_1.Color.WHITE, 0, Utils_1.Align.left, false));\n  }\n\n  draw(batch) {\n    const regions = this.font.getRegions();\n\n    for (let i = 0; i < this.pageVertices.length; i++) {\n      if (this.idx[i] > 0) {\n        const vertices = this.pageVertices[i];\n\n        for (let j = 0; j < this.idx[i] / 20; j++) {\n          const offset = 20 * j;\n          const region = regions.find(item => {\n            var _a;\n\n            return item.id === ((_a = this.drawingTexts) === null || _a === void 0 ? void 0 : _a[j]);\n          });\n\n          if (region) {\n            region.draw(batch, vertices[0 + offset], vertices[1 + offset], vertices[10 + offset] - vertices[0 + offset], vertices[11 + offset] - vertices[1 + offset]);\n          }\n        }\n      }\n    }\n  }\n\n}\n\nexports.BitmapFontCache = BitmapFontCache;","map":{"version":3,"names":["Object","defineProperty","exports","value","BitmapFontCache","GlyphLayout_1","require","NumberUtils_1","Utils_1","constructor","font","integer","tempColor","Color","drawingTexts","layouts","pooledLayouts","color","setPosition","x","y","translate","xAmount","yAmount","Math","round","pageVertices","i","n","length","vertices","ii","nn","idx","setColors","r","g","b","a","intBits","NumberUtil","intToFloatColor","j","getColor","setColor","set","clear","Pools","freeAll","pageGlyphIndices","requireGlyphs","layout","requirePageGlyphs","glyphCount","tempGlyphCount","runs","glyphs","glyphItems","page","vertexCount","Array","newVertices","Utils","arrayCopy","setPageCount","pageCount","newPageVertices","fill","newIdx","newPageGlyphIndices","pageGlyphIndicesLength","addToCache","runCount","regions","push","colors","colorsIndex","nextColorGlyphIndex","glyphIndex","lastColorFloatBits","run","xAdvances","gx","gy","id","addGlyph","whiteIntBits","currentTint","glyph","scaleX","data","scaleY","xoffset","yoffset","width","height","u","u2","v","v2","x2","y2","setText","str","start","end","targetWidth","halign","wrap","truncate","addText","setTextToCache","addTextToCache","obtain","ascent","getX","getY","getFont","setUseIntegerPositions","use","usesIntegerPositions","getVertices","getVertexCount","getLayouts","console","log","get","GlyphLayout","WHITE","Align","left","draw","batch","getRegions","offset","region","find","item","_a"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/BitmapFontCache.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitmapFontCache = void 0;\nconst GlyphLayout_1 = require(\"./GlyphLayout\");\nconst NumberUtils_1 = require(\"./NumberUtils\");\nconst Utils_1 = require(\"./Utils\");\nclass BitmapFontCache {\n    /** @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */\n    constructor(font, integer) {\n        this.tempColor = new Utils_1.Color(1, 1, 1, 1);\n        this.drawingTexts = [];\n        this.layouts = [];\n        this.pooledLayouts = [];\n        this.color = new Utils_1.Color(1, 1, 1, 1);\n        /** Sets the position of the text, relative to the position when the cached text was created.\n         * @param x The x coordinate\n         * @param y The y coordinate */\n        this.setPosition = (x, y) => {\n            this.translate(x - this.x, y - this.y);\n        };\n        /** Sets the position of the text, relative to its current position.\n         * @param xAmount The amount in x to move the text\n         * @param yAmount The amount in y to move the text */\n        this.translate = (xAmount, yAmount) => {\n            if (xAmount === 0 && yAmount === 0)\n                return;\n            if (this.integer) {\n                xAmount = Math.round(xAmount);\n                yAmount = Math.round(yAmount);\n            }\n            this.x += xAmount;\n            this.y += yAmount;\n            const pageVertices = this.pageVertices;\n            for (let i = 0, n = pageVertices.length; i < n; i++) {\n                const vertices = pageVertices[i];\n                for (let ii = 0, nn = this.idx[i]; ii < nn; ii += 5) {\n                    vertices[ii] += xAmount;\n                    vertices[ii + 1] += yAmount;\n                }\n            }\n        };\n        /** Tints all text currently in the cache. Does not affect subsequently added text. */\n        // public tint = (tint: Color) => {\n        //    const newTint: number = tint.toFloatBits();\n        //    if (this.currentTint == newTint) return;\n        //    this.currentTint = newTint;\n        //    const pageVertices: number[][] = this.pageVertices;\n        //    const tempColor: Color = this.tempColor;\n        //    const tempGlyphCount: number[] = this.tempGlyphCount;\n        //    for (let i = 0; i < tempGlyphCount.length; i++) {\n        //       tempGlyphCount[i] = 0;\n        //    }\n        //    for (let i = 0, n = this.layouts.length; i < n; i++) {\n        //       const layout: GlyphLayout = this.layouts[i];\n        //       const colors: number[] = layout.colors;\n        //       let colorsIndex = 0,\n        //          nextColorGlyphIndex = 0,\n        //          glyphIndex = 0;\n        //       let lastColorFloatBits = 0;\n        //       for (let ii = 0, nn = layout.runs.length; ii < nn; ii++) {\n        //          const run: GlyphRun = layout.runs[ii];\n        //          const glyphs: Glyph[] = run.glyphs;\n        //          for (let iii = 0, nnn = run.glyphs.length; iii < nnn; iii++) {\n        //             if (glyphIndex++ === nextColorGlyphIndex) {\n        //                Color.abgr8888ToColor(tempColor, colors[++colorsIndex]);\n        //                lastColorFloatBits = tempColor.mul(tint).toFloatBits();\n        //                nextColorGlyphIndex = ++colorsIndex < colors.length ? colors[colorsIndex] : -1;\n        //             }\n        //             const page: number = glyphs[iii].page;\n        //             const offset = tempGlyphCount[page] * 20 + 2;\n        //             tempGlyphCount[page]++;\n        //             const vertices: number[] = pageVertices[page];\n        //             vertices[offset] = lastColorFloatBits;\n        //             vertices[offset + 5] = lastColorFloatBits;\n        //             vertices[offset + 10] = lastColorFloatBits;\n        //             vertices[offset + 15] = lastColorFloatBits;\n        //          }\n        //       }\n        //    }\n        // };\n        /** Sets the alpha component of all text currently in the cache. Does not affect subsequently added text. */\n        // public setAlphas = (alpha: number) => {\n        //    const alphaBits: number = (254 * alpha) << 24;\n        //    let prev = 0,\n        //       newColor = 0;\n        //    for (let j = 0, length = this.pageVertices.length; j < length; j++) {\n        //       const vertices: number[] = this.pageVertices[j];\n        //       for (let i = 2, n = this.idx[j]; i < n; i += 5) {\n        //          const c: number = vertices[i];\n        //          if (c == prev && i != 2) {\n        //             vertices[i] = newColor;\n        //          } else {\n        //             prev = c;\n        //             let rgba = NumberUtils.floatToIntColor(c);\n        //             rgba = (rgba & 0x00ffffff) | alphaBits;\n        //             newColor = NumberUtils.intToFloatColor(rgba);\n        //             vertices[i] = newColor;\n        //          }\n        //       }\n        //    }\n        // };\n        this.setColors = (r, g, b, a) => {\n            const intBits = (255 << 24) | ((255 * b) << 16) | ((255 * g) << 8) | (255 * r);\n            const value = NumberUtils_1.NumberUtil.intToFloatColor(intBits);\n            for (let j = 0, length = this.pageVertices.length; j < length; j++) {\n                const vertices = this.pageVertices[j];\n                for (let i = 2, n = this.idx[j]; i < n; i += 5)\n                    vertices[i] = value;\n            }\n        };\n        /** Returns the color used for subsequently added text. Modifying the color affects text subsequently added to the cache, but\n         * does not affect existing text currently in the cache. */\n        this.getColor = () => {\n            return this.color;\n        };\n        /** A convenience method for setting the cache color. The color can also be set by modifying {@link #getColor()}. */\n        this.setColor = (r, g, b, a) => {\n            this.color.set(r, g, b, a);\n        };\n        /** Removes all glyphs in the cache. */\n        this.clear = () => {\n            this.x = 0;\n            this.y = 0;\n            Utils_1.Pools.freeAll('GlyphLayout', this.pooledLayouts);\n            this.pooledLayouts.length = 0;\n            this.layouts.length = 0;\n            for (let i = 0, n = this.idx.length; i < n; i++) {\n                if (this.pageGlyphIndices != null)\n                    this.pageGlyphIndices[i].length = 0;\n                this.idx[i] = 0;\n            }\n        };\n        this.requireGlyphs = (layout) => {\n            if (this.pageVertices.length === 1) {\n                // Simple if we just have one page.\n                this.requirePageGlyphs(0, layout.glyphCount);\n            }\n            else {\n                const tempGlyphCount = this.tempGlyphCount;\n                for (let i = 0; i < tempGlyphCount.length; i++) {\n                    tempGlyphCount[i] = 0;\n                }\n                // Determine # of glyphs in each page.\n                for (let i = 0, n = layout.runs.length; i < n; i++) {\n                    const glyphs = layout.runs[i].glyphs;\n                    const glyphItems = glyphs;\n                    for (let ii = 0, nn = glyphs.length; ii < nn; ii++)\n                        tempGlyphCount[glyphItems[ii].page]++;\n                }\n                // Require that many for each page.\n                for (let i = 0, n = tempGlyphCount.length; i < n; i++)\n                    this.requirePageGlyphs(i, tempGlyphCount[i]);\n            }\n        };\n        this.requirePageGlyphs = (page, glyphCount) => {\n            // if (this.pageGlyphIndices != null) {\n            //    if (glyphCount > this.pageGlyphIndices[page].length)\n            //       this.pageGlyphIndices[page].ensureCapacity(glyphCount - this.pageGlyphIndices[page].length);\n            // }\n            const vertexCount = this.idx[page] + glyphCount * 20;\n            const vertices = this.pageVertices[page];\n            if (!vertices) {\n                this.pageVertices[page] = new Array(vertexCount);\n            }\n            else if (vertices.length < vertexCount) {\n                const newVertices = new Array(vertexCount);\n                Utils_1.Utils.arrayCopy(vertices, 0, newVertices, 0, this.idx[page]);\n                this.pageVertices[page] = newVertices;\n            }\n        };\n        this.setPageCount = (pageCount) => {\n            const newPageVertices = new Array(pageCount).fill([]);\n            Utils_1.Utils.arrayCopy(this.pageVertices, 0, newPageVertices, 0, this.pageVertices.length);\n            this.pageVertices = [...newPageVertices];\n            const newIdx = new Array(pageCount);\n            Utils_1.Utils.arrayCopy(this.idx, 0, newIdx, 0, this.idx.length);\n            this.idx = newIdx;\n            const newPageGlyphIndices = new Array(pageCount);\n            let pageGlyphIndicesLength = 0;\n            if (this.pageGlyphIndices != null) {\n                pageGlyphIndicesLength = this.pageGlyphIndices.length;\n                Utils_1.Utils.arrayCopy(this.pageGlyphIndices, 0, newPageGlyphIndices, 0, this.pageGlyphIndices.length);\n            }\n            for (let i = pageGlyphIndicesLength; i < pageCount; i++)\n                newPageGlyphIndices[i] = [];\n            this.pageGlyphIndices = newPageGlyphIndices;\n            this.tempGlyphCount = new Array(pageCount);\n        };\n        this.addToCache = (layout, x, y) => {\n            const runCount = layout.runs.length;\n            if (runCount === 0)\n                return;\n            // Check if the number of font pages has changed.\n            if (this.pageVertices.length < this.font.regions.length)\n                this.setPageCount(this.font.regions.length);\n            this.layouts.push(layout);\n            this.requireGlyphs(layout);\n            const colors = layout.colors;\n            let colorsIndex = 0, nextColorGlyphIndex = 0, glyphIndex = 0;\n            let lastColorFloatBits = 0;\n            this.drawingTexts.length = 0;\n            for (let i = 0; i < runCount; i++) {\n                const run = layout.runs[i];\n                const glyphs = run.glyphs;\n                const xAdvances = run.xAdvances;\n                let gx = x + run.x, gy = y + run.y;\n                for (let ii = 0, nn = run.glyphs.length; ii < nn; ii++) {\n                    if (glyphIndex++ === nextColorGlyphIndex) {\n                        lastColorFloatBits = NumberUtils_1.NumberUtil.intToFloatColor(colors[++colorsIndex]);\n                        nextColorGlyphIndex = ++colorsIndex < colors.length ? colors[colorsIndex] : -1;\n                    }\n                    gx += xAdvances[ii];\n                    this.drawingTexts.push(glyphs[ii].id);\n                    this.addGlyph(glyphs[ii], gx, gy, lastColorFloatBits);\n                }\n            }\n            const whiteIntBits = (255 << 24) | (255 << 16) | (255 << 8) | 255;\n            this.currentTint = NumberUtils_1.NumberUtil.intToFloatColor(whiteIntBits); // Cached glyphs have changed, reset the current tint.\n        };\n        this.addGlyph = (glyph, x, y, color) => {\n            let scaleX = this.font.data.scaleX, scaleY = this.font.data.scaleY;\n            x += glyph.xoffset * scaleX;\n            y += glyph.yoffset * scaleY;\n            let width = glyph.width * scaleX, height = glyph.height * scaleY;\n            let u = glyph.u, u2 = glyph.u2, v = glyph.v, v2 = glyph.v2;\n            if (this.integer) {\n                x = Math.round(x);\n                y = Math.round(y);\n                width = Math.round(width);\n                height = Math.round(height);\n            }\n            let x2 = x + width, y2 = y + height;\n            const page = glyph.page;\n            let idx = this.idx[page];\n            this.idx[page] += 20;\n            if (this.pageGlyphIndices != null)\n                this.pageGlyphIndices[page].push(this.glyphCount++);\n            const vertices = this.pageVertices[page];\n            vertices[idx++] = x;\n            vertices[idx++] = y;\n            vertices[idx++] = color;\n            vertices[idx++] = u;\n            vertices[idx++] = v;\n            vertices[idx++] = x;\n            vertices[idx++] = y2;\n            vertices[idx++] = color;\n            vertices[idx++] = u;\n            vertices[idx++] = v2;\n            vertices[idx++] = x2;\n            vertices[idx++] = y2;\n            vertices[idx++] = color;\n            vertices[idx++] = u2;\n            vertices[idx++] = v2;\n            vertices[idx++] = x2;\n            vertices[idx++] = y;\n            vertices[idx++] = color;\n            vertices[idx++] = u2;\n            vertices[idx] = v;\n        };\n        // public GlyphLayout setText (CharSequence str, float x, float y) {\n        // \tclear();\n        // \treturn addText(str, x, y, 0, str.length(), 0, Align.left, false);\n        // }\n        // public GlyphLayout setText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {\n        // \tclear();\n        // \treturn addText(str, x, y, 0, str.length(), targetWidth, halign, wrap);\n        // }\n        // public GlyphLayout setText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign,\n        // \tboolean wrap) {\n        // \tclear();\n        // \treturn addText(str, x, y, start, end, targetWidth, halign, wrap);\n        // }\n        this.setText = (str, x, y, start, end, targetWidth, halign, wrap, truncate) => {\n            this.clear();\n            return this.addText(str, x, y, start, end, targetWidth, halign, wrap, truncate);\n        };\n        this.setTextToCache = (layout, x, y) => {\n            this.clear();\n            this.addTextToCache(layout, x, y);\n        };\n        // public GlyphLayout addText (CharSequence str, float x, float y) {\n        // \treturn addText(str, x, y, 0, str.length(), 0, Align.left, false, null);\n        // }\n        // public GlyphLayout addText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {\n        // \treturn addText(str, x, y, 0, str.length(), targetWidth, halign, wrap, null);\n        // }\n        // public GlyphLayout addText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign,\n        // \tboolean wrap) {\n        // \treturn addText(str, x, y, start, end, targetWidth, halign, wrap, null);\n        // }\n        this.addText = (str, x, y, start, end, targetWidth, halign, wrap, truncate) => {\n            const layout = Utils_1.Pools.obtain('GlyphLayout');\n            this.pooledLayouts.push(layout);\n            layout.setText(this.font, str, start, end, this.color, targetWidth, halign, wrap, truncate);\n            this.addTextToCache(layout, x, y);\n            return layout;\n        };\n        this.addTextToCache = (layout, x, y) => {\n            this.addToCache(layout, x, y + this.font.data.ascent);\n        };\n        /** Returns the x position of the cached string, relative to the position when the string was cached. */\n        this.getX = () => {\n            return this.x;\n        };\n        /** Returns the y position of the cached string, relative to the position when the string was cached. */\n        this.getY = () => {\n            return this.y;\n        };\n        this.getFont = () => {\n            return this.font;\n        };\n        this.setUseIntegerPositions = (use) => {\n            this.integer = use;\n        };\n        /** @return whether this font uses integer positions for drawing. */\n        this.usesIntegerPositions = () => {\n            return this.integer;\n        };\n        this.getVertices = (page) => {\n            return this.pageVertices[page];\n        };\n        this.getVertexCount = (page) => {\n            return this.idx[page];\n        };\n        this.getLayouts = () => {\n            return this.layouts;\n        };\n        this.font = font;\n        this.integer = integer;\n        const pageCount = font.regions.length;\n        if (pageCount === 0)\n            console.log('The specified font must contain at least one texture page.');\n        this.pageVertices = new Array(pageCount).fill([]);\n        this.idx = new Array(pageCount);\n        if (pageCount > 1) {\n            // Contains the indices of the glyph in the cache as they are added.\n            this.pageGlyphIndices = new Array(pageCount);\n            for (let i = 0, n = this.pageGlyphIndices.length; i < n; i++)\n                this.pageGlyphIndices[i] = [];\n        }\n        this.tempGlyphCount = new Array(pageCount);\n        Utils_1.Pools.get('GlyphLayout', () => new GlyphLayout_1.GlyphLayout(font, '', 0, 0, Utils_1.Color.WHITE, 0, Utils_1.Align.left, false));\n    }\n    draw(batch) {\n        const regions = this.font.getRegions();\n        for (let i = 0; i < this.pageVertices.length; i++) {\n            if (this.idx[i] > 0) {\n                const vertices = this.pageVertices[i];\n                for (let j = 0; j < this.idx[i] / 20; j++) {\n                    const offset = 20 * j;\n                    const region = regions.find(item => { var _a; return item.id === ((_a = this.drawingTexts) === null || _a === void 0 ? void 0 : _a[j]); });\n                    if (region) {\n                        region.draw(batch, vertices[0 + offset], vertices[1 + offset], vertices[10 + offset] - vertices[0 + offset], vertices[11 + offset] - vertices[1 + offset]);\n                    }\n                }\n            }\n        }\n    }\n}\nexports.BitmapFontCache = BitmapFontCache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}