{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitmapFontData = void 0;\n\nconst Glyph_1 = require(\"./Glyph\");\n\nconst Texture_1 = require(\"./Texture\");\n\nconst TextureRegion_1 = require(\"./TextureRegion\");\n\nfunction concatAndResolveUrl(url, concat) {\n  let url1 = url.split('/');\n  let url2 = concat.split('/');\n  let url3 = [];\n\n  for (let i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (let i = 0, l = url2.length; i < l; i++) {\n    if (url2[i] === '..') {\n      url3.pop();\n    } else if (url2[i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nconst CHARACTER_MAX_VALUE = 65535;\n\nclass BitmapFontData {\n  /** Creates an empty BitmapFontData for configuration before calling {@link #load(FileHandle, boolean)}, to subclass, or to\n   * populate yourself, e.g. using stb-truetype or FreeType. */\n  constructor(fontFile, flip) {\n    /** The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of\n     * the first line, the cap height can be used to get the location of the baseline. */\n    this.capHeight = 1;\n    /** Multiplier for the line height of blank lines. down * blankLineHeight is used as the distance to move down for a blank\n     * line. */\n\n    this.blankLineScale = 1;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.glyphs = {};\n    /** The x-height, which is the distance from the top of most lowercase characters to the baseline. */\n\n    this.xHeight = 1;\n    this.xChars = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z'];\n    this.capChars = ['M', 'N', 'B', 'D', 'C', 'E', 'F', 'K', 'A', 'G', 'H', 'I', 'J', 'L', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\n    this.loadFont = gl => __awaiter(this, void 0, void 0, function* () {\n      if (this.imagePaths != null) return;\n      let i = 0;\n      let fileContent;\n      const res = yield fetch(this.fontFile);\n      fileContent = yield res.text();\n      const lines = fileContent.split('\\n').map(s => s.trim());\n\n      try {\n        let line = lines[i];\n        if (typeof line !== 'string') throw new Error('File is empty.');\n        line = line.substring(line.indexOf('padding=') + 8);\n        const padding = line.substring(0, line.indexOf(' ')).split(',', 4);\n        if (padding.length !== 4) throw new Error('Invalid padding.');\n        this.padTop = parseInt(padding[0]);\n        this.padRight = parseInt(padding[1]);\n        this.padBottom = parseInt(padding[2]);\n        this.padLeft = parseInt(padding[3]);\n        const padY = this.padTop + this.padBottom;\n        i++;\n        line = lines[i];\n        if (typeof line !== 'string') throw new Error('Missing common header.');\n        const common = line.split(' ', 9); // At most we want the 6th element; i.e. \"page=N\"\n        // At least lineHeight and base are required.\n\n        if (common.length < 3) throw new Error('Invalid common header.');\n        if (!common[1].startsWith('lineHeight=')) throw new Error('Missing: lineHeight');\n        this.lineHeight = parseInt(common[1].substring(11));\n        if (!common[2].startsWith('base=')) throw new Error('Missing: base');\n        const baseLine = parseInt(common[2].substring(5));\n        let pageCount = 1;\n\n        if (common.length >= 6 && common[5] != null && common[5].startsWith('pages=')) {\n          try {\n            pageCount = Math.max(1, parseInt(common[5].substring(6)));\n          } catch (_a) {// Use one page.\n          }\n        }\n\n        this.imagePaths = new Array(pageCount);\n        const imagePaths = []; // Read each page definition.\n\n        for (let p = 0; p < pageCount; p++) {\n          // Read each \"page\" info line.\n          i++;\n          line = lines[i];\n          if (typeof line !== 'string') throw new Error('Missing additional page definitions.'); // Expect ID to mean \"index\".\n\n          const idMatches = line.match(new RegExp('.*id=(\\\\d+)'));\n\n          if (idMatches && idMatches.length > 1) {\n            const id = idMatches[1];\n\n            try {\n              const pageID = parseInt(id);\n              if (pageID !== p) throw new Error('Page IDs must be indices starting at 0: ' + id);\n            } catch (_b) {}\n          }\n\n          const fileMatches = line.match(new RegExp('.*file=\"?([^\"]+)\"?'));\n          if (!fileMatches || fileMatches.length <= 1) throw new Error('Missing: file');\n          const fileName = fileMatches[1];\n          imagePaths[p] = fileName; // this.imagePaths[p] = fontFile.parent().child(fileName).path().replaceAll(\"\\\\\\\\\", \"/\");\n        }\n\n        this.descent = 0;\n\n        while (true) {\n          i++;\n          line = lines[i];\n          if (!line) break; // EOF\n\n          if (line.startsWith('kernings ')) break; // Starting kernings block.\n\n          if (line.startsWith('metrics ')) break; // Starting metrics block.\n\n          if (!line.startsWith('char ')) continue;\n          const glyph = new Glyph_1.Glyph();\n          const tokens = new StringTokenizer(line, '=');\n          tokens.nextToken();\n          tokens.nextToken();\n          const ch = parseInt(tokens.nextToken());\n          if (ch > 0 && ch > CHARACTER_MAX_VALUE) continue;\n          glyph.id = ch + '';\n          tokens.nextToken();\n          glyph.srcX = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          glyph.srcY = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          glyph.width = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          glyph.height = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          glyph.xoffset = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          if (this.flipped) glyph.yoffset = parseInt(tokens.nextToken());else glyph.yoffset = -(glyph.height + parseInt(tokens.nextToken()));\n          tokens.nextToken();\n          glyph.xadvance = parseInt(tokens.nextToken()); // Check for page safely, it could be omitted or invalid.\n\n          if (tokens.hasMoreTokens()) tokens.nextToken();\n\n          if (tokens.hasMoreTokens()) {\n            try {\n              glyph.page = parseInt(tokens.nextToken());\n            } catch (_c) {}\n          }\n\n          if (glyph.width > 0 && glyph.height > 0) this.descent = Math.min(baseLine + glyph.yoffset, this.descent);\n\n          if (ch <= 0) {\n            this.missingGlyph = glyph;\n          } else if (ch <= CHARACTER_MAX_VALUE) {\n            this.setGlyph(ch, glyph);\n          }\n        }\n\n        this.descent += this.padBottom;\n\n        while (true) {\n          i++;\n          line = lines[i];\n          if (typeof line !== 'string') break;\n          if (!line.startsWith('kerning ')) break;\n          const tokens = new StringTokenizer(line, '=');\n          tokens.nextToken();\n          tokens.nextToken();\n          let first = parseInt(tokens.nextToken());\n          tokens.nextToken();\n          let second = parseInt(tokens.nextToken());\n          if (first < 0 || first > CHARACTER_MAX_VALUE || second < 0 || second > CHARACTER_MAX_VALUE) continue;\n          const glyph = this.getGlyph(first + '');\n          tokens.nextToken();\n          const amount = parseInt(tokens.nextToken());\n\n          if (glyph) {\n            // Kernings may exist for glyph pairs not contained in the font.\n            glyph.setKerning(second, amount);\n          }\n        }\n\n        let hasMetricsOverride = false;\n        let overrideAscent = 0;\n        let overrideDescent = 0;\n        let overrideDown = 0;\n        let overrideCapHeight = 0;\n        let overrideLineHeight = 0;\n        let overrideSpaceXAdvance = 0;\n        let overrideXHeight = 0; // Metrics override\n\n        if (line != null && line.startsWith('metrics ')) {\n          hasMetricsOverride = true;\n          const tokens = new StringTokenizer(line, '=');\n          tokens.nextToken();\n          tokens.nextToken();\n          overrideAscent = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideDescent = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideDown = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideCapHeight = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideLineHeight = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideSpaceXAdvance = parseFloat(tokens.nextToken());\n          tokens.nextToken();\n          overrideXHeight = parseFloat(tokens.nextToken());\n        }\n\n        let spaceGlyph = this.getGlyph('32');\n\n        if (!spaceGlyph) {\n          spaceGlyph = new Glyph_1.Glyph();\n          spaceGlyph.id = '32';\n          let xadvanceGlyph = this.getGlyph('l');\n          if (!xadvanceGlyph) xadvanceGlyph = this.getFirstGlyph();\n          spaceGlyph.xadvance = xadvanceGlyph.xadvance;\n          this.setGlyph(32, spaceGlyph); // space character ascii code\n        }\n\n        if (spaceGlyph.width === 0) {\n          spaceGlyph.width = this.padLeft + spaceGlyph.xadvance + this.padRight;\n          spaceGlyph.xoffset = -this.padLeft;\n        }\n\n        this.spaceXadvance = spaceGlyph.xadvance;\n        let xGlyph;\n\n        for (let i = 0; i < this.xChars.length; i++) {\n          xGlyph = this.getGlyph(this.xChars[i]);\n          if (xGlyph) break;\n        }\n\n        if (!xGlyph) xGlyph = this.getFirstGlyph();\n        this.xHeight = xGlyph.height - padY;\n        let capGlyph;\n\n        for (let i = 0; i < this.capChars.length; i++) {\n          capGlyph = this.getGlyph(this.capChars[i]);\n          if (capGlyph) break;\n        }\n\n        if (!capGlyph) {\n          const glyphValues = Object.values(this.glyphs);\n\n          for (let i = 0; i < glyphValues.length; i++) {\n            const page = glyphValues[i];\n            if (!page) continue;\n\n            for (let j = 0; j < page.length; j++) {\n              if (!page[j] || page[j].height === 0 || page[j].width === 0) continue;\n              this.capHeight = Math.max(this.capHeight, page[j].height);\n            }\n          }\n        } else this.capHeight = capGlyph.height;\n\n        this.capHeight -= padY;\n        this.ascent = baseLine - this.capHeight;\n        this.down = -this.lineHeight;\n\n        if (this.flipped) {\n          this.ascent = -this.ascent;\n          this.down = -this.down;\n        }\n\n        if (hasMetricsOverride) {\n          this.ascent = overrideAscent;\n          this.descent = overrideDescent;\n          this.down = overrideDown;\n          this.capHeight = overrideCapHeight;\n          this.lineHeight = overrideLineHeight;\n          this.spaceXadvance = overrideSpaceXAdvance;\n          this.xHeight = overrideXHeight;\n        } // Generate texture regions\n\n\n        const regionsData = [];\n        const glyphValues = Object.values(this.glyphs);\n\n        for (let i = 0; i < glyphValues.length; i++) {\n          const values = Object.values(glyphValues[i]);\n\n          for (let j = 0; j < values.length; j++) {\n            const region = {\n              id: values[j].id,\n              left: values[j].srcX,\n              top: values[j].srcY,\n              width: values[j].width,\n              height: values[j].height,\n              xoffset: values[j].xoffset,\n              yoffset: values[j].yoffset,\n              xadvance: values[j].xadvance,\n              page: imagePaths[values[j].page],\n              pageId: values[j].page\n            };\n            regionsData.push(region);\n          }\n        }\n\n        const pages = [];\n\n        for (let i = 0; i < pageCount; i++) {\n          const texture = yield Texture_1.Texture.load(gl, concatAndResolveUrl(this.fontFile, `../${imagePaths[i]}`));\n          const invTexWidth = 1 / texture.width;\n          const invTexHeight = 1 / texture.height;\n          pages.push({\n            texture,\n            invTexWidth,\n            invTexHeight\n          });\n        }\n\n        this.regions = [];\n\n        for (let regionData of regionsData) {\n          const left = regionData.left;\n          const top = regionData.top;\n          const width = regionData.width;\n          const height = regionData.height;\n          const {\n            texture,\n            invTexWidth,\n            invTexHeight\n          } = pages[regionData.pageId];\n          const region = new TextureRegion_1.TextureRegion(texture, left, top, width, height, regionData, invTexWidth, invTexHeight);\n          region.originalWidth = width;\n          region.originalHeight = height;\n          region.offsetX = 0;\n          region.offsetY = 0;\n          this.regions.push(region);\n        }\n      } catch (ex) {\n        console.error(ex);\n      }\n    });\n\n    this.setGlyphRegion = (glyph, region) => {\n      const texture = region.texture;\n      const invTexWidth = 1 / texture.width;\n      const invTexHeight = 1 / texture.height;\n      let offsetX = 0,\n          offsetY = 0;\n      const u = region.u;\n      const v = region.v;\n      const regionWidth = region.originalWidth;\n      const regionHeight = region.originalHeight; // if (region instanceof AtlasRegion) {\n      //    // Compensate for whitespace stripped from left and top edges.\n      //    AtlasRegion atlasRegion = (AtlasRegion)region;\n      //    offsetX = atlasRegion.offsetX;\n      //    offsetY = atlasRegion.originalHeight - atlasRegion.packedHeight - atlasRegion.offsetY;\n      // }\n\n      let x = glyph.srcX;\n      let x2 = glyph.srcX + glyph.width;\n      let y = glyph.srcY;\n      let y2 = glyph.srcY + glyph.height; // Shift glyph for left and top edge stripped whitespace. Clip glyph for right and bottom edge stripped whitespace.\n      // Note if the font region has padding, whitespace stripping must not be used.\n\n      if (offsetX > 0) {\n        x -= offsetX;\n\n        if (x < 0) {\n          glyph.width += x;\n          glyph.xoffset -= x;\n          x = 0;\n        }\n\n        x2 -= offsetX;\n\n        if (x2 > regionWidth) {\n          glyph.width -= x2 - regionWidth;\n          x2 = regionWidth;\n        }\n      }\n\n      if (offsetY > 0) {\n        y -= offsetY;\n\n        if (y < 0) {\n          glyph.height += y;\n          if (glyph.height < 0) glyph.height = 0;\n          y = 0;\n        }\n\n        y2 -= offsetY;\n\n        if (y2 > regionHeight) {\n          const amount = y2 - regionHeight;\n          glyph.height -= amount;\n          glyph.yoffset += amount;\n          y2 = regionHeight;\n        }\n      }\n\n      glyph.u = u + x * invTexWidth;\n      glyph.u2 = u + x2 * invTexWidth;\n\n      if (this.flipped) {\n        glyph.v = v + y * invTexHeight;\n        glyph.v2 = v + y2 * invTexHeight;\n      } else {\n        glyph.v2 = v + y * invTexHeight;\n        glyph.v = v + y2 * invTexHeight;\n      }\n    };\n    /** Sets the line height, which is the distance from one line of text to the next. */\n\n\n    this.setLineHeight = height => {\n      this.lineHeight = height * this.scaleY;\n      this.down = this.flipped ? this.lineHeight : -this.lineHeight;\n    };\n\n    this.setGlyph = (ch, glyph) => {\n      let page = this.glyphs[ch / Glyph_1.PAGE_SIZE];\n\n      if (!page) {\n        page = new Array(Glyph_1.PAGE_SIZE);\n        this.glyphs[ch / Glyph_1.PAGE_SIZE] = page; // this.glyphs[ch / PAGE_SIZE] = page = new Glyph[PAGE_SIZE];\n      }\n\n      page[ch & Glyph_1.PAGE_SIZE - 1] = glyph;\n    };\n\n    this.getFirstGlyph = () => {\n      const glyphValues = Object.values(this.glyphs);\n\n      for (let i = 0; i < glyphValues.length; i++) {\n        const page = glyphValues[i];\n        if (!page) continue;\n\n        for (let j = 0; j < page.length; j++) {\n          const glyph = page[j];\n          if (!glyph || glyph.height === 0 || glyph.width === 0) continue;\n          return glyph;\n        }\n      }\n    };\n    /** Returns true if the font has the glyph, or if the font has a {@link #missingGlyph}. */\n\n\n    this.hasGlyph = ch => {\n      if (this.missingGlyph) return true;\n      return this.getGlyph(ch) != null;\n    };\n    /** Returns the glyph for the specified character, or null if no such glyph exists. Note that\n     * {@link #getGlyphs(GlyphRun, CharSequence, int, int, Glyph)} should be be used to shape a string of characters into a list\n     * of glyphs. */\n\n\n    this.getGlyph = ch => {\n      const page = this.glyphs[ch.charCodeAt(0) / Glyph_1.PAGE_SIZE];\n      if (page != null) return page[ch.charCodeAt(0) & Glyph_1.PAGE_SIZE - 1];\n      return undefined;\n    };\n    /** Using the specified string, populates the glyphs and positions of the specified glyph run.\n     * @param str Characters to convert to glyphs. Will not contain newline or color tags. May contain \"[[\" for an escaped left\n     *           square bracket.\n     * @param lastGlyph The glyph immediately before this run, or null if this is run is the first on a line of text. Used tp\n     *           apply kerning between the specified glyph and the first glyph in this run. */\n\n\n    this.getGlyphs = (run, str, start, end, lastGlyph) => {\n      const max = end - start;\n      if (max === 0) return;\n      let markupEnabled = this.markupEnabled;\n      const scaleX = this.scaleX;\n      const glyphs = run.glyphs;\n      const xAdvances = run.xAdvances; // Guess at number of glyphs needed.\n      // glyphs.ensureCapacity(max);\n      // run.xAdvances.ensureCapacity(max + 1);\n\n      do {\n        const ch = str.charAt(start++);\n        if (ch === '\\r') continue; // Ignore.\n\n        let glyph = this.getGlyph(ch);\n\n        if (!glyph) {\n          if (!this.missingGlyph) continue;\n          glyph = this.missingGlyph;\n        }\n\n        glyphs.push(glyph);\n        xAdvances.push(!lastGlyph // First glyph on line, adjust the position so it isn't drawn left of 0.\n        ? glyph.fixedWidth ? 0 : -glyph.xoffset * scaleX - this.padLeft : (lastGlyph.xadvance + lastGlyph.getKerning(ch)) * scaleX);\n        lastGlyph = glyph; // \"[[\" is an escaped left square bracket, skip second character.\n\n        if (markupEnabled && ch === '[' && start < end && str.charAt(start) === '[') start++;\n      } while (start < end);\n\n      if (lastGlyph) {\n        const lastGlyphWidth = lastGlyph.fixedWidth ? lastGlyph.xadvance * scaleX : (lastGlyph.width + lastGlyph.xoffset) * scaleX - this.padRight;\n        xAdvances.push(lastGlyphWidth);\n      }\n    };\n    /** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\n     * (typically) moving toward the beginning of the glyphs array. */\n\n\n    this.getWrapIndex = (glyphs, start) => {\n      let i = start - 1;\n      const glyphsItems = glyphs;\n      let ch = glyphsItems[i].id;\n      if (this.isWhitespace(ch + '')) return i;\n      if (this.isBreakChar(ch + '')) i--;\n\n      for (; i > 0; i--) {\n        ch = glyphsItems[i].id;\n\n        if (this.isWhitespace(ch + '') || this.isBreakChar(ch + '')) {\n          return i + 1;\n        }\n      }\n\n      return 0;\n    };\n\n    this.isBreakChar = c => {\n      if (!this.breakChars) return false;\n      const character = String.fromCharCode(parseInt(c));\n\n      for (let i = 0; i < this.breakChars.length; i++) {\n        if (character === this.breakChars[i]) return true;\n      }\n\n      return false;\n    };\n\n    this.isWhitespace = c => {\n      const character = String.fromCharCode(parseInt(c));\n\n      switch (character) {\n        case '\\n':\n        case '\\r':\n        case '\\t':\n        case ' ':\n          return true;\n\n        default:\n          return false;\n      }\n    };\n    /** Returns the image path for the texture page at the given index (the \"id\" in the BMFont file). */\n\n\n    this.getImagePath = index => {\n      return this.imagePaths[index];\n    };\n\n    this.getImagePaths = () => {\n      return this.imagePaths;\n    };\n    /** Scales the font by the specified amounts on both axes\n     * <p>\n     * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}.\n     * The default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.\n     * @throws IllegalArgumentException if scaleX or scaleY is zero. */\n\n\n    this.setScale = (scaleX, scaleY) => {\n      if (scaleX === 0 || scaleY === 0) return;\n      const x = scaleX / this.scaleX;\n      const y = scaleY / this.scaleY;\n      this.lineHeight *= y;\n      this.spaceXadvance *= x;\n      this.xHeight *= y;\n      this.capHeight *= y;\n      this.ascent *= y;\n      this.descent *= y;\n      this.down *= y;\n      this.padLeft *= x;\n      this.padRight *= x;\n      this.padTop *= y;\n      this.padBottom *= y;\n      this.scaleX = scaleX;\n      this.scaleY = scaleY;\n    };\n    /** Sets the font's scale relative to the current scale.\n     * @see #setScale(float, float)\n     * @throws IllegalArgumentException if the resulting scale is zero. */\n\n\n    this.scale = amount => {\n      this.setScale(this.scaleX + amount, this.scaleY + amount);\n    };\n\n    this.fontFile = fontFile;\n    this.flipped = flip;\n  }\n  /** Scales the font by the specified amount in both directions.\n   * @see #setScale(float, float)\n   * @throws IllegalArgumentException if scaleX or scaleY is zero. */\n\n\n  setXYScale(scaleXY) {\n    this.setScale(scaleXY, scaleXY);\n  }\n\n}\n\nexports.BitmapFontData = BitmapFontData;\n\nclass StringTokenizer {\n  constructor(str, delimitter) {\n    this.strArray = [];\n    this.currentIndex = 0;\n    const strings = str.split(/\\s+/);\n\n    for (let i = 0; i < strings.length; i++) {\n      const st = strings[i];\n      this.strArray.push(...st.split(delimitter));\n    }\n  }\n\n  hasMoreTokens() {\n    return this.currentIndex >= this.strArray.length;\n  }\n\n  nextToken() {\n    return this.strArray[this.currentIndex++];\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","BitmapFontData","Glyph_1","require","Texture_1","TextureRegion_1","concatAndResolveUrl","url","concat","url1","split","url2","url3","i","l","length","pop","push","join","CHARACTER_MAX_VALUE","constructor","fontFile","flip","capHeight","blankLineScale","scaleX","scaleY","glyphs","xHeight","xChars","capChars","loadFont","gl","imagePaths","fileContent","res","fetch","text","lines","map","s","trim","line","Error","substring","indexOf","padding","padTop","parseInt","padRight","padBottom","padLeft","padY","common","startsWith","lineHeight","baseLine","pageCount","Math","max","_a","Array","p","idMatches","match","RegExp","id","pageID","_b","fileMatches","fileName","descent","glyph","Glyph","tokens","StringTokenizer","nextToken","ch","srcX","srcY","width","height","xoffset","flipped","yoffset","xadvance","hasMoreTokens","page","_c","min","missingGlyph","setGlyph","first","second","getGlyph","amount","setKerning","hasMetricsOverride","overrideAscent","overrideDescent","overrideDown","overrideCapHeight","overrideLineHeight","overrideSpaceXAdvance","overrideXHeight","parseFloat","spaceGlyph","xadvanceGlyph","getFirstGlyph","spaceXadvance","xGlyph","capGlyph","glyphValues","values","j","ascent","down","regionsData","region","left","top","pageId","pages","texture","Texture","load","invTexWidth","invTexHeight","regions","regionData","TextureRegion","originalWidth","originalHeight","offsetX","offsetY","ex","console","error","setGlyphRegion","u","v","regionWidth","regionHeight","x","x2","y","y2","u2","v2","setLineHeight","PAGE_SIZE","hasGlyph","charCodeAt","undefined","getGlyphs","run","str","start","end","lastGlyph","markupEnabled","xAdvances","charAt","fixedWidth","getKerning","lastGlyphWidth","getWrapIndex","glyphsItems","isWhitespace","isBreakChar","c","breakChars","character","String","fromCharCode","getImagePath","index","getImagePaths","setScale","scale","setXYScale","scaleXY","delimitter","strArray","currentIndex","strings","st"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/BitmapFontData.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitmapFontData = void 0;\nconst Glyph_1 = require(\"./Glyph\");\nconst Texture_1 = require(\"./Texture\");\nconst TextureRegion_1 = require(\"./TextureRegion\");\nfunction concatAndResolveUrl(url, concat) {\n    let url1 = url.split('/');\n    let url2 = concat.split('/');\n    let url3 = [];\n    for (let i = 0, l = url1.length; i < l; i++) {\n        if (url1[i] === '..') {\n            url3.pop();\n        }\n        else if (url1[i] === '.') {\n            continue;\n        }\n        else {\n            url3.push(url1[i]);\n        }\n    }\n    for (let i = 0, l = url2.length; i < l; i++) {\n        if (url2[i] === '..') {\n            url3.pop();\n        }\n        else if (url2[i] === '.') {\n            continue;\n        }\n        else {\n            url3.push(url2[i]);\n        }\n    }\n    return url3.join('/');\n}\nconst CHARACTER_MAX_VALUE = 65535;\nclass BitmapFontData {\n    /** Creates an empty BitmapFontData for configuration before calling {@link #load(FileHandle, boolean)}, to subclass, or to\n     * populate yourself, e.g. using stb-truetype or FreeType. */\n    constructor(fontFile, flip) {\n        /** The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of\n         * the first line, the cap height can be used to get the location of the baseline. */\n        this.capHeight = 1;\n        /** Multiplier for the line height of blank lines. down * blankLineHeight is used as the distance to move down for a blank\n         * line. */\n        this.blankLineScale = 1;\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.glyphs = {};\n        /** The x-height, which is the distance from the top of most lowercase characters to the baseline. */\n        this.xHeight = 1;\n        this.xChars = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z'];\n        this.capChars = [\n            'M',\n            'N',\n            'B',\n            'D',\n            'C',\n            'E',\n            'F',\n            'K',\n            'A',\n            'G',\n            'H',\n            'I',\n            'J',\n            'L',\n            'O',\n            'P',\n            'Q',\n            'R',\n            'S',\n            'T',\n            'U',\n            'V',\n            'W',\n            'X',\n            'Y',\n            'Z'\n        ];\n        this.loadFont = (gl) => __awaiter(this, void 0, void 0, function* () {\n            if (this.imagePaths != null)\n                return;\n            let i = 0;\n            let fileContent;\n            const res = yield fetch(this.fontFile);\n            fileContent = yield res.text();\n            const lines = fileContent.split('\\n').map((s) => s.trim());\n            try {\n                let line = lines[i];\n                if (typeof line !== 'string')\n                    throw new Error('File is empty.');\n                line = line.substring(line.indexOf('padding=') + 8);\n                const padding = line.substring(0, line.indexOf(' ')).split(',', 4);\n                if (padding.length !== 4)\n                    throw new Error('Invalid padding.');\n                this.padTop = parseInt(padding[0]);\n                this.padRight = parseInt(padding[1]);\n                this.padBottom = parseInt(padding[2]);\n                this.padLeft = parseInt(padding[3]);\n                const padY = this.padTop + this.padBottom;\n                i++;\n                line = lines[i];\n                if (typeof line !== 'string')\n                    throw new Error('Missing common header.');\n                const common = line.split(' ', 9); // At most we want the 6th element; i.e. \"page=N\"\n                // At least lineHeight and base are required.\n                if (common.length < 3)\n                    throw new Error('Invalid common header.');\n                if (!common[1].startsWith('lineHeight='))\n                    throw new Error('Missing: lineHeight');\n                this.lineHeight = parseInt(common[1].substring(11));\n                if (!common[2].startsWith('base='))\n                    throw new Error('Missing: base');\n                const baseLine = parseInt(common[2].substring(5));\n                let pageCount = 1;\n                if (common.length >= 6 && common[5] != null && common[5].startsWith('pages=')) {\n                    try {\n                        pageCount = Math.max(1, parseInt(common[5].substring(6)));\n                    }\n                    catch (_a) {\n                        // Use one page.\n                    }\n                }\n                this.imagePaths = new Array(pageCount);\n                const imagePaths = [];\n                // Read each page definition.\n                for (let p = 0; p < pageCount; p++) {\n                    // Read each \"page\" info line.\n                    i++;\n                    line = lines[i];\n                    if (typeof line !== 'string')\n                        throw new Error('Missing additional page definitions.');\n                    // Expect ID to mean \"index\".\n                    const idMatches = line.match(new RegExp('.*id=(\\\\d+)'));\n                    if (idMatches && idMatches.length > 1) {\n                        const id = idMatches[1];\n                        try {\n                            const pageID = parseInt(id);\n                            if (pageID !== p)\n                                throw new Error('Page IDs must be indices starting at 0: ' + id);\n                        }\n                        catch (_b) { }\n                    }\n                    const fileMatches = line.match(new RegExp('.*file=\"?([^\"]+)\"?'));\n                    if (!fileMatches || fileMatches.length <= 1)\n                        throw new Error('Missing: file');\n                    const fileName = fileMatches[1];\n                    imagePaths[p] = fileName;\n                    // this.imagePaths[p] = fontFile.parent().child(fileName).path().replaceAll(\"\\\\\\\\\", \"/\");\n                }\n                this.descent = 0;\n                while (true) {\n                    i++;\n                    line = lines[i];\n                    if (!line)\n                        break; // EOF\n                    if (line.startsWith('kernings '))\n                        break; // Starting kernings block.\n                    if (line.startsWith('metrics '))\n                        break; // Starting metrics block.\n                    if (!line.startsWith('char '))\n                        continue;\n                    const glyph = new Glyph_1.Glyph();\n                    const tokens = new StringTokenizer(line, '=');\n                    tokens.nextToken();\n                    tokens.nextToken();\n                    const ch = parseInt(tokens.nextToken());\n                    if (ch > 0 && ch > CHARACTER_MAX_VALUE)\n                        continue;\n                    glyph.id = ch + '';\n                    tokens.nextToken();\n                    glyph.srcX = parseInt(tokens.nextToken());\n                    tokens.nextToken();\n                    glyph.srcY = parseInt(tokens.nextToken());\n                    tokens.nextToken();\n                    glyph.width = parseInt(tokens.nextToken());\n                    tokens.nextToken();\n                    glyph.height = parseInt(tokens.nextToken());\n                    tokens.nextToken();\n                    glyph.xoffset = parseInt(tokens.nextToken());\n                    tokens.nextToken();\n                    if (this.flipped)\n                        glyph.yoffset = parseInt(tokens.nextToken());\n                    else\n                        glyph.yoffset = -(glyph.height + parseInt(tokens.nextToken()));\n                    tokens.nextToken();\n                    glyph.xadvance = parseInt(tokens.nextToken());\n                    // Check for page safely, it could be omitted or invalid.\n                    if (tokens.hasMoreTokens())\n                        tokens.nextToken();\n                    if (tokens.hasMoreTokens()) {\n                        try {\n                            glyph.page = parseInt(tokens.nextToken());\n                        }\n                        catch (_c) { }\n                    }\n                    if (glyph.width > 0 && glyph.height > 0)\n                        this.descent = Math.min(baseLine + glyph.yoffset, this.descent);\n                    if (ch <= 0) {\n                        this.missingGlyph = glyph;\n                    }\n                    else if (ch <= CHARACTER_MAX_VALUE) {\n                        this.setGlyph(ch, glyph);\n                    }\n                }\n                this.descent += this.padBottom;\n                while (true) {\n                    i++;\n                    line = lines[i];\n                    if (typeof line !== 'string')\n                        break;\n                    if (!line.startsWith('kerning '))\n                        break;\n                    const tokens = new StringTokenizer(line, '=');\n                    tokens.nextToken();\n                    tokens.nextToken();\n                    let first = parseInt(tokens.nextToken());\n                    tokens.nextToken();\n                    let second = parseInt(tokens.nextToken());\n                    if (first < 0 || first > CHARACTER_MAX_VALUE || second < 0 || second > CHARACTER_MAX_VALUE)\n                        continue;\n                    const glyph = this.getGlyph(first + '');\n                    tokens.nextToken();\n                    const amount = parseInt(tokens.nextToken());\n                    if (glyph) {\n                        // Kernings may exist for glyph pairs not contained in the font.\n                        glyph.setKerning(second, amount);\n                    }\n                }\n                let hasMetricsOverride = false;\n                let overrideAscent = 0;\n                let overrideDescent = 0;\n                let overrideDown = 0;\n                let overrideCapHeight = 0;\n                let overrideLineHeight = 0;\n                let overrideSpaceXAdvance = 0;\n                let overrideXHeight = 0;\n                // Metrics override\n                if (line != null && line.startsWith('metrics ')) {\n                    hasMetricsOverride = true;\n                    const tokens = new StringTokenizer(line, '=');\n                    tokens.nextToken();\n                    tokens.nextToken();\n                    overrideAscent = parseFloat(tokens.nextToken());\n                    tokens.nextToken();\n                    overrideDescent = parseFloat(tokens.nextToken());\n                    tokens.nextToken();\n                    overrideDown = parseFloat(tokens.nextToken());\n                    tokens.nextToken();\n                    overrideCapHeight = parseFloat(tokens.nextToken());\n                    tokens.nextToken();\n                    overrideLineHeight = parseFloat(tokens.nextToken());\n                    tokens.nextToken();\n                    overrideSpaceXAdvance = parseFloat(tokens.nextToken());\n                    tokens.nextToken();\n                    overrideXHeight = parseFloat(tokens.nextToken());\n                }\n                let spaceGlyph = this.getGlyph('32');\n                if (!spaceGlyph) {\n                    spaceGlyph = new Glyph_1.Glyph();\n                    spaceGlyph.id = '32';\n                    let xadvanceGlyph = this.getGlyph('l');\n                    if (!xadvanceGlyph)\n                        xadvanceGlyph = this.getFirstGlyph();\n                    spaceGlyph.xadvance = xadvanceGlyph.xadvance;\n                    this.setGlyph(32, spaceGlyph); // space character ascii code\n                }\n                if (spaceGlyph.width === 0) {\n                    spaceGlyph.width = this.padLeft + spaceGlyph.xadvance + this.padRight;\n                    spaceGlyph.xoffset = -this.padLeft;\n                }\n                this.spaceXadvance = spaceGlyph.xadvance;\n                let xGlyph;\n                for (let i = 0; i < this.xChars.length; i++) {\n                    xGlyph = this.getGlyph(this.xChars[i]);\n                    if (xGlyph)\n                        break;\n                }\n                if (!xGlyph)\n                    xGlyph = this.getFirstGlyph();\n                this.xHeight = xGlyph.height - padY;\n                let capGlyph;\n                for (let i = 0; i < this.capChars.length; i++) {\n                    capGlyph = this.getGlyph(this.capChars[i]);\n                    if (capGlyph)\n                        break;\n                }\n                if (!capGlyph) {\n                    const glyphValues = Object.values(this.glyphs);\n                    for (let i = 0; i < glyphValues.length; i++) {\n                        const page = glyphValues[i];\n                        if (!page)\n                            continue;\n                        for (let j = 0; j < page.length; j++) {\n                            if (!page[j] || page[j].height === 0 || page[j].width === 0)\n                                continue;\n                            this.capHeight = Math.max(this.capHeight, page[j].height);\n                        }\n                    }\n                }\n                else\n                    this.capHeight = capGlyph.height;\n                this.capHeight -= padY;\n                this.ascent = baseLine - this.capHeight;\n                this.down = -this.lineHeight;\n                if (this.flipped) {\n                    this.ascent = -this.ascent;\n                    this.down = -this.down;\n                }\n                if (hasMetricsOverride) {\n                    this.ascent = overrideAscent;\n                    this.descent = overrideDescent;\n                    this.down = overrideDown;\n                    this.capHeight = overrideCapHeight;\n                    this.lineHeight = overrideLineHeight;\n                    this.spaceXadvance = overrideSpaceXAdvance;\n                    this.xHeight = overrideXHeight;\n                }\n                // Generate texture regions\n                const regionsData = [];\n                const glyphValues = Object.values(this.glyphs);\n                for (let i = 0; i < glyphValues.length; i++) {\n                    const values = Object.values(glyphValues[i]);\n                    for (let j = 0; j < values.length; j++) {\n                        const region = {\n                            id: values[j].id,\n                            left: values[j].srcX,\n                            top: values[j].srcY,\n                            width: values[j].width,\n                            height: values[j].height,\n                            xoffset: values[j].xoffset,\n                            yoffset: values[j].yoffset,\n                            xadvance: values[j].xadvance,\n                            page: imagePaths[values[j].page],\n                            pageId: values[j].page\n                        };\n                        regionsData.push(region);\n                    }\n                }\n                const pages = [];\n                for (let i = 0; i < pageCount; i++) {\n                    const texture = yield Texture_1.Texture.load(gl, concatAndResolveUrl(this.fontFile, `../${imagePaths[i]}`));\n                    const invTexWidth = 1 / texture.width;\n                    const invTexHeight = 1 / texture.height;\n                    pages.push({\n                        texture,\n                        invTexWidth,\n                        invTexHeight\n                    });\n                }\n                this.regions = [];\n                for (let regionData of regionsData) {\n                    const left = regionData.left;\n                    const top = regionData.top;\n                    const width = regionData.width;\n                    const height = regionData.height;\n                    const { texture, invTexWidth, invTexHeight } = pages[regionData.pageId];\n                    const region = new TextureRegion_1.TextureRegion(texture, left, top, width, height, regionData, invTexWidth, invTexHeight);\n                    region.originalWidth = width;\n                    region.originalHeight = height;\n                    region.offsetX = 0;\n                    region.offsetY = 0;\n                    this.regions.push(region);\n                }\n            }\n            catch (ex) {\n                console.error(ex);\n            }\n        });\n        this.setGlyphRegion = (glyph, region) => {\n            const texture = region.texture;\n            const invTexWidth = 1 / texture.width;\n            const invTexHeight = 1 / texture.height;\n            let offsetX = 0, offsetY = 0;\n            const u = region.u;\n            const v = region.v;\n            const regionWidth = region.originalWidth;\n            const regionHeight = region.originalHeight;\n            // if (region instanceof AtlasRegion) {\n            //    // Compensate for whitespace stripped from left and top edges.\n            //    AtlasRegion atlasRegion = (AtlasRegion)region;\n            //    offsetX = atlasRegion.offsetX;\n            //    offsetY = atlasRegion.originalHeight - atlasRegion.packedHeight - atlasRegion.offsetY;\n            // }\n            let x = glyph.srcX;\n            let x2 = glyph.srcX + glyph.width;\n            let y = glyph.srcY;\n            let y2 = glyph.srcY + glyph.height;\n            // Shift glyph for left and top edge stripped whitespace. Clip glyph for right and bottom edge stripped whitespace.\n            // Note if the font region has padding, whitespace stripping must not be used.\n            if (offsetX > 0) {\n                x -= offsetX;\n                if (x < 0) {\n                    glyph.width += x;\n                    glyph.xoffset -= x;\n                    x = 0;\n                }\n                x2 -= offsetX;\n                if (x2 > regionWidth) {\n                    glyph.width -= x2 - regionWidth;\n                    x2 = regionWidth;\n                }\n            }\n            if (offsetY > 0) {\n                y -= offsetY;\n                if (y < 0) {\n                    glyph.height += y;\n                    if (glyph.height < 0)\n                        glyph.height = 0;\n                    y = 0;\n                }\n                y2 -= offsetY;\n                if (y2 > regionHeight) {\n                    const amount = y2 - regionHeight;\n                    glyph.height -= amount;\n                    glyph.yoffset += amount;\n                    y2 = regionHeight;\n                }\n            }\n            glyph.u = u + x * invTexWidth;\n            glyph.u2 = u + x2 * invTexWidth;\n            if (this.flipped) {\n                glyph.v = v + y * invTexHeight;\n                glyph.v2 = v + y2 * invTexHeight;\n            }\n            else {\n                glyph.v2 = v + y * invTexHeight;\n                glyph.v = v + y2 * invTexHeight;\n            }\n        };\n        /** Sets the line height, which is the distance from one line of text to the next. */\n        this.setLineHeight = (height) => {\n            this.lineHeight = height * this.scaleY;\n            this.down = this.flipped ? this.lineHeight : -this.lineHeight;\n        };\n        this.setGlyph = (ch, glyph) => {\n            let page = this.glyphs[ch / Glyph_1.PAGE_SIZE];\n            if (!page) {\n                page = new Array(Glyph_1.PAGE_SIZE);\n                this.glyphs[ch / Glyph_1.PAGE_SIZE] = page;\n                // this.glyphs[ch / PAGE_SIZE] = page = new Glyph[PAGE_SIZE];\n            }\n            page[ch & (Glyph_1.PAGE_SIZE - 1)] = glyph;\n        };\n        this.getFirstGlyph = () => {\n            const glyphValues = Object.values(this.glyphs);\n            for (let i = 0; i < glyphValues.length; i++) {\n                const page = glyphValues[i];\n                if (!page)\n                    continue;\n                for (let j = 0; j < page.length; j++) {\n                    const glyph = page[j];\n                    if (!glyph || glyph.height === 0 || glyph.width === 0)\n                        continue;\n                    return glyph;\n                }\n            }\n        };\n        /** Returns true if the font has the glyph, or if the font has a {@link #missingGlyph}. */\n        this.hasGlyph = (ch) => {\n            if (this.missingGlyph)\n                return true;\n            return this.getGlyph(ch) != null;\n        };\n        /** Returns the glyph for the specified character, or null if no such glyph exists. Note that\n         * {@link #getGlyphs(GlyphRun, CharSequence, int, int, Glyph)} should be be used to shape a string of characters into a list\n         * of glyphs. */\n        this.getGlyph = (ch) => {\n            const page = this.glyphs[ch.charCodeAt(0) / Glyph_1.PAGE_SIZE];\n            if (page != null)\n                return page[ch.charCodeAt(0) & (Glyph_1.PAGE_SIZE - 1)];\n            return undefined;\n        };\n        /** Using the specified string, populates the glyphs and positions of the specified glyph run.\n         * @param str Characters to convert to glyphs. Will not contain newline or color tags. May contain \"[[\" for an escaped left\n         *           square bracket.\n         * @param lastGlyph The glyph immediately before this run, or null if this is run is the first on a line of text. Used tp\n         *           apply kerning between the specified glyph and the first glyph in this run. */\n        this.getGlyphs = (run, str, start, end, lastGlyph) => {\n            const max = end - start;\n            if (max === 0)\n                return;\n            let markupEnabled = this.markupEnabled;\n            const scaleX = this.scaleX;\n            const glyphs = run.glyphs;\n            const xAdvances = run.xAdvances;\n            // Guess at number of glyphs needed.\n            // glyphs.ensureCapacity(max);\n            // run.xAdvances.ensureCapacity(max + 1);\n            do {\n                const ch = str.charAt(start++);\n                if (ch === '\\r')\n                    continue; // Ignore.\n                let glyph = this.getGlyph(ch);\n                if (!glyph) {\n                    if (!this.missingGlyph)\n                        continue;\n                    glyph = this.missingGlyph;\n                }\n                glyphs.push(glyph);\n                xAdvances.push(!lastGlyph // First glyph on line, adjust the position so it isn't drawn left of 0.\n                    ? glyph.fixedWidth\n                        ? 0\n                        : -glyph.xoffset * scaleX - this.padLeft\n                    : (lastGlyph.xadvance + lastGlyph.getKerning(ch)) * scaleX);\n                lastGlyph = glyph;\n                // \"[[\" is an escaped left square bracket, skip second character.\n                if (markupEnabled && ch === '[' && start < end && str.charAt(start) === '[')\n                    start++;\n            } while (start < end);\n            if (lastGlyph) {\n                const lastGlyphWidth = lastGlyph.fixedWidth\n                    ? lastGlyph.xadvance * scaleX\n                    : (lastGlyph.width + lastGlyph.xoffset) * scaleX - this.padRight;\n                xAdvances.push(lastGlyphWidth);\n            }\n        };\n        /** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\n         * (typically) moving toward the beginning of the glyphs array. */\n        this.getWrapIndex = (glyphs, start) => {\n            let i = start - 1;\n            const glyphsItems = glyphs;\n            let ch = glyphsItems[i].id;\n            if (this.isWhitespace(ch + ''))\n                return i;\n            if (this.isBreakChar(ch + ''))\n                i--;\n            for (; i > 0; i--) {\n                ch = glyphsItems[i].id;\n                if (this.isWhitespace(ch + '') || this.isBreakChar(ch + '')) {\n                    return i + 1;\n                }\n            }\n            return 0;\n        };\n        this.isBreakChar = (c) => {\n            if (!this.breakChars)\n                return false;\n            const character = String.fromCharCode(parseInt(c));\n            for (let i = 0; i < this.breakChars.length; i++) {\n                if (character === this.breakChars[i])\n                    return true;\n            }\n            return false;\n        };\n        this.isWhitespace = (c) => {\n            const character = String.fromCharCode(parseInt(c));\n            switch (character) {\n                case '\\n':\n                case '\\r':\n                case '\\t':\n                case ' ':\n                    return true;\n                default:\n                    return false;\n            }\n        };\n        /** Returns the image path for the texture page at the given index (the \"id\" in the BMFont file). */\n        this.getImagePath = (index) => {\n            return this.imagePaths[index];\n        };\n        this.getImagePaths = () => {\n            return this.imagePaths;\n        };\n        /** Scales the font by the specified amounts on both axes\n         * <p>\n         * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}.\n         * The default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.\n         * @throws IllegalArgumentException if scaleX or scaleY is zero. */\n        this.setScale = (scaleX, scaleY) => {\n            if (scaleX === 0 || scaleY === 0)\n                return;\n            const x = scaleX / this.scaleX;\n            const y = scaleY / this.scaleY;\n            this.lineHeight *= y;\n            this.spaceXadvance *= x;\n            this.xHeight *= y;\n            this.capHeight *= y;\n            this.ascent *= y;\n            this.descent *= y;\n            this.down *= y;\n            this.padLeft *= x;\n            this.padRight *= x;\n            this.padTop *= y;\n            this.padBottom *= y;\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n        };\n        /** Sets the font's scale relative to the current scale.\n         * @see #setScale(float, float)\n         * @throws IllegalArgumentException if the resulting scale is zero. */\n        this.scale = (amount) => {\n            this.setScale(this.scaleX + amount, this.scaleY + amount);\n        };\n        this.fontFile = fontFile;\n        this.flipped = flip;\n    }\n    /** Scales the font by the specified amount in both directions.\n     * @see #setScale(float, float)\n     * @throws IllegalArgumentException if scaleX or scaleY is zero. */\n    setXYScale(scaleXY) {\n        this.setScale(scaleXY, scaleXY);\n    }\n}\nexports.BitmapFontData = BitmapFontData;\nclass StringTokenizer {\n    constructor(str, delimitter) {\n        this.strArray = [];\n        this.currentIndex = 0;\n        const strings = str.split(/\\s+/);\n        for (let i = 0; i < strings.length; i++) {\n            const st = strings[i];\n            this.strArray.push(...st.split(delimitter));\n        }\n    }\n    hasMoreTokens() {\n        return this.currentIndex >= this.strArray.length;\n    }\n    nextToken() {\n        return this.strArray[this.currentIndex++];\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}