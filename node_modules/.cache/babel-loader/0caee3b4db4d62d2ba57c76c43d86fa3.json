{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitmapFont = void 0;\n\nconst BitmapFontCache_1 = require(\"./BitmapFontCache\");\n\nconst BitmapFontData_1 = require(\"./BitmapFontData\");\n\nconst Utils_1 = require(\"./Utils\");\n\nclass BitmapFont {\n  /** Constructs a new BitmapFont from the given {@link BitmapFontData} and array of {@link TextureRegion}. If the TextureRegion\n   * is null or empty, the image path(s) will be read from the BitmapFontData. The dispose() method will not dispose the texture\n   * of the region(s) if the regions array is != null and not empty.\n   * @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */\n  constructor(data, regions, integer) {\n    var _this = this;\n\n    this.load = data => {\n      const glyphValues = Object.values(data.glyphs);\n\n      for (let i = 0; i < glyphValues.length; i++) {\n        const page = glyphValues[i];\n        if (!page) continue;\n\n        for (let j = 0; j < page.length; j++) {\n          const glyph = page[j];\n\n          if (glyph) {\n            data.setGlyphRegion(glyph, this.regions[glyph.page]);\n          }\n        }\n      }\n\n      if (data.missingGlyph != null) data.setGlyphRegion(data.missingGlyph, this.regions[data.missingGlyph.page]);\n    };\n    /** Draws text at the specified position.\n     * @see BitmapFontCache#addText(CharSequence, float, float, int, int, float, int, boolean, String) */\n\n\n    this.draw = function (batch, str, x, y, targetWidth) {\n      let halign = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Utils_1.Align.left;\n      let wrap = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n      let start = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n      let end = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : str.length;\n      let truncate = arguments.length > 9 ? arguments[9] : undefined;\n\n      _this.cache.clear();\n\n      _this.cache.addText(str, x, y, start, end, targetWidth, halign, wrap, truncate);\n\n      _this.cache.draw(batch);\n    };\n    /** Returns the color of text drawn with this font. */\n\n\n    this.getColor = () => {\n      return this.cache.getColor();\n    };\n    /** A convenience method for setting the font color. The color can also be set by modifying {@link #getColor()}. */\n    // setColor = (r: number, g: number, b: number, a: number) => {\n    //    this.cache.getColor().set(r, g, b, a);\n    // };\n\n\n    this.getScaleX = () => {\n      return this.data.scaleX;\n    };\n\n    this.getScaleY = () => {\n      return this.data.scaleY;\n    };\n    /** Returns the array of TextureRegions that represents each texture page of glyphs.\n     * @return the array of texture regions; modifying it may produce undesirable results */\n\n\n    this.getRegions = () => {\n      return this.regions;\n    };\n    /** Returns the texture page at the given index.\n     * @return the texture page at the given index */\n\n\n    this.getRegion = index => {\n      return this.regions[index];\n    };\n    /** Returns the line height, which is the distance from one line of text to the next. */\n\n\n    this.getLineHeight = () => {\n      return this.data.lineHeight;\n    };\n    /** Returns the x-advance of the space character. */\n\n\n    this.getSpaceXadvance = () => {\n      return this.data.spaceXadvance;\n    };\n    /** Returns the x-height, which is the distance from the top of most lowercase characters to the baseline. */\n\n\n    this.getXHeight = () => {\n      return this.data.xHeight;\n    };\n    /** Returns the cap height, which is the distance from the top of most uppercase characters to the baseline. Since the drawing\n     * position is the cap height of the first line, the cap height can be used to get the location of the baseline. */\n\n\n    this.getCapHeight = () => {\n      return this.data.capHeight;\n    };\n    /** Returns the ascent, which is the distance from the cap height to the top of the tallest glyph. */\n\n\n    this.getAscent = () => {\n      return this.data.ascent;\n    };\n    /** Returns the descent, which is the distance from the bottom of the glyph that extends the lowest to the baseline. This\n     * number is negative. */\n\n\n    this.getDescent = () => {\n      return this.data.descent;\n    };\n    /** Returns true if this BitmapFont has been flipped for use with a y-down coordinate system. */\n\n\n    this.isFlipped = () => {\n      return this.flipped;\n    };\n    /** Disposes the texture used by this BitmapFont's region IF this BitmapFont created the texture. */\n\n\n    this.dispose = () => {\n      if (this.ownsTexture) {\n        for (let i = 0; i < this.regions.length; i++) {\n          this.regions[i].texture.dispose();\n        }\n      }\n    };\n    /** Makes the specified glyphs fixed width. This can be useful to make the numbers in a font fixed width. Eg, when horizontally\n     * centering a score or loading percentage text, it will not jump around as different numbers are shown. */\n\n\n    this.setFixedWidthGlyphs = glyphs => {\n      const data = this.data;\n      let maxAdvance = 0;\n\n      for (let index = 0, end = glyphs.length; index < end; index++) {\n        const g = data.getGlyph(glyphs.charAt(index));\n        if (g != null && g.xadvance > maxAdvance) maxAdvance = g.xadvance;\n      }\n\n      for (let index = 0, end = glyphs.length; index < end; index++) {\n        const g = data.getGlyph(glyphs.charAt(index));\n        if (!g) continue;\n        g.xoffset += (maxAdvance - g.xadvance) / 2;\n        g.xadvance = maxAdvance;\n        g.kerning = [];\n        g.kerning = null;\n        g.fixedWidth = true;\n      }\n    };\n    /** Specifies whether to use integer positions. Default is to use them so filtering doesn't kick in as badly. */\n\n\n    this.setUseIntegerPositions = integer => {\n      this.integer = integer;\n      this.cache.setUseIntegerPositions(integer);\n    };\n    /** Checks whether this font uses integer positions for drawing. */\n\n\n    this.usesIntegerPositions = () => {\n      return this.integer;\n    };\n    /** For expert usage -- returns the BitmapFontCache used by this font, for rendering to a sprite batch. This can be used, for\n     * example, to manipulate glyph colors within a specific index.\n     * @return the bitmap font cache used by this font */\n\n\n    this.getCache = () => {\n      return this.cache;\n    };\n    /** Gets the underlying {@link BitmapFontData} for this BitmapFont. */\n\n\n    this.getData = () => {\n      return this.data;\n    };\n    /** @return whether the texture is owned by the font, font disposes the texture itself if true */\n\n\n    this.getOwnsTexture = () => {\n      return this.ownsTexture;\n    };\n    /** Sets whether the font owns the texture. In case it does, the font will also dispose of the texture when {@link #dispose()}\n     * is called. Use with care!\n     * @param ownsTexture whether the font owns the texture */\n\n\n    this.setOwnsTexture = ownsTexture => {\n      this.ownsTexture = ownsTexture;\n    };\n    /** Creates a new BitmapFontCache for this font. Using this method allows the font to provide the BitmapFontCache\n     * implementation to customize rendering.\n     * <p>\n     * Note this method is called by the BitmapFont constructors. If a subclass overrides this method, it will be called before the\n     * subclass constructors. */\n\n\n    this.newFontCache = () => {\n      return new BitmapFontCache_1.BitmapFontCache(this, this.integer);\n    };\n\n    this.regions = regions;\n    this.flipped = data.flipped;\n    this.data = data;\n    this.integer = integer;\n\n    if (this.regions.length === 0) {\n      console.log('No texture region were found');\n      return;\n    } else {\n      this.ownsTexture = false;\n    }\n\n    this.cache = this.newFontCache();\n    this.load(data);\n  }\n\n}\n\nexports.BitmapFont = BitmapFont;\n_a = BitmapFont;\n\nBitmapFont.load = function (gl, fontFile) {\n  let flip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let interger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const fontData = new BitmapFontData_1.BitmapFontData(fontFile, flip);\n    yield fontData.loadFont(gl);\n    return new BitmapFont(fontData, fontData.regions, interger);\n  });\n};","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","_a","Object","defineProperty","exports","BitmapFont","BitmapFontCache_1","require","BitmapFontData_1","Utils_1","constructor","data","regions","integer","load","glyphValues","values","glyphs","i","length","page","j","glyph","setGlyphRegion","missingGlyph","draw","batch","str","x","y","targetWidth","halign","Align","left","wrap","start","end","truncate","cache","clear","addText","getColor","getScaleX","scaleX","getScaleY","scaleY","getRegions","getRegion","index","getLineHeight","lineHeight","getSpaceXadvance","spaceXadvance","getXHeight","xHeight","getCapHeight","capHeight","getAscent","ascent","getDescent","descent","isFlipped","flipped","dispose","ownsTexture","texture","setFixedWidthGlyphs","maxAdvance","g","getGlyph","charAt","xadvance","xoffset","kerning","fixedWidth","setUseIntegerPositions","usesIntegerPositions","getCache","getData","getOwnsTexture","setOwnsTexture","newFontCache","BitmapFontCache","console","log","gl","fontFile","flip","interger","fontData","BitmapFontData","loadFont"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/BitmapFont.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitmapFont = void 0;\nconst BitmapFontCache_1 = require(\"./BitmapFontCache\");\nconst BitmapFontData_1 = require(\"./BitmapFontData\");\nconst Utils_1 = require(\"./Utils\");\nclass BitmapFont {\n    /** Constructs a new BitmapFont from the given {@link BitmapFontData} and array of {@link TextureRegion}. If the TextureRegion\n     * is null or empty, the image path(s) will be read from the BitmapFontData. The dispose() method will not dispose the texture\n     * of the region(s) if the regions array is != null and not empty.\n     * @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */\n    constructor(data, regions, integer) {\n        this.load = (data) => {\n            const glyphValues = Object.values(data.glyphs);\n            for (let i = 0; i < glyphValues.length; i++) {\n                const page = glyphValues[i];\n                if (!page)\n                    continue;\n                for (let j = 0; j < page.length; j++) {\n                    const glyph = page[j];\n                    if (glyph) {\n                        data.setGlyphRegion(glyph, this.regions[glyph.page]);\n                    }\n                }\n            }\n            if (data.missingGlyph != null)\n                data.setGlyphRegion(data.missingGlyph, this.regions[data.missingGlyph.page]);\n        };\n        /** Draws text at the specified position.\n         * @see BitmapFontCache#addText(CharSequence, float, float, int, int, float, int, boolean, String) */\n        this.draw = (batch, str, x, y, targetWidth, halign = Utils_1.Align.left, wrap = true, start = 0, end = str.length, truncate) => {\n            this.cache.clear();\n            this.cache.addText(str, x, y, start, end, targetWidth, halign, wrap, truncate);\n            this.cache.draw(batch);\n        };\n        /** Returns the color of text drawn with this font. */\n        this.getColor = () => {\n            return this.cache.getColor();\n        };\n        /** A convenience method for setting the font color. The color can also be set by modifying {@link #getColor()}. */\n        // setColor = (r: number, g: number, b: number, a: number) => {\n        //    this.cache.getColor().set(r, g, b, a);\n        // };\n        this.getScaleX = () => {\n            return this.data.scaleX;\n        };\n        this.getScaleY = () => {\n            return this.data.scaleY;\n        };\n        /** Returns the array of TextureRegions that represents each texture page of glyphs.\n         * @return the array of texture regions; modifying it may produce undesirable results */\n        this.getRegions = () => {\n            return this.regions;\n        };\n        /** Returns the texture page at the given index.\n         * @return the texture page at the given index */\n        this.getRegion = (index) => {\n            return this.regions[index];\n        };\n        /** Returns the line height, which is the distance from one line of text to the next. */\n        this.getLineHeight = () => {\n            return this.data.lineHeight;\n        };\n        /** Returns the x-advance of the space character. */\n        this.getSpaceXadvance = () => {\n            return this.data.spaceXadvance;\n        };\n        /** Returns the x-height, which is the distance from the top of most lowercase characters to the baseline. */\n        this.getXHeight = () => {\n            return this.data.xHeight;\n        };\n        /** Returns the cap height, which is the distance from the top of most uppercase characters to the baseline. Since the drawing\n         * position is the cap height of the first line, the cap height can be used to get the location of the baseline. */\n        this.getCapHeight = () => {\n            return this.data.capHeight;\n        };\n        /** Returns the ascent, which is the distance from the cap height to the top of the tallest glyph. */\n        this.getAscent = () => {\n            return this.data.ascent;\n        };\n        /** Returns the descent, which is the distance from the bottom of the glyph that extends the lowest to the baseline. This\n         * number is negative. */\n        this.getDescent = () => {\n            return this.data.descent;\n        };\n        /** Returns true if this BitmapFont has been flipped for use with a y-down coordinate system. */\n        this.isFlipped = () => {\n            return this.flipped;\n        };\n        /** Disposes the texture used by this BitmapFont's region IF this BitmapFont created the texture. */\n        this.dispose = () => {\n            if (this.ownsTexture) {\n                for (let i = 0; i < this.regions.length; i++) {\n                    this.regions[i].texture.dispose();\n                }\n            }\n        };\n        /** Makes the specified glyphs fixed width. This can be useful to make the numbers in a font fixed width. Eg, when horizontally\n         * centering a score or loading percentage text, it will not jump around as different numbers are shown. */\n        this.setFixedWidthGlyphs = (glyphs) => {\n            const data = this.data;\n            let maxAdvance = 0;\n            for (let index = 0, end = glyphs.length; index < end; index++) {\n                const g = data.getGlyph(glyphs.charAt(index));\n                if (g != null && g.xadvance > maxAdvance)\n                    maxAdvance = g.xadvance;\n            }\n            for (let index = 0, end = glyphs.length; index < end; index++) {\n                const g = data.getGlyph(glyphs.charAt(index));\n                if (!g)\n                    continue;\n                g.xoffset += (maxAdvance - g.xadvance) / 2;\n                g.xadvance = maxAdvance;\n                g.kerning = [];\n                g.kerning = null;\n                g.fixedWidth = true;\n            }\n        };\n        /** Specifies whether to use integer positions. Default is to use them so filtering doesn't kick in as badly. */\n        this.setUseIntegerPositions = (integer) => {\n            this.integer = integer;\n            this.cache.setUseIntegerPositions(integer);\n        };\n        /** Checks whether this font uses integer positions for drawing. */\n        this.usesIntegerPositions = () => {\n            return this.integer;\n        };\n        /** For expert usage -- returns the BitmapFontCache used by this font, for rendering to a sprite batch. This can be used, for\n         * example, to manipulate glyph colors within a specific index.\n         * @return the bitmap font cache used by this font */\n        this.getCache = () => {\n            return this.cache;\n        };\n        /** Gets the underlying {@link BitmapFontData} for this BitmapFont. */\n        this.getData = () => {\n            return this.data;\n        };\n        /** @return whether the texture is owned by the font, font disposes the texture itself if true */\n        this.getOwnsTexture = () => {\n            return this.ownsTexture;\n        };\n        /** Sets whether the font owns the texture. In case it does, the font will also dispose of the texture when {@link #dispose()}\n         * is called. Use with care!\n         * @param ownsTexture whether the font owns the texture */\n        this.setOwnsTexture = (ownsTexture) => {\n            this.ownsTexture = ownsTexture;\n        };\n        /** Creates a new BitmapFontCache for this font. Using this method allows the font to provide the BitmapFontCache\n         * implementation to customize rendering.\n         * <p>\n         * Note this method is called by the BitmapFont constructors. If a subclass overrides this method, it will be called before the\n         * subclass constructors. */\n        this.newFontCache = () => {\n            return new BitmapFontCache_1.BitmapFontCache(this, this.integer);\n        };\n        this.regions = regions;\n        this.flipped = data.flipped;\n        this.data = data;\n        this.integer = integer;\n        if (this.regions.length === 0) {\n            console.log('No texture region were found');\n            return;\n        }\n        else {\n            this.ownsTexture = false;\n        }\n        this.cache = this.newFontCache();\n        this.load(data);\n    }\n}\nexports.BitmapFont = BitmapFont;\n_a = BitmapFont;\nBitmapFont.load = (gl, fontFile, flip = false, interger = false) => __awaiter(void 0, void 0, void 0, function* () {\n    const fontData = new BitmapFontData_1.BitmapFontData(fontFile, flip);\n    yield fontData.loadFont(gl);\n    return new BitmapFont(fontData, fontData.regions, interger);\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}