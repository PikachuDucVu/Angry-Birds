{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _regeneratorRuntime = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _classCallCheck = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitmapFontData = void 0;\n\nvar Glyph_1 = require(\"./Glyph\");\n\nvar Texture_1 = require(\"./Texture\");\n\nvar TextureRegion_1 = require(\"./TextureRegion\");\n\nfunction concatAndResolveUrl(url, concat) {\n  var url1 = url.split('/');\n  var url2 = concat.split('/');\n  var url3 = [];\n\n  for (var i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (var _i = 0, _l = url2.length; _i < _l; _i++) {\n    if (url2[_i] === '..') {\n      url3.pop();\n    } else if (url2[_i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[_i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nvar CHARACTER_MAX_VALUE = 65535;\n\nvar BitmapFontData = /*#__PURE__*/function () {\n  /** Creates an empty BitmapFontData for configuration before calling {@link #load(FileHandle, boolean)}, to subclass, or to\r\n   * populate yourself, e.g. using stb-truetype or FreeType. */\n  function BitmapFontData(fontFile, flip) {\n    var _this = this;\n\n    _classCallCheck(this, BitmapFontData);\n\n    /** The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of\r\n     * the first line, the cap height can be used to get the location of the baseline. */\n    this.capHeight = 1;\n    /** Multiplier for the line height of blank lines. down * blankLineHeight is used as the distance to move down for a blank\r\n     * line. */\n\n    this.blankLineScale = 1;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.glyphs = {};\n    /** The x-height, which is the distance from the top of most lowercase characters to the baseline. */\n\n    this.xHeight = 1;\n    this.xChars = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z'];\n    this.capChars = ['M', 'N', 'B', 'D', 'C', 'E', 'F', 'K', 'A', 'G', 'H', 'I', 'J', 'L', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\n    this.loadFont = function (gl) {\n      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var i, fileContent, res, lines, line, padding, padY, common, baseLine, pageCount, imagePaths, p, idMatches, id, pageID, fileMatches, fileName, glyph, tokens, ch, _tokens, first, second, _glyph, amount, hasMetricsOverride, overrideAscent, overrideDescent, overrideDown, overrideCapHeight, overrideLineHeight, overrideSpaceXAdvance, overrideXHeight, _tokens2, spaceGlyph, xadvanceGlyph, xGlyph, _i2, capGlyph, _i3, _glyphValues, _i4, page, j, regionsData, glyphValues, _i5, values, _j, region, pages, _i6, texture, invTexWidth, invTexHeight, _i7, _regionsData, regionData, left, top, width, height, _pages$regionData$pag, _texture, _invTexWidth, _invTexHeight, _region;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.imagePaths != null)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                i = 0;\n                _context.next = 5;\n                return fetch(this.fontFile);\n\n              case 5:\n                res = _context.sent;\n                _context.next = 8;\n                return res.text();\n\n              case 8:\n                fileContent = _context.sent;\n                lines = fileContent.split(/\\r?\\n/).map(function (s) {\n                  return s.trim();\n                });\n                _context.prev = 10;\n                line = lines[i];\n\n                if (!(typeof line !== 'string')) {\n                  _context.next = 14;\n                  break;\n                }\n\n                throw new Error('File is empty.');\n\n              case 14:\n                line = line.substring(line.indexOf('padding=') + 8);\n                padding = line.substring(0, line.indexOf(' ')).split(',', 4);\n\n                if (!(padding.length !== 4)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                throw new Error('Invalid padding.');\n\n              case 18:\n                this.padTop = parseInt(padding[0]);\n                this.padRight = parseInt(padding[1]);\n                this.padBottom = parseInt(padding[2]);\n                this.padLeft = parseInt(padding[3]);\n                padY = this.padTop + this.padBottom;\n                i++;\n                line = lines[i];\n\n                if (!(typeof line !== 'string')) {\n                  _context.next = 27;\n                  break;\n                }\n\n                throw new Error('Missing common header.');\n\n              case 27:\n                common = line.split(' ', 9); // At most we want the 6th element; i.e. \"page=N\"\n                // At least lineHeight and base are required.\n\n                if (!(common.length < 3)) {\n                  _context.next = 30;\n                  break;\n                }\n\n                throw new Error('Invalid common header.');\n\n              case 30:\n                if (common[1].startsWith('lineHeight=')) {\n                  _context.next = 32;\n                  break;\n                }\n\n                throw new Error('Missing: lineHeight');\n\n              case 32:\n                this.lineHeight = parseInt(common[1].substring(11));\n\n                if (common[2].startsWith('base=')) {\n                  _context.next = 35;\n                  break;\n                }\n\n                throw new Error('Missing: base');\n\n              case 35:\n                baseLine = parseInt(common[2].substring(5));\n                pageCount = 1;\n\n                if (common.length >= 6 && common[5] != null && common[5].startsWith('pages=')) {\n                  try {\n                    pageCount = Math.max(1, parseInt(common[5].substring(6)));\n                  } catch (_a) {// Use one page.\n                  }\n                }\n\n                this.imagePaths = new Array(pageCount);\n                imagePaths = []; // Read each page definition.\n\n                p = 0;\n\n              case 41:\n                if (!(p < pageCount)) {\n                  _context.next = 65;\n                  break;\n                }\n\n                // Read each \"page\" info line.\n                i++;\n                line = lines[i];\n\n                if (!(typeof line !== 'string')) {\n                  _context.next = 46;\n                  break;\n                }\n\n                throw new Error('Missing additional page definitions.');\n\n              case 46:\n                // Expect ID to mean \"index\".\n                idMatches = line.match(new RegExp('.*id=(\\\\d+)'));\n\n                if (!(idMatches && idMatches.length > 1)) {\n                  _context.next = 57;\n                  break;\n                }\n\n                id = idMatches[1];\n                _context.prev = 49;\n                pageID = parseInt(id);\n\n                if (!(pageID !== p)) {\n                  _context.next = 53;\n                  break;\n                }\n\n                throw new Error('Page IDs must be indices starting at 0: ' + id);\n\n              case 53:\n                _context.next = 57;\n                break;\n\n              case 55:\n                _context.prev = 55;\n                _context.t0 = _context[\"catch\"](49);\n\n              case 57:\n                fileMatches = line.match(new RegExp('.*file=\"?([^\"]+)\"?'));\n\n                if (!(!fileMatches || fileMatches.length <= 1)) {\n                  _context.next = 60;\n                  break;\n                }\n\n                throw new Error('Missing: file');\n\n              case 60:\n                fileName = fileMatches[1];\n                imagePaths[p] = fileName; // this.imagePaths[p] = fontFile.parent().child(fileName).path().replaceAll(\"\\\\\\\\\", \"/\");\n\n              case 62:\n                p++;\n                _context.next = 41;\n                break;\n\n              case 65:\n                this.descent = 0;\n\n              case 66:\n                if (!true) {\n                  _context.next = 105;\n                  break;\n                }\n\n                i++;\n                line = lines[i];\n\n                if (line) {\n                  _context.next = 71;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 105);\n\n              case 71:\n                if (!line.startsWith('kernings ')) {\n                  _context.next = 73;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 105);\n\n              case 73:\n                if (!line.startsWith('metrics ')) {\n                  _context.next = 75;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 105);\n\n              case 75:\n                if (line.startsWith('char ')) {\n                  _context.next = 77;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 66);\n\n              case 77:\n                glyph = new Glyph_1.Glyph();\n                tokens = new StringTokenizer(line, '=');\n                tokens.nextToken();\n                tokens.nextToken();\n                ch = parseInt(tokens.nextToken());\n\n                if (!(ch > 0 && ch > CHARACTER_MAX_VALUE)) {\n                  _context.next = 84;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 66);\n\n              case 84:\n                glyph.id = ch + '';\n                tokens.nextToken();\n                glyph.srcX = parseInt(tokens.nextToken());\n                tokens.nextToken();\n                glyph.srcY = parseInt(tokens.nextToken());\n                tokens.nextToken();\n                glyph.width = parseInt(tokens.nextToken());\n                tokens.nextToken();\n                glyph.height = parseInt(tokens.nextToken());\n                tokens.nextToken();\n                glyph.xoffset = parseInt(tokens.nextToken());\n                tokens.nextToken();\n                if (this.flipped) glyph.yoffset = parseInt(tokens.nextToken());else glyph.yoffset = -(glyph.height + parseInt(tokens.nextToken()));\n                tokens.nextToken();\n                glyph.xadvance = parseInt(tokens.nextToken()); // Check for page safely, it could be omitted or invalid.\n\n                if (tokens.hasMoreTokens()) tokens.nextToken();\n\n                if (tokens.hasMoreTokens()) {\n                  try {\n                    glyph.page = parseInt(tokens.nextToken());\n                  } catch (_c) {}\n                }\n\n                if (glyph.width > 0 && glyph.height > 0) this.descent = Math.min(baseLine + glyph.yoffset, this.descent);\n\n                if (ch <= 0) {\n                  this.missingGlyph = glyph;\n                } else if (ch <= CHARACTER_MAX_VALUE) {\n                  this.setGlyph(ch, glyph);\n                }\n\n                _context.next = 66;\n                break;\n\n              case 105:\n                this.descent += this.padBottom;\n\n              case 106:\n                if (!true) {\n                  _context.next = 127;\n                  break;\n                }\n\n                i++;\n                line = lines[i];\n\n                if (!(typeof line !== 'string')) {\n                  _context.next = 111;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 127);\n\n              case 111:\n                if (line.startsWith('kerning ')) {\n                  _context.next = 113;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 127);\n\n              case 113:\n                _tokens = new StringTokenizer(line, '=');\n\n                _tokens.nextToken();\n\n                _tokens.nextToken();\n\n                first = parseInt(_tokens.nextToken());\n\n                _tokens.nextToken();\n\n                second = parseInt(_tokens.nextToken());\n\n                if (!(first < 0 || first > CHARACTER_MAX_VALUE || second < 0 || second > CHARACTER_MAX_VALUE)) {\n                  _context.next = 121;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 106);\n\n              case 121:\n                _glyph = this.getGlyph(first + '');\n\n                _tokens.nextToken();\n\n                amount = parseInt(_tokens.nextToken());\n\n                if (_glyph) {\n                  // Kernings may exist for glyph pairs not contained in the font.\n                  _glyph.setKerning(second, amount);\n                }\n\n                _context.next = 106;\n                break;\n\n              case 127:\n                hasMetricsOverride = false;\n                overrideAscent = 0;\n                overrideDescent = 0;\n                overrideDown = 0;\n                overrideCapHeight = 0;\n                overrideLineHeight = 0;\n                overrideSpaceXAdvance = 0;\n                overrideXHeight = 0; // Metrics override\n\n                if (line != null && line.startsWith('metrics ')) {\n                  hasMetricsOverride = true;\n                  _tokens2 = new StringTokenizer(line, '=');\n\n                  _tokens2.nextToken();\n\n                  _tokens2.nextToken();\n\n                  overrideAscent = parseFloat(_tokens2.nextToken());\n\n                  _tokens2.nextToken();\n\n                  overrideDescent = parseFloat(_tokens2.nextToken());\n\n                  _tokens2.nextToken();\n\n                  overrideDown = parseFloat(_tokens2.nextToken());\n\n                  _tokens2.nextToken();\n\n                  overrideCapHeight = parseFloat(_tokens2.nextToken());\n\n                  _tokens2.nextToken();\n\n                  overrideLineHeight = parseFloat(_tokens2.nextToken());\n\n                  _tokens2.nextToken();\n\n                  overrideSpaceXAdvance = parseFloat(_tokens2.nextToken());\n\n                  _tokens2.nextToken();\n\n                  overrideXHeight = parseFloat(_tokens2.nextToken());\n                }\n\n                spaceGlyph = this.getGlyph('32');\n\n                if (!spaceGlyph) {\n                  spaceGlyph = new Glyph_1.Glyph();\n                  spaceGlyph.id = '32';\n                  xadvanceGlyph = this.getGlyph('l');\n                  if (!xadvanceGlyph) xadvanceGlyph = this.getFirstGlyph();\n                  spaceGlyph.xadvance = xadvanceGlyph.xadvance;\n                  this.setGlyph(32, spaceGlyph); // space character ascii code\n                }\n\n                if (spaceGlyph.width === 0) {\n                  spaceGlyph.width = this.padLeft + spaceGlyph.xadvance + this.padRight;\n                  spaceGlyph.xoffset = -this.padLeft;\n                }\n\n                this.spaceXadvance = spaceGlyph.xadvance;\n                _i2 = 0;\n\n              case 141:\n                if (!(_i2 < this.xChars.length)) {\n                  _context.next = 148;\n                  break;\n                }\n\n                xGlyph = this.getGlyph(this.xChars[_i2]);\n\n                if (!xGlyph) {\n                  _context.next = 145;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 148);\n\n              case 145:\n                _i2++;\n                _context.next = 141;\n                break;\n\n              case 148:\n                if (!xGlyph) xGlyph = this.getFirstGlyph();\n                this.xHeight = xGlyph.height - padY;\n                _i3 = 0;\n\n              case 151:\n                if (!(_i3 < this.capChars.length)) {\n                  _context.next = 158;\n                  break;\n                }\n\n                capGlyph = this.getGlyph(this.capChars[_i3]);\n\n                if (!capGlyph) {\n                  _context.next = 155;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 158);\n\n              case 155:\n                _i3++;\n                _context.next = 151;\n                break;\n\n              case 158:\n                if (capGlyph) {\n                  _context.next = 178;\n                  break;\n                }\n\n                _glyphValues = Object.values(this.glyphs);\n                _i4 = 0;\n\n              case 161:\n                if (!(_i4 < _glyphValues.length)) {\n                  _context.next = 176;\n                  break;\n                }\n\n                page = _glyphValues[_i4];\n\n                if (page) {\n                  _context.next = 165;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 173);\n\n              case 165:\n                j = 0;\n\n              case 166:\n                if (!(j < page.length)) {\n                  _context.next = 173;\n                  break;\n                }\n\n                if (!(!page[j] || page[j].height === 0 || page[j].width === 0)) {\n                  _context.next = 169;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 170);\n\n              case 169:\n                this.capHeight = Math.max(this.capHeight, page[j].height);\n\n              case 170:\n                j++;\n                _context.next = 166;\n                break;\n\n              case 173:\n                _i4++;\n                _context.next = 161;\n                break;\n\n              case 176:\n                _context.next = 179;\n                break;\n\n              case 178:\n                this.capHeight = capGlyph.height;\n\n              case 179:\n                this.capHeight -= padY;\n                this.ascent = baseLine - this.capHeight;\n                this.down = -this.lineHeight;\n\n                if (this.flipped) {\n                  this.ascent = -this.ascent;\n                  this.down = -this.down;\n                }\n\n                if (hasMetricsOverride) {\n                  this.ascent = overrideAscent;\n                  this.descent = overrideDescent;\n                  this.down = overrideDown;\n                  this.capHeight = overrideCapHeight;\n                  this.lineHeight = overrideLineHeight;\n                  this.spaceXadvance = overrideSpaceXAdvance;\n                  this.xHeight = overrideXHeight;\n                } // Generate texture regions\n\n\n                regionsData = [];\n                glyphValues = Object.values(this.glyphs);\n\n                for (_i5 = 0; _i5 < glyphValues.length; _i5++) {\n                  values = Object.values(glyphValues[_i5]);\n\n                  for (_j = 0; _j < values.length; _j++) {\n                    region = {\n                      id: values[_j].id,\n                      left: values[_j].srcX,\n                      top: values[_j].srcY,\n                      width: values[_j].width,\n                      height: values[_j].height,\n                      xoffset: values[_j].xoffset,\n                      yoffset: values[_j].yoffset,\n                      xadvance: values[_j].xadvance,\n                      page: imagePaths[values[_j].page],\n                      pageId: values[_j].page\n                    };\n                    regionsData.push(region);\n                  }\n                }\n\n                pages = [];\n                _i6 = 0;\n\n              case 189:\n                if (!(_i6 < pageCount)) {\n                  _context.next = 199;\n                  break;\n                }\n\n                _context.next = 192;\n                return Texture_1.Texture.load(gl, concatAndResolveUrl(this.fontFile, \"../\".concat(imagePaths[_i6])));\n\n              case 192:\n                texture = _context.sent;\n                invTexWidth = 1 / texture.width;\n                invTexHeight = 1 / texture.height;\n                pages.push({\n                  texture: texture,\n                  invTexWidth: invTexWidth,\n                  invTexHeight: invTexHeight\n                });\n\n              case 196:\n                _i6++;\n                _context.next = 189;\n                break;\n\n              case 199:\n                this.regions = [];\n\n                for (_i7 = 0, _regionsData = regionsData; _i7 < _regionsData.length; _i7++) {\n                  regionData = _regionsData[_i7];\n                  left = regionData.left;\n                  top = regionData.top;\n                  width = regionData.width;\n                  height = regionData.height;\n                  _pages$regionData$pag = pages[regionData.pageId], _texture = _pages$regionData$pag.texture, _invTexWidth = _pages$regionData$pag.invTexWidth, _invTexHeight = _pages$regionData$pag.invTexHeight;\n                  _region = new TextureRegion_1.TextureRegion(_texture, left, top, width, height, regionData, _invTexWidth, _invTexHeight);\n                  _region.originalWidth = width;\n                  _region.originalHeight = height;\n                  _region.offsetX = 0;\n                  _region.offsetY = 0;\n                  this.regions.push(_region);\n                }\n\n                _context.next = 206;\n                break;\n\n              case 203:\n                _context.prev = 203;\n                _context.t1 = _context[\"catch\"](10);\n                console.error(_context.t1);\n\n              case 206:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[10, 203], [49, 55]]);\n      }));\n    };\n\n    this.setGlyphRegion = function (glyph, region) {\n      var texture = region.texture;\n      var invTexWidth = 1 / texture.width;\n      var invTexHeight = 1 / texture.height;\n      var offsetX = 0,\n          offsetY = 0;\n      var u = region.u;\n      var v = region.v;\n      var regionWidth = region.originalWidth;\n      var regionHeight = region.originalHeight; // if (region instanceof AtlasRegion) {\n      //    // Compensate for whitespace stripped from left and top edges.\n      //    AtlasRegion atlasRegion = (AtlasRegion)region;\n      //    offsetX = atlasRegion.offsetX;\n      //    offsetY = atlasRegion.originalHeight - atlasRegion.packedHeight - atlasRegion.offsetY;\n      // }\n\n      var x = glyph.srcX;\n      var x2 = glyph.srcX + glyph.width;\n      var y = glyph.srcY;\n      var y2 = glyph.srcY + glyph.height; // Shift glyph for left and top edge stripped whitespace. Clip glyph for right and bottom edge stripped whitespace.\n      // Note if the font region has padding, whitespace stripping must not be used.\n\n      if (offsetX > 0) {\n        x -= offsetX;\n\n        if (x < 0) {\n          glyph.width += x;\n          glyph.xoffset -= x;\n          x = 0;\n        }\n\n        x2 -= offsetX;\n\n        if (x2 > regionWidth) {\n          glyph.width -= x2 - regionWidth;\n          x2 = regionWidth;\n        }\n      }\n\n      if (offsetY > 0) {\n        y -= offsetY;\n\n        if (y < 0) {\n          glyph.height += y;\n          if (glyph.height < 0) glyph.height = 0;\n          y = 0;\n        }\n\n        y2 -= offsetY;\n\n        if (y2 > regionHeight) {\n          var amount = y2 - regionHeight;\n          glyph.height -= amount;\n          glyph.yoffset += amount;\n          y2 = regionHeight;\n        }\n      }\n\n      glyph.u = u + x * invTexWidth;\n      glyph.u2 = u + x2 * invTexWidth;\n\n      if (_this.flipped) {\n        glyph.v = v + y * invTexHeight;\n        glyph.v2 = v + y2 * invTexHeight;\n      } else {\n        glyph.v2 = v + y * invTexHeight;\n        glyph.v = v + y2 * invTexHeight;\n      }\n    };\n    /** Sets the line height, which is the distance from one line of text to the next. */\n\n\n    this.setLineHeight = function (height) {\n      _this.lineHeight = height * _this.scaleY;\n      _this.down = _this.flipped ? _this.lineHeight : -_this.lineHeight;\n    };\n\n    this.setGlyph = function (ch, glyph) {\n      var page = _this.glyphs[ch / Glyph_1.PAGE_SIZE];\n\n      if (!page) {\n        page = new Array(Glyph_1.PAGE_SIZE);\n        _this.glyphs[ch / Glyph_1.PAGE_SIZE] = page; // this.glyphs[ch / PAGE_SIZE] = page = new Glyph[PAGE_SIZE];\n      }\n\n      page[ch & Glyph_1.PAGE_SIZE - 1] = glyph;\n    };\n\n    this.getFirstGlyph = function () {\n      var glyphValues = Object.values(_this.glyphs);\n\n      for (var i = 0; i < glyphValues.length; i++) {\n        var page = glyphValues[i];\n        if (!page) continue;\n\n        for (var j = 0; j < page.length; j++) {\n          var glyph = page[j];\n          if (!glyph || glyph.height === 0 || glyph.width === 0) continue;\n          return glyph;\n        }\n      }\n    };\n    /** Returns true if the font has the glyph, or if the font has a {@link #missingGlyph}. */\n\n\n    this.hasGlyph = function (ch) {\n      if (_this.missingGlyph) return true;\n      return _this.getGlyph(ch) != null;\n    };\n    /** Returns the glyph for the specified character, or null if no such glyph exists. Note that\r\n     * {@link #getGlyphs(GlyphRun, CharSequence, int, int, Glyph)} should be be used to shape a string of characters into a list\r\n     * of glyphs. */\n\n\n    this.getGlyph = function (ch) {\n      var page = _this.glyphs[ch.charCodeAt(0) / Glyph_1.PAGE_SIZE];\n\n      if (page != null) return page[ch.charCodeAt(0) & Glyph_1.PAGE_SIZE - 1];\n      return undefined;\n    };\n    /** Using the specified string, populates the glyphs and positions of the specified glyph run.\r\n     * @param str Characters to convert to glyphs. Will not contain newline or color tags. May contain \"[[\" for an escaped left\r\n     *           square bracket.\r\n     * @param lastGlyph The glyph immediately before this run, or null if this is run is the first on a line of text. Used tp\r\n     *           apply kerning between the specified glyph and the first glyph in this run. */\n\n\n    this.getGlyphs = function (run, str, start, end, lastGlyph) {\n      var max = end - start;\n      if (max === 0) return;\n      var markupEnabled = _this.markupEnabled;\n      var scaleX = _this.scaleX;\n      var glyphs = run.glyphs;\n      var xAdvances = run.xAdvances; // Guess at number of glyphs needed.\n      // glyphs.ensureCapacity(max);\n      // run.xAdvances.ensureCapacity(max + 1);\n\n      do {\n        var ch = str.charAt(start++);\n        if (ch === '\\r') continue; // Ignore.\n\n        var glyph = _this.getGlyph(ch);\n\n        if (!glyph) {\n          if (!_this.missingGlyph) continue;\n          glyph = _this.missingGlyph;\n        }\n\n        glyphs.push(glyph);\n        xAdvances.push(!lastGlyph // First glyph on line, adjust the position so it isn't drawn left of 0.\n        ? glyph.fixedWidth ? 0 : -glyph.xoffset * scaleX - _this.padLeft : (lastGlyph.xadvance + lastGlyph.getKerning(ch)) * scaleX);\n        lastGlyph = glyph; // \"[[\" is an escaped left square bracket, skip second character.\n\n        if (markupEnabled && ch === '[' && start < end && str.charAt(start) === '[') start++;\n      } while (start < end);\n\n      if (lastGlyph) {\n        var lastGlyphWidth = lastGlyph.fixedWidth ? lastGlyph.xadvance * scaleX : (lastGlyph.width + lastGlyph.xoffset) * scaleX - _this.padRight;\n        xAdvances.push(lastGlyphWidth);\n      }\n    };\n    /** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\r\n     * (typically) moving toward the beginning of the glyphs array. */\n\n\n    this.getWrapIndex = function (glyphs, start) {\n      var i = start - 1;\n      var glyphsItems = glyphs;\n      var ch = glyphsItems[i].id;\n      if (_this.isWhitespace(ch + '')) return i;\n      if (_this.isBreakChar(ch + '')) i--;\n\n      for (; i > 0; i--) {\n        ch = glyphsItems[i].id;\n\n        if (_this.isWhitespace(ch + '') || _this.isBreakChar(ch + '')) {\n          return i + 1;\n        }\n      }\n\n      return 0;\n    };\n\n    this.isBreakChar = function (c) {\n      if (!_this.breakChars) return false;\n      var character = String.fromCharCode(parseInt(c));\n\n      for (var i = 0; i < _this.breakChars.length; i++) {\n        if (character === _this.breakChars[i]) return true;\n      }\n\n      return false;\n    };\n\n    this.isWhitespace = function (c) {\n      var character = String.fromCharCode(parseInt(c));\n\n      switch (character) {\n        case '\\n':\n        case '\\r':\n        case '\\t':\n        case ' ':\n          return true;\n\n        default:\n          return false;\n      }\n    };\n    /** Returns the image path for the texture page at the given index (the \"id\" in the BMFont file). */\n\n\n    this.getImagePath = function (index) {\n      return _this.imagePaths[index];\n    };\n\n    this.getImagePaths = function () {\n      return _this.imagePaths;\n    };\n    /** Scales the font by the specified amounts on both axes\r\n     * <p>\r\n     * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}.\r\n     * The default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.\r\n     * @throws IllegalArgumentException if scaleX or scaleY is zero. */\n\n\n    this.setScale = function (scaleX, scaleY) {\n      if (scaleX === 0 || scaleY === 0) return;\n      var x = scaleX / _this.scaleX;\n      var y = scaleY / _this.scaleY;\n      _this.lineHeight *= y;\n      _this.spaceXadvance *= x;\n      _this.xHeight *= y;\n      _this.capHeight *= y;\n      _this.ascent *= y;\n      _this.descent *= y;\n      _this.down *= y;\n      _this.padLeft *= x;\n      _this.padRight *= x;\n      _this.padTop *= y;\n      _this.padBottom *= y;\n      _this.scaleX = scaleX;\n      _this.scaleY = scaleY;\n    };\n    /** Sets the font's scale relative to the current scale.\r\n     * @see #setScale(float, float)\r\n     * @throws IllegalArgumentException if the resulting scale is zero. */\n\n\n    this.scale = function (amount) {\n      _this.setScale(_this.scaleX + amount, _this.scaleY + amount);\n    };\n\n    this.fontFile = fontFile;\n    this.flipped = flip;\n  }\n  /** Scales the font by the specified amount in both directions.\r\n   * @see #setScale(float, float)\r\n   * @throws IllegalArgumentException if scaleX or scaleY is zero. */\n\n\n  _createClass(BitmapFontData, [{\n    key: \"setXYScale\",\n    value: function setXYScale(scaleXY) {\n      this.setScale(scaleXY, scaleXY);\n    }\n  }]);\n\n  return BitmapFontData;\n}();\n\nexports.BitmapFontData = BitmapFontData;\n\nvar StringTokenizer = /*#__PURE__*/function () {\n  function StringTokenizer(str, delimitter) {\n    _classCallCheck(this, StringTokenizer);\n\n    this.strArray = [];\n    this.currentIndex = 0;\n    var strings = str.split(/\\s+/);\n\n    for (var i = 0; i < strings.length; i++) {\n      var _this$strArray;\n\n      var st = strings[i];\n\n      (_this$strArray = this.strArray).push.apply(_this$strArray, _toConsumableArray(st.split(delimitter)));\n    }\n  }\n\n  _createClass(StringTokenizer, [{\n    key: \"hasMoreTokens\",\n    value: function hasMoreTokens() {\n      return this.currentIndex >= this.strArray.length;\n    }\n  }, {\n    key: \"nextToken\",\n    value: function nextToken() {\n      return this.strArray[this.currentIndex++];\n    }\n  }]);\n\n  return StringTokenizer;\n}();","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","BitmapFontData","Glyph_1","require","Texture_1","TextureRegion_1","concatAndResolveUrl","url","concat","url1","split","url2","url3","i","l","length","pop","push","join","CHARACTER_MAX_VALUE","fontFile","flip","capHeight","blankLineScale","scaleX","scaleY","glyphs","xHeight","xChars","capChars","loadFont","gl","imagePaths","fetch","res","text","fileContent","lines","map","s","trim","line","Error","substring","indexOf","padding","padTop","parseInt","padRight","padBottom","padLeft","padY","common","startsWith","lineHeight","baseLine","pageCount","Math","max","_a","Array","p","idMatches","match","RegExp","id","pageID","fileMatches","fileName","descent","glyph","Glyph","tokens","StringTokenizer","nextToken","ch","srcX","srcY","width","height","xoffset","flipped","yoffset","xadvance","hasMoreTokens","page","_c","min","missingGlyph","setGlyph","first","second","getGlyph","amount","setKerning","hasMetricsOverride","overrideAscent","overrideDescent","overrideDown","overrideCapHeight","overrideLineHeight","overrideSpaceXAdvance","overrideXHeight","parseFloat","spaceGlyph","xadvanceGlyph","getFirstGlyph","spaceXadvance","xGlyph","capGlyph","glyphValues","values","j","ascent","down","regionsData","region","left","top","pageId","pages","Texture","load","texture","invTexWidth","invTexHeight","regions","regionData","TextureRegion","originalWidth","originalHeight","offsetX","offsetY","console","error","setGlyphRegion","u","v","regionWidth","regionHeight","x","x2","y","y2","u2","v2","setLineHeight","PAGE_SIZE","hasGlyph","charCodeAt","undefined","getGlyphs","run","str","start","end","lastGlyph","markupEnabled","xAdvances","charAt","fixedWidth","getKerning","lastGlyphWidth","getWrapIndex","glyphsItems","isWhitespace","isBreakChar","c","breakChars","character","String","fromCharCode","getImagePath","index","getImagePaths","setScale","scale","scaleXY","delimitter","strArray","currentIndex","strings","st"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/BitmapFontData.js"],"sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BitmapFontData = void 0;\r\nconst Glyph_1 = require(\"./Glyph\");\r\nconst Texture_1 = require(\"./Texture\");\r\nconst TextureRegion_1 = require(\"./TextureRegion\");\r\nfunction concatAndResolveUrl(url, concat) {\r\n    let url1 = url.split('/');\r\n    let url2 = concat.split('/');\r\n    let url3 = [];\r\n    for (let i = 0, l = url1.length; i < l; i++) {\r\n        if (url1[i] === '..') {\r\n            url3.pop();\r\n        }\r\n        else if (url1[i] === '.') {\r\n            continue;\r\n        }\r\n        else {\r\n            url3.push(url1[i]);\r\n        }\r\n    }\r\n    for (let i = 0, l = url2.length; i < l; i++) {\r\n        if (url2[i] === '..') {\r\n            url3.pop();\r\n        }\r\n        else if (url2[i] === '.') {\r\n            continue;\r\n        }\r\n        else {\r\n            url3.push(url2[i]);\r\n        }\r\n    }\r\n    return url3.join('/');\r\n}\r\nconst CHARACTER_MAX_VALUE = 65535;\r\nclass BitmapFontData {\r\n    /** Creates an empty BitmapFontData for configuration before calling {@link #load(FileHandle, boolean)}, to subclass, or to\r\n     * populate yourself, e.g. using stb-truetype or FreeType. */\r\n    constructor(fontFile, flip) {\r\n        /** The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of\r\n         * the first line, the cap height can be used to get the location of the baseline. */\r\n        this.capHeight = 1;\r\n        /** Multiplier for the line height of blank lines. down * blankLineHeight is used as the distance to move down for a blank\r\n         * line. */\r\n        this.blankLineScale = 1;\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.glyphs = {};\r\n        /** The x-height, which is the distance from the top of most lowercase characters to the baseline. */\r\n        this.xHeight = 1;\r\n        this.xChars = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z'];\r\n        this.capChars = [\r\n            'M',\r\n            'N',\r\n            'B',\r\n            'D',\r\n            'C',\r\n            'E',\r\n            'F',\r\n            'K',\r\n            'A',\r\n            'G',\r\n            'H',\r\n            'I',\r\n            'J',\r\n            'L',\r\n            'O',\r\n            'P',\r\n            'Q',\r\n            'R',\r\n            'S',\r\n            'T',\r\n            'U',\r\n            'V',\r\n            'W',\r\n            'X',\r\n            'Y',\r\n            'Z'\r\n        ];\r\n        this.loadFont = (gl) => __awaiter(this, void 0, void 0, function* () {\r\n            if (this.imagePaths != null)\r\n                return;\r\n            let i = 0;\r\n            let fileContent;\r\n            const res = yield fetch(this.fontFile);\r\n            fileContent = yield res.text();\r\n            const lines = fileContent.split(/\\r?\\n/).map((s) => s.trim());\r\n            try {\r\n                let line = lines[i];\r\n                if (typeof line !== 'string')\r\n                    throw new Error('File is empty.');\r\n                line = line.substring(line.indexOf('padding=') + 8);\r\n                const padding = line.substring(0, line.indexOf(' ')).split(',', 4);\r\n                if (padding.length !== 4)\r\n                    throw new Error('Invalid padding.');\r\n                this.padTop = parseInt(padding[0]);\r\n                this.padRight = parseInt(padding[1]);\r\n                this.padBottom = parseInt(padding[2]);\r\n                this.padLeft = parseInt(padding[3]);\r\n                const padY = this.padTop + this.padBottom;\r\n                i++;\r\n                line = lines[i];\r\n                if (typeof line !== 'string')\r\n                    throw new Error('Missing common header.');\r\n                const common = line.split(' ', 9); // At most we want the 6th element; i.e. \"page=N\"\r\n                // At least lineHeight and base are required.\r\n                if (common.length < 3)\r\n                    throw new Error('Invalid common header.');\r\n                if (!common[1].startsWith('lineHeight='))\r\n                    throw new Error('Missing: lineHeight');\r\n                this.lineHeight = parseInt(common[1].substring(11));\r\n                if (!common[2].startsWith('base='))\r\n                    throw new Error('Missing: base');\r\n                const baseLine = parseInt(common[2].substring(5));\r\n                let pageCount = 1;\r\n                if (common.length >= 6 && common[5] != null && common[5].startsWith('pages=')) {\r\n                    try {\r\n                        pageCount = Math.max(1, parseInt(common[5].substring(6)));\r\n                    }\r\n                    catch (_a) {\r\n                        // Use one page.\r\n                    }\r\n                }\r\n                this.imagePaths = new Array(pageCount);\r\n                const imagePaths = [];\r\n                // Read each page definition.\r\n                for (let p = 0; p < pageCount; p++) {\r\n                    // Read each \"page\" info line.\r\n                    i++;\r\n                    line = lines[i];\r\n                    if (typeof line !== 'string')\r\n                        throw new Error('Missing additional page definitions.');\r\n                    // Expect ID to mean \"index\".\r\n                    const idMatches = line.match(new RegExp('.*id=(\\\\d+)'));\r\n                    if (idMatches && idMatches.length > 1) {\r\n                        const id = idMatches[1];\r\n                        try {\r\n                            const pageID = parseInt(id);\r\n                            if (pageID !== p)\r\n                                throw new Error('Page IDs must be indices starting at 0: ' + id);\r\n                        }\r\n                        catch (_b) { }\r\n                    }\r\n                    const fileMatches = line.match(new RegExp('.*file=\"?([^\"]+)\"?'));\r\n                    if (!fileMatches || fileMatches.length <= 1)\r\n                        throw new Error('Missing: file');\r\n                    const fileName = fileMatches[1];\r\n                    imagePaths[p] = fileName;\r\n                    // this.imagePaths[p] = fontFile.parent().child(fileName).path().replaceAll(\"\\\\\\\\\", \"/\");\r\n                }\r\n                this.descent = 0;\r\n                while (true) {\r\n                    i++;\r\n                    line = lines[i];\r\n                    if (!line)\r\n                        break; // EOF\r\n                    if (line.startsWith('kernings '))\r\n                        break; // Starting kernings block.\r\n                    if (line.startsWith('metrics '))\r\n                        break; // Starting metrics block.\r\n                    if (!line.startsWith('char '))\r\n                        continue;\r\n                    const glyph = new Glyph_1.Glyph();\r\n                    const tokens = new StringTokenizer(line, '=');\r\n                    tokens.nextToken();\r\n                    tokens.nextToken();\r\n                    const ch = parseInt(tokens.nextToken());\r\n                    if (ch > 0 && ch > CHARACTER_MAX_VALUE)\r\n                        continue;\r\n                    glyph.id = ch + '';\r\n                    tokens.nextToken();\r\n                    glyph.srcX = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    glyph.srcY = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    glyph.width = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    glyph.height = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    glyph.xoffset = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    if (this.flipped)\r\n                        glyph.yoffset = parseInt(tokens.nextToken());\r\n                    else\r\n                        glyph.yoffset = -(glyph.height + parseInt(tokens.nextToken()));\r\n                    tokens.nextToken();\r\n                    glyph.xadvance = parseInt(tokens.nextToken());\r\n                    // Check for page safely, it could be omitted or invalid.\r\n                    if (tokens.hasMoreTokens())\r\n                        tokens.nextToken();\r\n                    if (tokens.hasMoreTokens()) {\r\n                        try {\r\n                            glyph.page = parseInt(tokens.nextToken());\r\n                        }\r\n                        catch (_c) { }\r\n                    }\r\n                    if (glyph.width > 0 && glyph.height > 0)\r\n                        this.descent = Math.min(baseLine + glyph.yoffset, this.descent);\r\n                    if (ch <= 0) {\r\n                        this.missingGlyph = glyph;\r\n                    }\r\n                    else if (ch <= CHARACTER_MAX_VALUE) {\r\n                        this.setGlyph(ch, glyph);\r\n                    }\r\n                }\r\n                this.descent += this.padBottom;\r\n                while (true) {\r\n                    i++;\r\n                    line = lines[i];\r\n                    if (typeof line !== 'string')\r\n                        break;\r\n                    if (!line.startsWith('kerning '))\r\n                        break;\r\n                    const tokens = new StringTokenizer(line, '=');\r\n                    tokens.nextToken();\r\n                    tokens.nextToken();\r\n                    let first = parseInt(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    let second = parseInt(tokens.nextToken());\r\n                    if (first < 0 || first > CHARACTER_MAX_VALUE || second < 0 || second > CHARACTER_MAX_VALUE)\r\n                        continue;\r\n                    const glyph = this.getGlyph(first + '');\r\n                    tokens.nextToken();\r\n                    const amount = parseInt(tokens.nextToken());\r\n                    if (glyph) {\r\n                        // Kernings may exist for glyph pairs not contained in the font.\r\n                        glyph.setKerning(second, amount);\r\n                    }\r\n                }\r\n                let hasMetricsOverride = false;\r\n                let overrideAscent = 0;\r\n                let overrideDescent = 0;\r\n                let overrideDown = 0;\r\n                let overrideCapHeight = 0;\r\n                let overrideLineHeight = 0;\r\n                let overrideSpaceXAdvance = 0;\r\n                let overrideXHeight = 0;\r\n                // Metrics override\r\n                if (line != null && line.startsWith('metrics ')) {\r\n                    hasMetricsOverride = true;\r\n                    const tokens = new StringTokenizer(line, '=');\r\n                    tokens.nextToken();\r\n                    tokens.nextToken();\r\n                    overrideAscent = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideDescent = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideDown = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideCapHeight = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideLineHeight = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideSpaceXAdvance = parseFloat(tokens.nextToken());\r\n                    tokens.nextToken();\r\n                    overrideXHeight = parseFloat(tokens.nextToken());\r\n                }\r\n                let spaceGlyph = this.getGlyph('32');\r\n                if (!spaceGlyph) {\r\n                    spaceGlyph = new Glyph_1.Glyph();\r\n                    spaceGlyph.id = '32';\r\n                    let xadvanceGlyph = this.getGlyph('l');\r\n                    if (!xadvanceGlyph)\r\n                        xadvanceGlyph = this.getFirstGlyph();\r\n                    spaceGlyph.xadvance = xadvanceGlyph.xadvance;\r\n                    this.setGlyph(32, spaceGlyph); // space character ascii code\r\n                }\r\n                if (spaceGlyph.width === 0) {\r\n                    spaceGlyph.width = this.padLeft + spaceGlyph.xadvance + this.padRight;\r\n                    spaceGlyph.xoffset = -this.padLeft;\r\n                }\r\n                this.spaceXadvance = spaceGlyph.xadvance;\r\n                let xGlyph;\r\n                for (let i = 0; i < this.xChars.length; i++) {\r\n                    xGlyph = this.getGlyph(this.xChars[i]);\r\n                    if (xGlyph)\r\n                        break;\r\n                }\r\n                if (!xGlyph)\r\n                    xGlyph = this.getFirstGlyph();\r\n                this.xHeight = xGlyph.height - padY;\r\n                let capGlyph;\r\n                for (let i = 0; i < this.capChars.length; i++) {\r\n                    capGlyph = this.getGlyph(this.capChars[i]);\r\n                    if (capGlyph)\r\n                        break;\r\n                }\r\n                if (!capGlyph) {\r\n                    const glyphValues = Object.values(this.glyphs);\r\n                    for (let i = 0; i < glyphValues.length; i++) {\r\n                        const page = glyphValues[i];\r\n                        if (!page)\r\n                            continue;\r\n                        for (let j = 0; j < page.length; j++) {\r\n                            if (!page[j] || page[j].height === 0 || page[j].width === 0)\r\n                                continue;\r\n                            this.capHeight = Math.max(this.capHeight, page[j].height);\r\n                        }\r\n                    }\r\n                }\r\n                else\r\n                    this.capHeight = capGlyph.height;\r\n                this.capHeight -= padY;\r\n                this.ascent = baseLine - this.capHeight;\r\n                this.down = -this.lineHeight;\r\n                if (this.flipped) {\r\n                    this.ascent = -this.ascent;\r\n                    this.down = -this.down;\r\n                }\r\n                if (hasMetricsOverride) {\r\n                    this.ascent = overrideAscent;\r\n                    this.descent = overrideDescent;\r\n                    this.down = overrideDown;\r\n                    this.capHeight = overrideCapHeight;\r\n                    this.lineHeight = overrideLineHeight;\r\n                    this.spaceXadvance = overrideSpaceXAdvance;\r\n                    this.xHeight = overrideXHeight;\r\n                }\r\n                // Generate texture regions\r\n                const regionsData = [];\r\n                const glyphValues = Object.values(this.glyphs);\r\n                for (let i = 0; i < glyphValues.length; i++) {\r\n                    const values = Object.values(glyphValues[i]);\r\n                    for (let j = 0; j < values.length; j++) {\r\n                        const region = {\r\n                            id: values[j].id,\r\n                            left: values[j].srcX,\r\n                            top: values[j].srcY,\r\n                            width: values[j].width,\r\n                            height: values[j].height,\r\n                            xoffset: values[j].xoffset,\r\n                            yoffset: values[j].yoffset,\r\n                            xadvance: values[j].xadvance,\r\n                            page: imagePaths[values[j].page],\r\n                            pageId: values[j].page\r\n                        };\r\n                        regionsData.push(region);\r\n                    }\r\n                }\r\n                const pages = [];\r\n                for (let i = 0; i < pageCount; i++) {\r\n                    const texture = yield Texture_1.Texture.load(gl, concatAndResolveUrl(this.fontFile, `../${imagePaths[i]}`));\r\n                    const invTexWidth = 1 / texture.width;\r\n                    const invTexHeight = 1 / texture.height;\r\n                    pages.push({\r\n                        texture,\r\n                        invTexWidth,\r\n                        invTexHeight\r\n                    });\r\n                }\r\n                this.regions = [];\r\n                for (let regionData of regionsData) {\r\n                    const left = regionData.left;\r\n                    const top = regionData.top;\r\n                    const width = regionData.width;\r\n                    const height = regionData.height;\r\n                    const { texture, invTexWidth, invTexHeight } = pages[regionData.pageId];\r\n                    const region = new TextureRegion_1.TextureRegion(texture, left, top, width, height, regionData, invTexWidth, invTexHeight);\r\n                    region.originalWidth = width;\r\n                    region.originalHeight = height;\r\n                    region.offsetX = 0;\r\n                    region.offsetY = 0;\r\n                    this.regions.push(region);\r\n                }\r\n            }\r\n            catch (ex) {\r\n                console.error(ex);\r\n            }\r\n        });\r\n        this.setGlyphRegion = (glyph, region) => {\r\n            const texture = region.texture;\r\n            const invTexWidth = 1 / texture.width;\r\n            const invTexHeight = 1 / texture.height;\r\n            let offsetX = 0, offsetY = 0;\r\n            const u = region.u;\r\n            const v = region.v;\r\n            const regionWidth = region.originalWidth;\r\n            const regionHeight = region.originalHeight;\r\n            // if (region instanceof AtlasRegion) {\r\n            //    // Compensate for whitespace stripped from left and top edges.\r\n            //    AtlasRegion atlasRegion = (AtlasRegion)region;\r\n            //    offsetX = atlasRegion.offsetX;\r\n            //    offsetY = atlasRegion.originalHeight - atlasRegion.packedHeight - atlasRegion.offsetY;\r\n            // }\r\n            let x = glyph.srcX;\r\n            let x2 = glyph.srcX + glyph.width;\r\n            let y = glyph.srcY;\r\n            let y2 = glyph.srcY + glyph.height;\r\n            // Shift glyph for left and top edge stripped whitespace. Clip glyph for right and bottom edge stripped whitespace.\r\n            // Note if the font region has padding, whitespace stripping must not be used.\r\n            if (offsetX > 0) {\r\n                x -= offsetX;\r\n                if (x < 0) {\r\n                    glyph.width += x;\r\n                    glyph.xoffset -= x;\r\n                    x = 0;\r\n                }\r\n                x2 -= offsetX;\r\n                if (x2 > regionWidth) {\r\n                    glyph.width -= x2 - regionWidth;\r\n                    x2 = regionWidth;\r\n                }\r\n            }\r\n            if (offsetY > 0) {\r\n                y -= offsetY;\r\n                if (y < 0) {\r\n                    glyph.height += y;\r\n                    if (glyph.height < 0)\r\n                        glyph.height = 0;\r\n                    y = 0;\r\n                }\r\n                y2 -= offsetY;\r\n                if (y2 > regionHeight) {\r\n                    const amount = y2 - regionHeight;\r\n                    glyph.height -= amount;\r\n                    glyph.yoffset += amount;\r\n                    y2 = regionHeight;\r\n                }\r\n            }\r\n            glyph.u = u + x * invTexWidth;\r\n            glyph.u2 = u + x2 * invTexWidth;\r\n            if (this.flipped) {\r\n                glyph.v = v + y * invTexHeight;\r\n                glyph.v2 = v + y2 * invTexHeight;\r\n            }\r\n            else {\r\n                glyph.v2 = v + y * invTexHeight;\r\n                glyph.v = v + y2 * invTexHeight;\r\n            }\r\n        };\r\n        /** Sets the line height, which is the distance from one line of text to the next. */\r\n        this.setLineHeight = (height) => {\r\n            this.lineHeight = height * this.scaleY;\r\n            this.down = this.flipped ? this.lineHeight : -this.lineHeight;\r\n        };\r\n        this.setGlyph = (ch, glyph) => {\r\n            let page = this.glyphs[ch / Glyph_1.PAGE_SIZE];\r\n            if (!page) {\r\n                page = new Array(Glyph_1.PAGE_SIZE);\r\n                this.glyphs[ch / Glyph_1.PAGE_SIZE] = page;\r\n                // this.glyphs[ch / PAGE_SIZE] = page = new Glyph[PAGE_SIZE];\r\n            }\r\n            page[ch & (Glyph_1.PAGE_SIZE - 1)] = glyph;\r\n        };\r\n        this.getFirstGlyph = () => {\r\n            const glyphValues = Object.values(this.glyphs);\r\n            for (let i = 0; i < glyphValues.length; i++) {\r\n                const page = glyphValues[i];\r\n                if (!page)\r\n                    continue;\r\n                for (let j = 0; j < page.length; j++) {\r\n                    const glyph = page[j];\r\n                    if (!glyph || glyph.height === 0 || glyph.width === 0)\r\n                        continue;\r\n                    return glyph;\r\n                }\r\n            }\r\n        };\r\n        /** Returns true if the font has the glyph, or if the font has a {@link #missingGlyph}. */\r\n        this.hasGlyph = (ch) => {\r\n            if (this.missingGlyph)\r\n                return true;\r\n            return this.getGlyph(ch) != null;\r\n        };\r\n        /** Returns the glyph for the specified character, or null if no such glyph exists. Note that\r\n         * {@link #getGlyphs(GlyphRun, CharSequence, int, int, Glyph)} should be be used to shape a string of characters into a list\r\n         * of glyphs. */\r\n        this.getGlyph = (ch) => {\r\n            const page = this.glyphs[ch.charCodeAt(0) / Glyph_1.PAGE_SIZE];\r\n            if (page != null)\r\n                return page[ch.charCodeAt(0) & (Glyph_1.PAGE_SIZE - 1)];\r\n            return undefined;\r\n        };\r\n        /** Using the specified string, populates the glyphs and positions of the specified glyph run.\r\n         * @param str Characters to convert to glyphs. Will not contain newline or color tags. May contain \"[[\" for an escaped left\r\n         *           square bracket.\r\n         * @param lastGlyph The glyph immediately before this run, or null if this is run is the first on a line of text. Used tp\r\n         *           apply kerning between the specified glyph and the first glyph in this run. */\r\n        this.getGlyphs = (run, str, start, end, lastGlyph) => {\r\n            const max = end - start;\r\n            if (max === 0)\r\n                return;\r\n            let markupEnabled = this.markupEnabled;\r\n            const scaleX = this.scaleX;\r\n            const glyphs = run.glyphs;\r\n            const xAdvances = run.xAdvances;\r\n            // Guess at number of glyphs needed.\r\n            // glyphs.ensureCapacity(max);\r\n            // run.xAdvances.ensureCapacity(max + 1);\r\n            do {\r\n                const ch = str.charAt(start++);\r\n                if (ch === '\\r')\r\n                    continue; // Ignore.\r\n                let glyph = this.getGlyph(ch);\r\n                if (!glyph) {\r\n                    if (!this.missingGlyph)\r\n                        continue;\r\n                    glyph = this.missingGlyph;\r\n                }\r\n                glyphs.push(glyph);\r\n                xAdvances.push(!lastGlyph // First glyph on line, adjust the position so it isn't drawn left of 0.\r\n                    ? glyph.fixedWidth\r\n                        ? 0\r\n                        : -glyph.xoffset * scaleX - this.padLeft\r\n                    : (lastGlyph.xadvance + lastGlyph.getKerning(ch)) * scaleX);\r\n                lastGlyph = glyph;\r\n                // \"[[\" is an escaped left square bracket, skip second character.\r\n                if (markupEnabled && ch === '[' && start < end && str.charAt(start) === '[')\r\n                    start++;\r\n            } while (start < end);\r\n            if (lastGlyph) {\r\n                const lastGlyphWidth = lastGlyph.fixedWidth\r\n                    ? lastGlyph.xadvance * scaleX\r\n                    : (lastGlyph.width + lastGlyph.xoffset) * scaleX - this.padRight;\r\n                xAdvances.push(lastGlyphWidth);\r\n            }\r\n        };\r\n        /** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\r\n         * (typically) moving toward the beginning of the glyphs array. */\r\n        this.getWrapIndex = (glyphs, start) => {\r\n            let i = start - 1;\r\n            const glyphsItems = glyphs;\r\n            let ch = glyphsItems[i].id;\r\n            if (this.isWhitespace(ch + ''))\r\n                return i;\r\n            if (this.isBreakChar(ch + ''))\r\n                i--;\r\n            for (; i > 0; i--) {\r\n                ch = glyphsItems[i].id;\r\n                if (this.isWhitespace(ch + '') || this.isBreakChar(ch + '')) {\r\n                    return i + 1;\r\n                }\r\n            }\r\n            return 0;\r\n        };\r\n        this.isBreakChar = (c) => {\r\n            if (!this.breakChars)\r\n                return false;\r\n            const character = String.fromCharCode(parseInt(c));\r\n            for (let i = 0; i < this.breakChars.length; i++) {\r\n                if (character === this.breakChars[i])\r\n                    return true;\r\n            }\r\n            return false;\r\n        };\r\n        this.isWhitespace = (c) => {\r\n            const character = String.fromCharCode(parseInt(c));\r\n            switch (character) {\r\n                case '\\n':\r\n                case '\\r':\r\n                case '\\t':\r\n                case ' ':\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        };\r\n        /** Returns the image path for the texture page at the given index (the \"id\" in the BMFont file). */\r\n        this.getImagePath = (index) => {\r\n            return this.imagePaths[index];\r\n        };\r\n        this.getImagePaths = () => {\r\n            return this.imagePaths;\r\n        };\r\n        /** Scales the font by the specified amounts on both axes\r\n         * <p>\r\n         * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}.\r\n         * The default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.\r\n         * @throws IllegalArgumentException if scaleX or scaleY is zero. */\r\n        this.setScale = (scaleX, scaleY) => {\r\n            if (scaleX === 0 || scaleY === 0)\r\n                return;\r\n            const x = scaleX / this.scaleX;\r\n            const y = scaleY / this.scaleY;\r\n            this.lineHeight *= y;\r\n            this.spaceXadvance *= x;\r\n            this.xHeight *= y;\r\n            this.capHeight *= y;\r\n            this.ascent *= y;\r\n            this.descent *= y;\r\n            this.down *= y;\r\n            this.padLeft *= x;\r\n            this.padRight *= x;\r\n            this.padTop *= y;\r\n            this.padBottom *= y;\r\n            this.scaleX = scaleX;\r\n            this.scaleY = scaleY;\r\n        };\r\n        /** Sets the font's scale relative to the current scale.\r\n         * @see #setScale(float, float)\r\n         * @throws IllegalArgumentException if the resulting scale is zero. */\r\n        this.scale = (amount) => {\r\n            this.setScale(this.scaleX + amount, this.scaleY + amount);\r\n        };\r\n        this.fontFile = fontFile;\r\n        this.flipped = flip;\r\n    }\r\n    /** Scales the font by the specified amount in both directions.\r\n     * @see #setScale(float, float)\r\n     * @throws IllegalArgumentException if scaleX or scaleY is zero. */\r\n    setXYScale(scaleXY) {\r\n        this.setScale(scaleXY, scaleXY);\r\n    }\r\n}\r\nexports.BitmapFontData = BitmapFontData;\r\nclass StringTokenizer {\r\n    constructor(str, delimitter) {\r\n        this.strArray = [];\r\n        this.currentIndex = 0;\r\n        const strings = str.split(/\\s+/);\r\n        for (let i = 0; i < strings.length; i++) {\r\n            const st = strings[i];\r\n            this.strArray.push(...st.split(delimitter));\r\n        }\r\n    }\r\n    hasMoreTokens() {\r\n        return this.currentIndex >= this.strArray.length;\r\n    }\r\n    nextToken() {\r\n        return this.strArray[this.currentIndex++];\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}