{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Shader = void 0;\n\nclass Shader {\n  constructor(context, vertexShader, fragmentShader) {\n    this.vertexShader = vertexShader;\n    this.fragmentShader = fragmentShader;\n    this.vs = null;\n    this.fs = null;\n    this.program = null;\n    this.tmp2x2 = new Float32Array(2 * 2);\n    this.tmp3x3 = new Float32Array(3 * 3);\n    this.tmp4x4 = new Float32Array(4 * 4);\n    this.vsSource = vertexShader;\n    this.fsSource = fragmentShader;\n    this.context = context;\n    this.compile();\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  getVertexShader() {\n    return this.vertexShader;\n  }\n\n  getFragmentShader() {\n    return this.fragmentShader;\n  }\n\n  getVertexShaderSource() {\n    return this.vsSource;\n  }\n\n  getFragmentSource() {\n    return this.fsSource;\n  }\n\n  compile() {\n    let gl = this.context;\n\n    try {\n      this.vs = this.compileShader(gl.VERTEX_SHADER, this.vertexShader);\n      this.fs = this.compileShader(gl.FRAGMENT_SHADER, this.fragmentShader);\n      this.program = this.compileProgram(this.vs, this.fs);\n    } catch (e) {\n      this.dispose();\n      throw e;\n    }\n  }\n\n  compileShader(type, source) {\n    let gl = this.context;\n    let shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      let error = \"Couldn't compile shader: \" + gl.getShaderInfoLog(shader);\n      gl.deleteShader(shader);\n      if (!gl.isContextLost()) throw new Error(error);\n    }\n\n    return shader;\n  }\n\n  compileProgram(vs, fs) {\n    let gl = this.context;\n    let program = gl.createProgram();\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      let error = \"Couldn't compile shader program: \" + gl.getProgramInfoLog(program);\n      gl.deleteProgram(program);\n      if (!gl.isContextLost()) throw new Error(error);\n    }\n\n    return program;\n  }\n\n  restore() {\n    this.compile();\n  }\n\n  bind() {\n    this.context.useProgram(this.program);\n  }\n\n  unbind() {\n    this.context.useProgram(null);\n  }\n\n  setUniformi(uniform, value) {\n    this.context.uniform1i(this.getUniformLocation(uniform), value);\n  }\n\n  setUniformf(uniform, value) {\n    this.context.uniform1f(this.getUniformLocation(uniform), value);\n  }\n\n  setUniform2f(uniform, value, value2) {\n    this.context.uniform2f(this.getUniformLocation(uniform), value, value2);\n  }\n\n  setUniform3f(uniform, value, value2, value3) {\n    this.context.uniform3f(this.getUniformLocation(uniform), value, value2, value3);\n  }\n\n  setUniform4f(uniform, value, value2, value3, value4) {\n    this.context.uniform4f(this.getUniformLocation(uniform), value, value2, value3, value4);\n  }\n\n  setUniform2x2f(uniform, value) {\n    let gl = this.context;\n    this.tmp2x2.set(value);\n    gl.uniformMatrix2fv(this.getUniformLocation(uniform), false, this.tmp2x2);\n  }\n\n  setUniform3x3f(uniform, value) {\n    let gl = this.context;\n    this.tmp3x3.set(value);\n    gl.uniformMatrix3fv(this.getUniformLocation(uniform), false, this.tmp3x3);\n  }\n\n  setUniform4x4f(uniform, value) {\n    let gl = this.context;\n    this.tmp4x4.set(value);\n    gl.uniformMatrix4fv(this.getUniformLocation(uniform), false, this.tmp4x4);\n  }\n\n  getUniformLocation(uniform) {\n    let gl = this.context;\n    let location = gl.getUniformLocation(this.program, uniform);\n    if (!location && !gl.isContextLost()) throw new Error(`Couldn't find location for uniform ${uniform}`);\n    return location;\n  }\n\n  getAttributeLocation(attribute) {\n    let gl = this.context;\n    let location = gl.getAttribLocation(this.program, attribute);\n    if (location === -1 && !gl.isContextLost()) throw new Error(`Couldn't find location for attribute ${attribute}`);\n    return location;\n  }\n\n  dispose() {\n    let gl = this.context;\n\n    if (this.vs) {\n      gl.deleteShader(this.vs);\n      this.vs = null;\n    }\n\n    if (this.fs) {\n      gl.deleteShader(this.fs);\n      this.fs = null;\n    }\n\n    if (this.program) {\n      gl.deleteProgram(this.program);\n      this.program = null;\n    }\n  }\n\n  static newColoredTextured(context) {\n    let vs = `\n         attribute vec4 ${Shader.POSITION};\n         attribute vec4 ${Shader.COLOR};\n         attribute vec2 ${Shader.TEXCOORDS};\n         uniform mat4 ${Shader.MVP_MATRIX};\n         varying vec4 v_color;\n         varying vec2 v_texCoords;\n \n         void main () {\n           v_color = ${Shader.COLOR};\n           v_texCoords = ${Shader.TEXCOORDS};\n           gl_Position = ${Shader.MVP_MATRIX} * ${Shader.POSITION};\n         }\n       `;\n    let fs = `\n         #ifdef GL_ES\n           #define LOWP lowp\n           precision mediump float;\n         #else\n           #define LOWP\n         #endif\n         varying LOWP vec4 v_color;\n         varying vec2 v_texCoords;\n         uniform sampler2D u_texture;\n \n         void main () {\n           gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n         }\n       `;\n    return new Shader(context, vs, fs);\n  }\n\n  static newTwoColoredTextured(context) {\n    let vs = `\n         attribute vec4 ${Shader.POSITION};\n         attribute vec4 ${Shader.COLOR};\n         attribute vec4 ${Shader.COLOR2};\n         attribute vec2 ${Shader.TEXCOORDS};\n         uniform mat4 ${Shader.MVP_MATRIX};\n         varying vec4 v_light;\n         varying vec4 v_dark;\n         varying vec2 v_texCoords;\n \n         void main () {\n           v_light = ${Shader.COLOR};\n           v_dark = ${Shader.COLOR2};\n           v_texCoords = ${Shader.TEXCOORDS};\n           gl_Position = ${Shader.MVP_MATRIX} * ${Shader.POSITION};\n         }\n       `;\n    let fs = `\n         #ifdef GL_ES\n           #define LOWP lowp\n           precision mediump float;\n         #else\n           #define LOWP\n         #endif\n         varying LOWP vec4 v_light;\n         varying LOWP vec4 v_dark;\n         varying vec2 v_texCoords;\n         uniform sampler2D u_texture;\n \n         void main () {\n           vec4 texColor = texture2D(u_texture, v_texCoords);\n           gl_FragColor.a = texColor.a * v_light.a;\n           gl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n         }\n       `;\n    return new Shader(context, vs, fs);\n  }\n\n  static newColored(context) {\n    let vs = `\n         attribute vec4 ${Shader.POSITION};\n         attribute vec4 ${Shader.COLOR};\n         uniform mat4 ${Shader.MVP_MATRIX};\n         varying vec4 v_color;\n \n         void main () {\n           v_color = ${Shader.COLOR};\n           gl_Position = ${Shader.MVP_MATRIX} * ${Shader.POSITION};\n         }\n       `;\n    let fs = `\n         #ifdef GL_ES\n           #define LOWP lowp\n           precision mediump float;\n         #else\n           #define LOWP\n         #endif\n         varying LOWP vec4 v_color;\n \n         void main () {\n           gl_FragColor = v_color;\n         }\n       `;\n    return new Shader(context, vs, fs);\n  }\n\n}\n\nexports.Shader = Shader;\nShader.MVP_MATRIX = 'u_projTrans';\nShader.POSITION = 'a_position';\nShader.COLOR = 'a_color';\nShader.COLOR2 = 'a_color2';\nShader.TEXCOORDS = 'a_texCoords';\nShader.SAMPLER = 'u_texture';","map":{"version":3,"names":["Object","defineProperty","exports","value","Shader","constructor","context","vertexShader","fragmentShader","vs","fs","program","tmp2x2","Float32Array","tmp3x3","tmp4x4","vsSource","fsSource","compile","getProgram","getVertexShader","getFragmentShader","getVertexShaderSource","getFragmentSource","gl","compileShader","VERTEX_SHADER","FRAGMENT_SHADER","compileProgram","e","dispose","type","source","shader","createShader","shaderSource","getShaderParameter","COMPILE_STATUS","error","getShaderInfoLog","deleteShader","isContextLost","Error","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","restore","bind","useProgram","unbind","setUniformi","uniform","uniform1i","getUniformLocation","setUniformf","uniform1f","setUniform2f","value2","uniform2f","setUniform3f","value3","uniform3f","setUniform4f","value4","uniform4f","setUniform2x2f","set","uniformMatrix2fv","setUniform3x3f","uniformMatrix3fv","setUniform4x4f","uniformMatrix4fv","location","getAttributeLocation","attribute","getAttribLocation","newColoredTextured","POSITION","COLOR","TEXCOORDS","MVP_MATRIX","newTwoColoredTextured","COLOR2","newColored","SAMPLER"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/Shader.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Shader = void 0;\nclass Shader {\n    constructor(context, vertexShader, fragmentShader) {\n        this.vertexShader = vertexShader;\n        this.fragmentShader = fragmentShader;\n        this.vs = null;\n        this.fs = null;\n        this.program = null;\n        this.tmp2x2 = new Float32Array(2 * 2);\n        this.tmp3x3 = new Float32Array(3 * 3);\n        this.tmp4x4 = new Float32Array(4 * 4);\n        this.vsSource = vertexShader;\n        this.fsSource = fragmentShader;\n        this.context = context;\n        this.compile();\n    }\n    getProgram() {\n        return this.program;\n    }\n    getVertexShader() {\n        return this.vertexShader;\n    }\n    getFragmentShader() {\n        return this.fragmentShader;\n    }\n    getVertexShaderSource() {\n        return this.vsSource;\n    }\n    getFragmentSource() {\n        return this.fsSource;\n    }\n    compile() {\n        let gl = this.context;\n        try {\n            this.vs = this.compileShader(gl.VERTEX_SHADER, this.vertexShader);\n            this.fs = this.compileShader(gl.FRAGMENT_SHADER, this.fragmentShader);\n            this.program = this.compileProgram(this.vs, this.fs);\n        }\n        catch (e) {\n            this.dispose();\n            throw e;\n        }\n    }\n    compileShader(type, source) {\n        let gl = this.context;\n        let shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            let error = \"Couldn't compile shader: \" + gl.getShaderInfoLog(shader);\n            gl.deleteShader(shader);\n            if (!gl.isContextLost())\n                throw new Error(error);\n        }\n        return shader;\n    }\n    compileProgram(vs, fs) {\n        let gl = this.context;\n        let program = gl.createProgram();\n        gl.attachShader(program, vs);\n        gl.attachShader(program, fs);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            let error = \"Couldn't compile shader program: \" + gl.getProgramInfoLog(program);\n            gl.deleteProgram(program);\n            if (!gl.isContextLost())\n                throw new Error(error);\n        }\n        return program;\n    }\n    restore() {\n        this.compile();\n    }\n    bind() {\n        this.context.useProgram(this.program);\n    }\n    unbind() {\n        this.context.useProgram(null);\n    }\n    setUniformi(uniform, value) {\n        this.context.uniform1i(this.getUniformLocation(uniform), value);\n    }\n    setUniformf(uniform, value) {\n        this.context.uniform1f(this.getUniformLocation(uniform), value);\n    }\n    setUniform2f(uniform, value, value2) {\n        this.context.uniform2f(this.getUniformLocation(uniform), value, value2);\n    }\n    setUniform3f(uniform, value, value2, value3) {\n        this.context.uniform3f(this.getUniformLocation(uniform), value, value2, value3);\n    }\n    setUniform4f(uniform, value, value2, value3, value4) {\n        this.context.uniform4f(this.getUniformLocation(uniform), value, value2, value3, value4);\n    }\n    setUniform2x2f(uniform, value) {\n        let gl = this.context;\n        this.tmp2x2.set(value);\n        gl.uniformMatrix2fv(this.getUniformLocation(uniform), false, this.tmp2x2);\n    }\n    setUniform3x3f(uniform, value) {\n        let gl = this.context;\n        this.tmp3x3.set(value);\n        gl.uniformMatrix3fv(this.getUniformLocation(uniform), false, this.tmp3x3);\n    }\n    setUniform4x4f(uniform, value) {\n        let gl = this.context;\n        this.tmp4x4.set(value);\n        gl.uniformMatrix4fv(this.getUniformLocation(uniform), false, this.tmp4x4);\n    }\n    getUniformLocation(uniform) {\n        let gl = this.context;\n        let location = gl.getUniformLocation(this.program, uniform);\n        if (!location && !gl.isContextLost())\n            throw new Error(`Couldn't find location for uniform ${uniform}`);\n        return location;\n    }\n    getAttributeLocation(attribute) {\n        let gl = this.context;\n        let location = gl.getAttribLocation(this.program, attribute);\n        if (location === -1 && !gl.isContextLost())\n            throw new Error(`Couldn't find location for attribute ${attribute}`);\n        return location;\n    }\n    dispose() {\n        let gl = this.context;\n        if (this.vs) {\n            gl.deleteShader(this.vs);\n            this.vs = null;\n        }\n        if (this.fs) {\n            gl.deleteShader(this.fs);\n            this.fs = null;\n        }\n        if (this.program) {\n            gl.deleteProgram(this.program);\n            this.program = null;\n        }\n    }\n    static newColoredTextured(context) {\n        let vs = `\n         attribute vec4 ${Shader.POSITION};\n         attribute vec4 ${Shader.COLOR};\n         attribute vec2 ${Shader.TEXCOORDS};\n         uniform mat4 ${Shader.MVP_MATRIX};\n         varying vec4 v_color;\n         varying vec2 v_texCoords;\n \n         void main () {\n           v_color = ${Shader.COLOR};\n           v_texCoords = ${Shader.TEXCOORDS};\n           gl_Position = ${Shader.MVP_MATRIX} * ${Shader.POSITION};\n         }\n       `;\n        let fs = `\n         #ifdef GL_ES\n           #define LOWP lowp\n           precision mediump float;\n         #else\n           #define LOWP\n         #endif\n         varying LOWP vec4 v_color;\n         varying vec2 v_texCoords;\n         uniform sampler2D u_texture;\n \n         void main () {\n           gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n         }\n       `;\n        return new Shader(context, vs, fs);\n    }\n    static newTwoColoredTextured(context) {\n        let vs = `\n         attribute vec4 ${Shader.POSITION};\n         attribute vec4 ${Shader.COLOR};\n         attribute vec4 ${Shader.COLOR2};\n         attribute vec2 ${Shader.TEXCOORDS};\n         uniform mat4 ${Shader.MVP_MATRIX};\n         varying vec4 v_light;\n         varying vec4 v_dark;\n         varying vec2 v_texCoords;\n \n         void main () {\n           v_light = ${Shader.COLOR};\n           v_dark = ${Shader.COLOR2};\n           v_texCoords = ${Shader.TEXCOORDS};\n           gl_Position = ${Shader.MVP_MATRIX} * ${Shader.POSITION};\n         }\n       `;\n        let fs = `\n         #ifdef GL_ES\n           #define LOWP lowp\n           precision mediump float;\n         #else\n           #define LOWP\n         #endif\n         varying LOWP vec4 v_light;\n         varying LOWP vec4 v_dark;\n         varying vec2 v_texCoords;\n         uniform sampler2D u_texture;\n \n         void main () {\n           vec4 texColor = texture2D(u_texture, v_texCoords);\n           gl_FragColor.a = texColor.a * v_light.a;\n           gl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n         }\n       `;\n        return new Shader(context, vs, fs);\n    }\n    static newColored(context) {\n        let vs = `\n         attribute vec4 ${Shader.POSITION};\n         attribute vec4 ${Shader.COLOR};\n         uniform mat4 ${Shader.MVP_MATRIX};\n         varying vec4 v_color;\n \n         void main () {\n           v_color = ${Shader.COLOR};\n           gl_Position = ${Shader.MVP_MATRIX} * ${Shader.POSITION};\n         }\n       `;\n        let fs = `\n         #ifdef GL_ES\n           #define LOWP lowp\n           precision mediump float;\n         #else\n           #define LOWP\n         #endif\n         varying LOWP vec4 v_color;\n \n         void main () {\n           gl_FragColor = v_color;\n         }\n       `;\n        return new Shader(context, vs, fs);\n    }\n}\nexports.Shader = Shader;\nShader.MVP_MATRIX = 'u_projTrans';\nShader.POSITION = 'a_position';\nShader.COLOR = 'a_color';\nShader.COLOR2 = 'a_color2';\nShader.TEXCOORDS = 'a_texCoords';\nShader.SAMPLER = 'u_texture';\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,MAAR,GAAiB,KAAK,CAAtB;;AACA,MAAMA,MAAN,CAAa;EACTC,WAAW,CAACC,OAAD,EAAUC,YAAV,EAAwBC,cAAxB,EAAwC;IAC/C,KAAKD,YAAL,GAAoBA,YAApB;IACA,KAAKC,cAAL,GAAsBA,cAAtB;IACA,KAAKC,EAAL,GAAU,IAAV;IACA,KAAKC,EAAL,GAAU,IAAV;IACA,KAAKC,OAAL,GAAe,IAAf;IACA,KAAKC,MAAL,GAAc,IAAIC,YAAJ,CAAiB,IAAI,CAArB,CAAd;IACA,KAAKC,MAAL,GAAc,IAAID,YAAJ,CAAiB,IAAI,CAArB,CAAd;IACA,KAAKE,MAAL,GAAc,IAAIF,YAAJ,CAAiB,IAAI,CAArB,CAAd;IACA,KAAKG,QAAL,GAAgBT,YAAhB;IACA,KAAKU,QAAL,GAAgBT,cAAhB;IACA,KAAKF,OAAL,GAAeA,OAAf;IACA,KAAKY,OAAL;EACH;;EACDC,UAAU,GAAG;IACT,OAAO,KAAKR,OAAZ;EACH;;EACDS,eAAe,GAAG;IACd,OAAO,KAAKb,YAAZ;EACH;;EACDc,iBAAiB,GAAG;IAChB,OAAO,KAAKb,cAAZ;EACH;;EACDc,qBAAqB,GAAG;IACpB,OAAO,KAAKN,QAAZ;EACH;;EACDO,iBAAiB,GAAG;IAChB,OAAO,KAAKN,QAAZ;EACH;;EACDC,OAAO,GAAG;IACN,IAAIM,EAAE,GAAG,KAAKlB,OAAd;;IACA,IAAI;MACA,KAAKG,EAAL,GAAU,KAAKgB,aAAL,CAAmBD,EAAE,CAACE,aAAtB,EAAqC,KAAKnB,YAA1C,CAAV;MACA,KAAKG,EAAL,GAAU,KAAKe,aAAL,CAAmBD,EAAE,CAACG,eAAtB,EAAuC,KAAKnB,cAA5C,CAAV;MACA,KAAKG,OAAL,GAAe,KAAKiB,cAAL,CAAoB,KAAKnB,EAAzB,EAA6B,KAAKC,EAAlC,CAAf;IACH,CAJD,CAKA,OAAOmB,CAAP,EAAU;MACN,KAAKC,OAAL;MACA,MAAMD,CAAN;IACH;EACJ;;EACDJ,aAAa,CAACM,IAAD,EAAOC,MAAP,EAAe;IACxB,IAAIR,EAAE,GAAG,KAAKlB,OAAd;IACA,IAAI2B,MAAM,GAAGT,EAAE,CAACU,YAAH,CAAgBH,IAAhB,CAAb;IACAP,EAAE,CAACW,YAAH,CAAgBF,MAAhB,EAAwBD,MAAxB;IACAR,EAAE,CAACC,aAAH,CAAiBQ,MAAjB;;IACA,IAAI,CAACT,EAAE,CAACY,kBAAH,CAAsBH,MAAtB,EAA8BT,EAAE,CAACa,cAAjC,CAAL,EAAuD;MACnD,IAAIC,KAAK,GAAG,8BAA8Bd,EAAE,CAACe,gBAAH,CAAoBN,MAApB,CAA1C;MACAT,EAAE,CAACgB,YAAH,CAAgBP,MAAhB;MACA,IAAI,CAACT,EAAE,CAACiB,aAAH,EAAL,EACI,MAAM,IAAIC,KAAJ,CAAUJ,KAAV,CAAN;IACP;;IACD,OAAOL,MAAP;EACH;;EACDL,cAAc,CAACnB,EAAD,EAAKC,EAAL,EAAS;IACnB,IAAIc,EAAE,GAAG,KAAKlB,OAAd;IACA,IAAIK,OAAO,GAAGa,EAAE,CAACmB,aAAH,EAAd;IACAnB,EAAE,CAACoB,YAAH,CAAgBjC,OAAhB,EAAyBF,EAAzB;IACAe,EAAE,CAACoB,YAAH,CAAgBjC,OAAhB,EAAyBD,EAAzB;IACAc,EAAE,CAACqB,WAAH,CAAelC,OAAf;;IACA,IAAI,CAACa,EAAE,CAACsB,mBAAH,CAAuBnC,OAAvB,EAAgCa,EAAE,CAACuB,WAAnC,CAAL,EAAsD;MAClD,IAAIT,KAAK,GAAG,sCAAsCd,EAAE,CAACwB,iBAAH,CAAqBrC,OAArB,CAAlD;MACAa,EAAE,CAACyB,aAAH,CAAiBtC,OAAjB;MACA,IAAI,CAACa,EAAE,CAACiB,aAAH,EAAL,EACI,MAAM,IAAIC,KAAJ,CAAUJ,KAAV,CAAN;IACP;;IACD,OAAO3B,OAAP;EACH;;EACDuC,OAAO,GAAG;IACN,KAAKhC,OAAL;EACH;;EACDiC,IAAI,GAAG;IACH,KAAK7C,OAAL,CAAa8C,UAAb,CAAwB,KAAKzC,OAA7B;EACH;;EACD0C,MAAM,GAAG;IACL,KAAK/C,OAAL,CAAa8C,UAAb,CAAwB,IAAxB;EACH;;EACDE,WAAW,CAACC,OAAD,EAAUpD,KAAV,EAAiB;IACxB,KAAKG,OAAL,CAAakD,SAAb,CAAuB,KAAKC,kBAAL,CAAwBF,OAAxB,CAAvB,EAAyDpD,KAAzD;EACH;;EACDuD,WAAW,CAACH,OAAD,EAAUpD,KAAV,EAAiB;IACxB,KAAKG,OAAL,CAAaqD,SAAb,CAAuB,KAAKF,kBAAL,CAAwBF,OAAxB,CAAvB,EAAyDpD,KAAzD;EACH;;EACDyD,YAAY,CAACL,OAAD,EAAUpD,KAAV,EAAiB0D,MAAjB,EAAyB;IACjC,KAAKvD,OAAL,CAAawD,SAAb,CAAuB,KAAKL,kBAAL,CAAwBF,OAAxB,CAAvB,EAAyDpD,KAAzD,EAAgE0D,MAAhE;EACH;;EACDE,YAAY,CAACR,OAAD,EAAUpD,KAAV,EAAiB0D,MAAjB,EAAyBG,MAAzB,EAAiC;IACzC,KAAK1D,OAAL,CAAa2D,SAAb,CAAuB,KAAKR,kBAAL,CAAwBF,OAAxB,CAAvB,EAAyDpD,KAAzD,EAAgE0D,MAAhE,EAAwEG,MAAxE;EACH;;EACDE,YAAY,CAACX,OAAD,EAAUpD,KAAV,EAAiB0D,MAAjB,EAAyBG,MAAzB,EAAiCG,MAAjC,EAAyC;IACjD,KAAK7D,OAAL,CAAa8D,SAAb,CAAuB,KAAKX,kBAAL,CAAwBF,OAAxB,CAAvB,EAAyDpD,KAAzD,EAAgE0D,MAAhE,EAAwEG,MAAxE,EAAgFG,MAAhF;EACH;;EACDE,cAAc,CAACd,OAAD,EAAUpD,KAAV,EAAiB;IAC3B,IAAIqB,EAAE,GAAG,KAAKlB,OAAd;IACA,KAAKM,MAAL,CAAY0D,GAAZ,CAAgBnE,KAAhB;IACAqB,EAAE,CAAC+C,gBAAH,CAAoB,KAAKd,kBAAL,CAAwBF,OAAxB,CAApB,EAAsD,KAAtD,EAA6D,KAAK3C,MAAlE;EACH;;EACD4D,cAAc,CAACjB,OAAD,EAAUpD,KAAV,EAAiB;IAC3B,IAAIqB,EAAE,GAAG,KAAKlB,OAAd;IACA,KAAKQ,MAAL,CAAYwD,GAAZ,CAAgBnE,KAAhB;IACAqB,EAAE,CAACiD,gBAAH,CAAoB,KAAKhB,kBAAL,CAAwBF,OAAxB,CAApB,EAAsD,KAAtD,EAA6D,KAAKzC,MAAlE;EACH;;EACD4D,cAAc,CAACnB,OAAD,EAAUpD,KAAV,EAAiB;IAC3B,IAAIqB,EAAE,GAAG,KAAKlB,OAAd;IACA,KAAKS,MAAL,CAAYuD,GAAZ,CAAgBnE,KAAhB;IACAqB,EAAE,CAACmD,gBAAH,CAAoB,KAAKlB,kBAAL,CAAwBF,OAAxB,CAApB,EAAsD,KAAtD,EAA6D,KAAKxC,MAAlE;EACH;;EACD0C,kBAAkB,CAACF,OAAD,EAAU;IACxB,IAAI/B,EAAE,GAAG,KAAKlB,OAAd;IACA,IAAIsE,QAAQ,GAAGpD,EAAE,CAACiC,kBAAH,CAAsB,KAAK9C,OAA3B,EAAoC4C,OAApC,CAAf;IACA,IAAI,CAACqB,QAAD,IAAa,CAACpD,EAAE,CAACiB,aAAH,EAAlB,EACI,MAAM,IAAIC,KAAJ,CAAW,sCAAqCa,OAAQ,EAAxD,CAAN;IACJ,OAAOqB,QAAP;EACH;;EACDC,oBAAoB,CAACC,SAAD,EAAY;IAC5B,IAAItD,EAAE,GAAG,KAAKlB,OAAd;IACA,IAAIsE,QAAQ,GAAGpD,EAAE,CAACuD,iBAAH,CAAqB,KAAKpE,OAA1B,EAAmCmE,SAAnC,CAAf;IACA,IAAIF,QAAQ,KAAK,CAAC,CAAd,IAAmB,CAACpD,EAAE,CAACiB,aAAH,EAAxB,EACI,MAAM,IAAIC,KAAJ,CAAW,wCAAuCoC,SAAU,EAA5D,CAAN;IACJ,OAAOF,QAAP;EACH;;EACD9C,OAAO,GAAG;IACN,IAAIN,EAAE,GAAG,KAAKlB,OAAd;;IACA,IAAI,KAAKG,EAAT,EAAa;MACTe,EAAE,CAACgB,YAAH,CAAgB,KAAK/B,EAArB;MACA,KAAKA,EAAL,GAAU,IAAV;IACH;;IACD,IAAI,KAAKC,EAAT,EAAa;MACTc,EAAE,CAACgB,YAAH,CAAgB,KAAK9B,EAArB;MACA,KAAKA,EAAL,GAAU,IAAV;IACH;;IACD,IAAI,KAAKC,OAAT,EAAkB;MACda,EAAE,CAACyB,aAAH,CAAiB,KAAKtC,OAAtB;MACA,KAAKA,OAAL,GAAe,IAAf;IACH;EACJ;;EACwB,OAAlBqE,kBAAkB,CAAC1E,OAAD,EAAU;IAC/B,IAAIG,EAAE,GAAI;AAClB,0BAA0BL,MAAM,CAAC6E,QAAS;AAC1C,0BAA0B7E,MAAM,CAAC8E,KAAM;AACvC,0BAA0B9E,MAAM,CAAC+E,SAAU;AAC3C,wBAAwB/E,MAAM,CAACgF,UAAW;AAC1C;AACA;AACA;AACA;AACA,uBAAuBhF,MAAM,CAAC8E,KAAM;AACpC,2BAA2B9E,MAAM,CAAC+E,SAAU;AAC5C,2BAA2B/E,MAAM,CAACgF,UAAW,MAAKhF,MAAM,CAAC6E,QAAS;AAClE;AACA,QAbQ;IAcA,IAAIvE,EAAE,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAdQ;IAeA,OAAO,IAAIN,MAAJ,CAAWE,OAAX,EAAoBG,EAApB,EAAwBC,EAAxB,CAAP;EACH;;EAC2B,OAArB2E,qBAAqB,CAAC/E,OAAD,EAAU;IAClC,IAAIG,EAAE,GAAI;AAClB,0BAA0BL,MAAM,CAAC6E,QAAS;AAC1C,0BAA0B7E,MAAM,CAAC8E,KAAM;AACvC,0BAA0B9E,MAAM,CAACkF,MAAO;AACxC,0BAA0BlF,MAAM,CAAC+E,SAAU;AAC3C,wBAAwB/E,MAAM,CAACgF,UAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuBhF,MAAM,CAAC8E,KAAM;AACpC,sBAAsB9E,MAAM,CAACkF,MAAO;AACpC,2BAA2BlF,MAAM,CAAC+E,SAAU;AAC5C,2BAA2B/E,MAAM,CAACgF,UAAW,MAAKhF,MAAM,CAAC6E,QAAS;AAClE;AACA,QAhBQ;IAiBA,IAAIvE,EAAE,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAjBQ;IAkBA,OAAO,IAAIN,MAAJ,CAAWE,OAAX,EAAoBG,EAApB,EAAwBC,EAAxB,CAAP;EACH;;EACgB,OAAV6E,UAAU,CAACjF,OAAD,EAAU;IACvB,IAAIG,EAAE,GAAI;AAClB,0BAA0BL,MAAM,CAAC6E,QAAS;AAC1C,0BAA0B7E,MAAM,CAAC8E,KAAM;AACvC,wBAAwB9E,MAAM,CAACgF,UAAW;AAC1C;AACA;AACA;AACA,uBAAuBhF,MAAM,CAAC8E,KAAM;AACpC,2BAA2B9E,MAAM,CAACgF,UAAW,MAAKhF,MAAM,CAAC6E,QAAS;AAClE;AACA,QAVQ;IAWA,IAAIvE,EAAE,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAZQ;IAaA,OAAO,IAAIN,MAAJ,CAAWE,OAAX,EAAoBG,EAApB,EAAwBC,EAAxB,CAAP;EACH;;AAzOQ;;AA2ObR,OAAO,CAACE,MAAR,GAAiBA,MAAjB;AACAA,MAAM,CAACgF,UAAP,GAAoB,aAApB;AACAhF,MAAM,CAAC6E,QAAP,GAAkB,YAAlB;AACA7E,MAAM,CAAC8E,KAAP,GAAe,SAAf;AACA9E,MAAM,CAACkF,MAAP,GAAgB,UAAhB;AACAlF,MAAM,CAAC+E,SAAP,GAAmB,aAAnB;AACA/E,MAAM,CAACoF,OAAP,GAAiB,WAAjB"},"metadata":{},"sourceType":"script"}