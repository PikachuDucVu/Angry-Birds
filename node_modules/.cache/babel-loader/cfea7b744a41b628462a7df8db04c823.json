{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"D:/projects/test-game/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitmapFontCache = void 0;\n\nvar GlyphLayout_1 = require(\"./GlyphLayout\");\n\nvar NumberUtils_1 = require(\"./NumberUtils\");\n\nvar Utils_1 = require(\"./Utils\");\n\nvar BitmapFontCache = /*#__PURE__*/function () {\n  /** @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */\n  function BitmapFontCache(font, integer) {\n    var _this = this;\n\n    _classCallCheck(this, BitmapFontCache);\n\n    this.tempColor = new Utils_1.Color(1, 1, 1, 1);\n    this.drawingTexts = [];\n    this.layouts = [];\n    this.pooledLayouts = [];\n    this.color = new Utils_1.Color(1, 1, 1, 1);\n    /** Sets the position of the text, relative to the position when the cached text was created.\n     * @param x The x coordinate\n     * @param y The y coordinate */\n\n    this.setPosition = function (x, y) {\n      _this.translate(x - _this.x, y - _this.y);\n    };\n    /** Sets the position of the text, relative to its current position.\n     * @param xAmount The amount in x to move the text\n     * @param yAmount The amount in y to move the text */\n\n\n    this.translate = function (xAmount, yAmount) {\n      if (xAmount === 0 && yAmount === 0) return;\n\n      if (_this.integer) {\n        xAmount = Math.round(xAmount);\n        yAmount = Math.round(yAmount);\n      }\n\n      _this.x += xAmount;\n      _this.y += yAmount;\n      var pageVertices = _this.pageVertices;\n\n      for (var i = 0, n = pageVertices.length; i < n; i++) {\n        var vertices = pageVertices[i];\n\n        for (var ii = 0, nn = _this.idx[i]; ii < nn; ii += 5) {\n          vertices[ii] += xAmount;\n          vertices[ii + 1] += yAmount;\n        }\n      }\n    };\n    /** Tints all text currently in the cache. Does not affect subsequently added text. */\n    // public tint = (tint: Color) => {\n    //    const newTint: number = tint.toFloatBits();\n    //    if (this.currentTint == newTint) return;\n    //    this.currentTint = newTint;\n    //    const pageVertices: number[][] = this.pageVertices;\n    //    const tempColor: Color = this.tempColor;\n    //    const tempGlyphCount: number[] = this.tempGlyphCount;\n    //    for (let i = 0; i < tempGlyphCount.length; i++) {\n    //       tempGlyphCount[i] = 0;\n    //    }\n    //    for (let i = 0, n = this.layouts.length; i < n; i++) {\n    //       const layout: GlyphLayout = this.layouts[i];\n    //       const colors: number[] = layout.colors;\n    //       let colorsIndex = 0,\n    //          nextColorGlyphIndex = 0,\n    //          glyphIndex = 0;\n    //       let lastColorFloatBits = 0;\n    //       for (let ii = 0, nn = layout.runs.length; ii < nn; ii++) {\n    //          const run: GlyphRun = layout.runs[ii];\n    //          const glyphs: Glyph[] = run.glyphs;\n    //          for (let iii = 0, nnn = run.glyphs.length; iii < nnn; iii++) {\n    //             if (glyphIndex++ === nextColorGlyphIndex) {\n    //                Color.abgr8888ToColor(tempColor, colors[++colorsIndex]);\n    //                lastColorFloatBits = tempColor.mul(tint).toFloatBits();\n    //                nextColorGlyphIndex = ++colorsIndex < colors.length ? colors[colorsIndex] : -1;\n    //             }\n    //             const page: number = glyphs[iii].page;\n    //             const offset = tempGlyphCount[page] * 20 + 2;\n    //             tempGlyphCount[page]++;\n    //             const vertices: number[] = pageVertices[page];\n    //             vertices[offset] = lastColorFloatBits;\n    //             vertices[offset + 5] = lastColorFloatBits;\n    //             vertices[offset + 10] = lastColorFloatBits;\n    //             vertices[offset + 15] = lastColorFloatBits;\n    //          }\n    //       }\n    //    }\n    // };\n\n    /** Sets the alpha component of all text currently in the cache. Does not affect subsequently added text. */\n    // public setAlphas = (alpha: number) => {\n    //    const alphaBits: number = (254 * alpha) << 24;\n    //    let prev = 0,\n    //       newColor = 0;\n    //    for (let j = 0, length = this.pageVertices.length; j < length; j++) {\n    //       const vertices: number[] = this.pageVertices[j];\n    //       for (let i = 2, n = this.idx[j]; i < n; i += 5) {\n    //          const c: number = vertices[i];\n    //          if (c == prev && i != 2) {\n    //             vertices[i] = newColor;\n    //          } else {\n    //             prev = c;\n    //             let rgba = NumberUtils.floatToIntColor(c);\n    //             rgba = (rgba & 0x00ffffff) | alphaBits;\n    //             newColor = NumberUtils.intToFloatColor(rgba);\n    //             vertices[i] = newColor;\n    //          }\n    //       }\n    //    }\n    // };\n\n\n    this.setColors = function (r, g, b, a) {\n      var intBits = 255 << 24 | 255 * b << 16 | 255 * g << 8 | 255 * r;\n      var value = NumberUtils_1.NumberUtil.intToFloatColor(intBits);\n\n      for (var j = 0, length = _this.pageVertices.length; j < length; j++) {\n        var vertices = _this.pageVertices[j];\n\n        for (var i = 2, n = _this.idx[j]; i < n; i += 5) {\n          vertices[i] = value;\n        }\n      }\n    };\n    /** Returns the color used for subsequently added text. Modifying the color affects text subsequently added to the cache, but\n     * does not affect existing text currently in the cache. */\n\n\n    this.getColor = function () {\n      return _this.color;\n    };\n    /** A convenience method for setting the cache color. The color can also be set by modifying {@link #getColor()}. */\n\n\n    this.setColor = function (r, g, b, a) {\n      _this.color.set(r, g, b, a);\n    };\n    /** Removes all glyphs in the cache. */\n\n\n    this.clear = function () {\n      _this.x = 0;\n      _this.y = 0;\n      Utils_1.Pools.freeAll('GlyphLayout', _this.pooledLayouts);\n      _this.pooledLayouts.length = 0;\n      _this.layouts.length = 0;\n\n      for (var i = 0, n = _this.idx.length; i < n; i++) {\n        if (_this.pageGlyphIndices != null) _this.pageGlyphIndices[i].length = 0;\n        _this.idx[i] = 0;\n      }\n    };\n\n    this.requireGlyphs = function (layout) {\n      if (_this.pageVertices.length === 1) {\n        // Simple if we just have one page.\n        _this.requirePageGlyphs(0, layout.glyphCount);\n      } else {\n        var tempGlyphCount = _this.tempGlyphCount;\n\n        for (var i = 0; i < tempGlyphCount.length; i++) {\n          tempGlyphCount[i] = 0;\n        } // Determine # of glyphs in each page.\n\n\n        for (var _i = 0, n = layout.runs.length; _i < n; _i++) {\n          var glyphs = layout.runs[_i].glyphs;\n          var glyphItems = glyphs;\n\n          for (var ii = 0, nn = glyphs.length; ii < nn; ii++) {\n            tempGlyphCount[glyphItems[ii].page]++;\n          }\n        } // Require that many for each page.\n\n\n        for (var _i2 = 0, _n = tempGlyphCount.length; _i2 < _n; _i2++) {\n          _this.requirePageGlyphs(_i2, tempGlyphCount[_i2]);\n        }\n      }\n    };\n\n    this.requirePageGlyphs = function (page, glyphCount) {\n      // if (this.pageGlyphIndices != null) {\n      //    if (glyphCount > this.pageGlyphIndices[page].length)\n      //       this.pageGlyphIndices[page].ensureCapacity(glyphCount - this.pageGlyphIndices[page].length);\n      // }\n      var vertexCount = _this.idx[page] + glyphCount * 20;\n      var vertices = _this.pageVertices[page];\n\n      if (!vertices) {\n        _this.pageVertices[page] = new Array(vertexCount);\n      } else if (vertices.length < vertexCount) {\n        var newVertices = new Array(vertexCount);\n        Utils_1.Utils.arrayCopy(vertices, 0, newVertices, 0, _this.idx[page]);\n        _this.pageVertices[page] = newVertices;\n      }\n    };\n\n    this.setPageCount = function (pageCount) {\n      var newPageVertices = new Array(pageCount).fill([]);\n      Utils_1.Utils.arrayCopy(_this.pageVertices, 0, newPageVertices, 0, _this.pageVertices.length);\n      _this.pageVertices = _toConsumableArray(newPageVertices);\n      var newIdx = new Array(pageCount);\n      Utils_1.Utils.arrayCopy(_this.idx, 0, newIdx, 0, _this.idx.length);\n      _this.idx = newIdx;\n      var newPageGlyphIndices = new Array(pageCount);\n      var pageGlyphIndicesLength = 0;\n\n      if (_this.pageGlyphIndices != null) {\n        pageGlyphIndicesLength = _this.pageGlyphIndices.length;\n        Utils_1.Utils.arrayCopy(_this.pageGlyphIndices, 0, newPageGlyphIndices, 0, _this.pageGlyphIndices.length);\n      }\n\n      for (var i = pageGlyphIndicesLength; i < pageCount; i++) {\n        newPageGlyphIndices[i] = [];\n      }\n\n      _this.pageGlyphIndices = newPageGlyphIndices;\n      _this.tempGlyphCount = new Array(pageCount);\n    };\n\n    this.addToCache = function (layout, x, y) {\n      var runCount = layout.runs.length;\n      if (runCount === 0) return; // Check if the number of font pages has changed.\n\n      if (_this.pageVertices.length < _this.font.regions.length) _this.setPageCount(_this.font.regions.length);\n\n      _this.layouts.push(layout);\n\n      _this.requireGlyphs(layout);\n\n      var colors = layout.colors;\n      var colorsIndex = 0,\n          nextColorGlyphIndex = 0,\n          glyphIndex = 0;\n      var lastColorFloatBits = 0;\n      _this.drawingTexts.length = 0;\n\n      for (var i = 0; i < runCount; i++) {\n        var run = layout.runs[i];\n        var glyphs = run.glyphs;\n        var xAdvances = run.xAdvances;\n        var gx = x + run.x,\n            gy = y + run.y;\n\n        for (var ii = 0, nn = run.glyphs.length; ii < nn; ii++) {\n          if (glyphIndex++ === nextColorGlyphIndex) {\n            lastColorFloatBits = NumberUtils_1.NumberUtil.intToFloatColor(colors[++colorsIndex]);\n            nextColorGlyphIndex = ++colorsIndex < colors.length ? colors[colorsIndex] : -1;\n          }\n\n          gx += xAdvances[ii];\n\n          _this.drawingTexts.push(glyphs[ii].id);\n\n          _this.addGlyph(glyphs[ii], gx, gy, lastColorFloatBits);\n        }\n      }\n\n      var whiteIntBits = 255 << 24 | 255 << 16 | 255 << 8 | 255;\n      _this.currentTint = NumberUtils_1.NumberUtil.intToFloatColor(whiteIntBits); // Cached glyphs have changed, reset the current tint.\n    };\n\n    this.addGlyph = function (glyph, x, y, color) {\n      var scaleX = _this.font.data.scaleX,\n          scaleY = _this.font.data.scaleY;\n      x += glyph.xoffset * scaleX;\n      y += glyph.yoffset * scaleY;\n      var width = glyph.width * scaleX,\n          height = glyph.height * scaleY;\n      var u = glyph.u,\n          u2 = glyph.u2,\n          v = glyph.v,\n          v2 = glyph.v2;\n\n      if (_this.integer) {\n        x = Math.round(x);\n        y = Math.round(y);\n        width = Math.round(width);\n        height = Math.round(height);\n      }\n\n      var x2 = x + width,\n          y2 = y + height;\n      var page = glyph.page;\n      var idx = _this.idx[page];\n      _this.idx[page] += 20;\n      if (_this.pageGlyphIndices != null) _this.pageGlyphIndices[page].push(_this.glyphCount++);\n      var vertices = _this.pageVertices[page];\n      vertices[idx++] = x;\n      vertices[idx++] = y;\n      vertices[idx++] = color;\n      vertices[idx++] = u;\n      vertices[idx++] = v;\n      vertices[idx++] = x;\n      vertices[idx++] = y2;\n      vertices[idx++] = color;\n      vertices[idx++] = u;\n      vertices[idx++] = v2;\n      vertices[idx++] = x2;\n      vertices[idx++] = y2;\n      vertices[idx++] = color;\n      vertices[idx++] = u2;\n      vertices[idx++] = v2;\n      vertices[idx++] = x2;\n      vertices[idx++] = y;\n      vertices[idx++] = color;\n      vertices[idx++] = u2;\n      vertices[idx] = v;\n    }; // public GlyphLayout setText (CharSequence str, float x, float y) {\n    // \tclear();\n    // \treturn addText(str, x, y, 0, str.length(), 0, Align.left, false);\n    // }\n    // public GlyphLayout setText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {\n    // \tclear();\n    // \treturn addText(str, x, y, 0, str.length(), targetWidth, halign, wrap);\n    // }\n    // public GlyphLayout setText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign,\n    // \tboolean wrap) {\n    // \tclear();\n    // \treturn addText(str, x, y, start, end, targetWidth, halign, wrap);\n    // }\n\n\n    this.setText = function (str, x, y, start, end, targetWidth, halign, wrap, truncate) {\n      _this.clear();\n\n      return _this.addText(str, x, y, start, end, targetWidth, halign, wrap, truncate);\n    };\n\n    this.setTextToCache = function (layout, x, y) {\n      _this.clear();\n\n      _this.addTextToCache(layout, x, y);\n    }; // public GlyphLayout addText (CharSequence str, float x, float y) {\n    // \treturn addText(str, x, y, 0, str.length(), 0, Align.left, false, null);\n    // }\n    // public GlyphLayout addText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {\n    // \treturn addText(str, x, y, 0, str.length(), targetWidth, halign, wrap, null);\n    // }\n    // public GlyphLayout addText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign,\n    // \tboolean wrap) {\n    // \treturn addText(str, x, y, start, end, targetWidth, halign, wrap, null);\n    // }\n\n\n    this.addText = function (str, x, y, start, end, targetWidth, halign, wrap, truncate) {\n      var layout = Utils_1.Pools.obtain('GlyphLayout');\n\n      _this.pooledLayouts.push(layout);\n\n      layout.setText(_this.font, str, start, end, _this.color, targetWidth, halign, wrap, truncate);\n\n      _this.addTextToCache(layout, x, y);\n\n      return layout;\n    };\n\n    this.addTextToCache = function (layout, x, y) {\n      _this.addToCache(layout, x, y + _this.font.data.ascent);\n    };\n    /** Returns the x position of the cached string, relative to the position when the string was cached. */\n\n\n    this.getX = function () {\n      return _this.x;\n    };\n    /** Returns the y position of the cached string, relative to the position when the string was cached. */\n\n\n    this.getY = function () {\n      return _this.y;\n    };\n\n    this.getFont = function () {\n      return _this.font;\n    };\n\n    this.setUseIntegerPositions = function (use) {\n      _this.integer = use;\n    };\n    /** @return whether this font uses integer positions for drawing. */\n\n\n    this.usesIntegerPositions = function () {\n      return _this.integer;\n    };\n\n    this.getVertices = function (page) {\n      return _this.pageVertices[page];\n    };\n\n    this.getVertexCount = function (page) {\n      return _this.idx[page];\n    };\n\n    this.getLayouts = function () {\n      return _this.layouts;\n    };\n\n    this.font = font;\n    this.integer = integer;\n    var pageCount = font.regions.length;\n    if (pageCount === 0) console.log('The specified font must contain at least one texture page.');\n    this.pageVertices = new Array(pageCount).fill([]);\n    this.idx = new Array(pageCount);\n\n    if (pageCount > 1) {\n      // Contains the indices of the glyph in the cache as they are added.\n      this.pageGlyphIndices = new Array(pageCount);\n\n      for (var i = 0, n = this.pageGlyphIndices.length; i < n; i++) {\n        this.pageGlyphIndices[i] = [];\n      }\n    }\n\n    this.tempGlyphCount = new Array(pageCount);\n    Utils_1.Pools.get('GlyphLayout', function () {\n      return new GlyphLayout_1.GlyphLayout(font, '', 0, 0, Utils_1.Color.WHITE, 0, Utils_1.Align.left, false);\n    });\n  }\n\n  _createClass(BitmapFontCache, [{\n    key: \"draw\",\n    value: function draw(batch) {\n      var _this2 = this;\n\n      var regions = this.font.getRegions();\n\n      for (var i = 0; i < this.pageVertices.length; i++) {\n        if (this.idx[i] > 0) {\n          var vertices = this.pageVertices[i];\n\n          var _loop = function _loop(j) {\n            var offset = 20 * j;\n            var region = regions.find(function (item) {\n              var _a;\n\n              return item.id === ((_a = _this2.drawingTexts) === null || _a === void 0 ? void 0 : _a[j]);\n            });\n\n            if (region) {\n              region.draw(batch, vertices[0 + offset], vertices[1 + offset], vertices[10 + offset] - vertices[0 + offset], vertices[11 + offset] - vertices[1 + offset]);\n            }\n          };\n\n          for (var j = 0; j < this.idx[i] / 20; j++) {\n            _loop(j);\n          }\n        }\n      }\n    }\n  }]);\n\n  return BitmapFontCache;\n}();\n\nexports.BitmapFontCache = BitmapFontCache;","map":{"version":3,"names":["Object","defineProperty","exports","value","BitmapFontCache","GlyphLayout_1","require","NumberUtils_1","Utils_1","font","integer","tempColor","Color","drawingTexts","layouts","pooledLayouts","color","setPosition","x","y","translate","xAmount","yAmount","Math","round","pageVertices","i","n","length","vertices","ii","nn","idx","setColors","r","g","b","a","intBits","NumberUtil","intToFloatColor","j","getColor","setColor","set","clear","Pools","freeAll","pageGlyphIndices","requireGlyphs","layout","requirePageGlyphs","glyphCount","tempGlyphCount","runs","glyphs","glyphItems","page","vertexCount","Array","newVertices","Utils","arrayCopy","setPageCount","pageCount","newPageVertices","fill","newIdx","newPageGlyphIndices","pageGlyphIndicesLength","addToCache","runCount","regions","push","colors","colorsIndex","nextColorGlyphIndex","glyphIndex","lastColorFloatBits","run","xAdvances","gx","gy","id","addGlyph","whiteIntBits","currentTint","glyph","scaleX","data","scaleY","xoffset","yoffset","width","height","u","u2","v","v2","x2","y2","setText","str","start","end","targetWidth","halign","wrap","truncate","addText","setTextToCache","addTextToCache","obtain","ascent","getX","getY","getFont","setUseIntegerPositions","use","usesIntegerPositions","getVertices","getVertexCount","getLayouts","console","log","get","GlyphLayout","WHITE","Align","left","batch","getRegions","offset","region","find","item","_a","draw"],"sources":["D:/projects/test-game/node_modules/gdxts/dist/lib/BitmapFontCache.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitmapFontCache = void 0;\nconst GlyphLayout_1 = require(\"./GlyphLayout\");\nconst NumberUtils_1 = require(\"./NumberUtils\");\nconst Utils_1 = require(\"./Utils\");\nclass BitmapFontCache {\n    /** @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */\n    constructor(font, integer) {\n        this.tempColor = new Utils_1.Color(1, 1, 1, 1);\n        this.drawingTexts = [];\n        this.layouts = [];\n        this.pooledLayouts = [];\n        this.color = new Utils_1.Color(1, 1, 1, 1);\n        /** Sets the position of the text, relative to the position when the cached text was created.\n         * @param x The x coordinate\n         * @param y The y coordinate */\n        this.setPosition = (x, y) => {\n            this.translate(x - this.x, y - this.y);\n        };\n        /** Sets the position of the text, relative to its current position.\n         * @param xAmount The amount in x to move the text\n         * @param yAmount The amount in y to move the text */\n        this.translate = (xAmount, yAmount) => {\n            if (xAmount === 0 && yAmount === 0)\n                return;\n            if (this.integer) {\n                xAmount = Math.round(xAmount);\n                yAmount = Math.round(yAmount);\n            }\n            this.x += xAmount;\n            this.y += yAmount;\n            const pageVertices = this.pageVertices;\n            for (let i = 0, n = pageVertices.length; i < n; i++) {\n                const vertices = pageVertices[i];\n                for (let ii = 0, nn = this.idx[i]; ii < nn; ii += 5) {\n                    vertices[ii] += xAmount;\n                    vertices[ii + 1] += yAmount;\n                }\n            }\n        };\n        /** Tints all text currently in the cache. Does not affect subsequently added text. */\n        // public tint = (tint: Color) => {\n        //    const newTint: number = tint.toFloatBits();\n        //    if (this.currentTint == newTint) return;\n        //    this.currentTint = newTint;\n        //    const pageVertices: number[][] = this.pageVertices;\n        //    const tempColor: Color = this.tempColor;\n        //    const tempGlyphCount: number[] = this.tempGlyphCount;\n        //    for (let i = 0; i < tempGlyphCount.length; i++) {\n        //       tempGlyphCount[i] = 0;\n        //    }\n        //    for (let i = 0, n = this.layouts.length; i < n; i++) {\n        //       const layout: GlyphLayout = this.layouts[i];\n        //       const colors: number[] = layout.colors;\n        //       let colorsIndex = 0,\n        //          nextColorGlyphIndex = 0,\n        //          glyphIndex = 0;\n        //       let lastColorFloatBits = 0;\n        //       for (let ii = 0, nn = layout.runs.length; ii < nn; ii++) {\n        //          const run: GlyphRun = layout.runs[ii];\n        //          const glyphs: Glyph[] = run.glyphs;\n        //          for (let iii = 0, nnn = run.glyphs.length; iii < nnn; iii++) {\n        //             if (glyphIndex++ === nextColorGlyphIndex) {\n        //                Color.abgr8888ToColor(tempColor, colors[++colorsIndex]);\n        //                lastColorFloatBits = tempColor.mul(tint).toFloatBits();\n        //                nextColorGlyphIndex = ++colorsIndex < colors.length ? colors[colorsIndex] : -1;\n        //             }\n        //             const page: number = glyphs[iii].page;\n        //             const offset = tempGlyphCount[page] * 20 + 2;\n        //             tempGlyphCount[page]++;\n        //             const vertices: number[] = pageVertices[page];\n        //             vertices[offset] = lastColorFloatBits;\n        //             vertices[offset + 5] = lastColorFloatBits;\n        //             vertices[offset + 10] = lastColorFloatBits;\n        //             vertices[offset + 15] = lastColorFloatBits;\n        //          }\n        //       }\n        //    }\n        // };\n        /** Sets the alpha component of all text currently in the cache. Does not affect subsequently added text. */\n        // public setAlphas = (alpha: number) => {\n        //    const alphaBits: number = (254 * alpha) << 24;\n        //    let prev = 0,\n        //       newColor = 0;\n        //    for (let j = 0, length = this.pageVertices.length; j < length; j++) {\n        //       const vertices: number[] = this.pageVertices[j];\n        //       for (let i = 2, n = this.idx[j]; i < n; i += 5) {\n        //          const c: number = vertices[i];\n        //          if (c == prev && i != 2) {\n        //             vertices[i] = newColor;\n        //          } else {\n        //             prev = c;\n        //             let rgba = NumberUtils.floatToIntColor(c);\n        //             rgba = (rgba & 0x00ffffff) | alphaBits;\n        //             newColor = NumberUtils.intToFloatColor(rgba);\n        //             vertices[i] = newColor;\n        //          }\n        //       }\n        //    }\n        // };\n        this.setColors = (r, g, b, a) => {\n            const intBits = (255 << 24) | ((255 * b) << 16) | ((255 * g) << 8) | (255 * r);\n            const value = NumberUtils_1.NumberUtil.intToFloatColor(intBits);\n            for (let j = 0, length = this.pageVertices.length; j < length; j++) {\n                const vertices = this.pageVertices[j];\n                for (let i = 2, n = this.idx[j]; i < n; i += 5)\n                    vertices[i] = value;\n            }\n        };\n        /** Returns the color used for subsequently added text. Modifying the color affects text subsequently added to the cache, but\n         * does not affect existing text currently in the cache. */\n        this.getColor = () => {\n            return this.color;\n        };\n        /** A convenience method for setting the cache color. The color can also be set by modifying {@link #getColor()}. */\n        this.setColor = (r, g, b, a) => {\n            this.color.set(r, g, b, a);\n        };\n        /** Removes all glyphs in the cache. */\n        this.clear = () => {\n            this.x = 0;\n            this.y = 0;\n            Utils_1.Pools.freeAll('GlyphLayout', this.pooledLayouts);\n            this.pooledLayouts.length = 0;\n            this.layouts.length = 0;\n            for (let i = 0, n = this.idx.length; i < n; i++) {\n                if (this.pageGlyphIndices != null)\n                    this.pageGlyphIndices[i].length = 0;\n                this.idx[i] = 0;\n            }\n        };\n        this.requireGlyphs = (layout) => {\n            if (this.pageVertices.length === 1) {\n                // Simple if we just have one page.\n                this.requirePageGlyphs(0, layout.glyphCount);\n            }\n            else {\n                const tempGlyphCount = this.tempGlyphCount;\n                for (let i = 0; i < tempGlyphCount.length; i++) {\n                    tempGlyphCount[i] = 0;\n                }\n                // Determine # of glyphs in each page.\n                for (let i = 0, n = layout.runs.length; i < n; i++) {\n                    const glyphs = layout.runs[i].glyphs;\n                    const glyphItems = glyphs;\n                    for (let ii = 0, nn = glyphs.length; ii < nn; ii++)\n                        tempGlyphCount[glyphItems[ii].page]++;\n                }\n                // Require that many for each page.\n                for (let i = 0, n = tempGlyphCount.length; i < n; i++)\n                    this.requirePageGlyphs(i, tempGlyphCount[i]);\n            }\n        };\n        this.requirePageGlyphs = (page, glyphCount) => {\n            // if (this.pageGlyphIndices != null) {\n            //    if (glyphCount > this.pageGlyphIndices[page].length)\n            //       this.pageGlyphIndices[page].ensureCapacity(glyphCount - this.pageGlyphIndices[page].length);\n            // }\n            const vertexCount = this.idx[page] + glyphCount * 20;\n            const vertices = this.pageVertices[page];\n            if (!vertices) {\n                this.pageVertices[page] = new Array(vertexCount);\n            }\n            else if (vertices.length < vertexCount) {\n                const newVertices = new Array(vertexCount);\n                Utils_1.Utils.arrayCopy(vertices, 0, newVertices, 0, this.idx[page]);\n                this.pageVertices[page] = newVertices;\n            }\n        };\n        this.setPageCount = (pageCount) => {\n            const newPageVertices = new Array(pageCount).fill([]);\n            Utils_1.Utils.arrayCopy(this.pageVertices, 0, newPageVertices, 0, this.pageVertices.length);\n            this.pageVertices = [...newPageVertices];\n            const newIdx = new Array(pageCount);\n            Utils_1.Utils.arrayCopy(this.idx, 0, newIdx, 0, this.idx.length);\n            this.idx = newIdx;\n            const newPageGlyphIndices = new Array(pageCount);\n            let pageGlyphIndicesLength = 0;\n            if (this.pageGlyphIndices != null) {\n                pageGlyphIndicesLength = this.pageGlyphIndices.length;\n                Utils_1.Utils.arrayCopy(this.pageGlyphIndices, 0, newPageGlyphIndices, 0, this.pageGlyphIndices.length);\n            }\n            for (let i = pageGlyphIndicesLength; i < pageCount; i++)\n                newPageGlyphIndices[i] = [];\n            this.pageGlyphIndices = newPageGlyphIndices;\n            this.tempGlyphCount = new Array(pageCount);\n        };\n        this.addToCache = (layout, x, y) => {\n            const runCount = layout.runs.length;\n            if (runCount === 0)\n                return;\n            // Check if the number of font pages has changed.\n            if (this.pageVertices.length < this.font.regions.length)\n                this.setPageCount(this.font.regions.length);\n            this.layouts.push(layout);\n            this.requireGlyphs(layout);\n            const colors = layout.colors;\n            let colorsIndex = 0, nextColorGlyphIndex = 0, glyphIndex = 0;\n            let lastColorFloatBits = 0;\n            this.drawingTexts.length = 0;\n            for (let i = 0; i < runCount; i++) {\n                const run = layout.runs[i];\n                const glyphs = run.glyphs;\n                const xAdvances = run.xAdvances;\n                let gx = x + run.x, gy = y + run.y;\n                for (let ii = 0, nn = run.glyphs.length; ii < nn; ii++) {\n                    if (glyphIndex++ === nextColorGlyphIndex) {\n                        lastColorFloatBits = NumberUtils_1.NumberUtil.intToFloatColor(colors[++colorsIndex]);\n                        nextColorGlyphIndex = ++colorsIndex < colors.length ? colors[colorsIndex] : -1;\n                    }\n                    gx += xAdvances[ii];\n                    this.drawingTexts.push(glyphs[ii].id);\n                    this.addGlyph(glyphs[ii], gx, gy, lastColorFloatBits);\n                }\n            }\n            const whiteIntBits = (255 << 24) | (255 << 16) | (255 << 8) | 255;\n            this.currentTint = NumberUtils_1.NumberUtil.intToFloatColor(whiteIntBits); // Cached glyphs have changed, reset the current tint.\n        };\n        this.addGlyph = (glyph, x, y, color) => {\n            let scaleX = this.font.data.scaleX, scaleY = this.font.data.scaleY;\n            x += glyph.xoffset * scaleX;\n            y += glyph.yoffset * scaleY;\n            let width = glyph.width * scaleX, height = glyph.height * scaleY;\n            let u = glyph.u, u2 = glyph.u2, v = glyph.v, v2 = glyph.v2;\n            if (this.integer) {\n                x = Math.round(x);\n                y = Math.round(y);\n                width = Math.round(width);\n                height = Math.round(height);\n            }\n            let x2 = x + width, y2 = y + height;\n            const page = glyph.page;\n            let idx = this.idx[page];\n            this.idx[page] += 20;\n            if (this.pageGlyphIndices != null)\n                this.pageGlyphIndices[page].push(this.glyphCount++);\n            const vertices = this.pageVertices[page];\n            vertices[idx++] = x;\n            vertices[idx++] = y;\n            vertices[idx++] = color;\n            vertices[idx++] = u;\n            vertices[idx++] = v;\n            vertices[idx++] = x;\n            vertices[idx++] = y2;\n            vertices[idx++] = color;\n            vertices[idx++] = u;\n            vertices[idx++] = v2;\n            vertices[idx++] = x2;\n            vertices[idx++] = y2;\n            vertices[idx++] = color;\n            vertices[idx++] = u2;\n            vertices[idx++] = v2;\n            vertices[idx++] = x2;\n            vertices[idx++] = y;\n            vertices[idx++] = color;\n            vertices[idx++] = u2;\n            vertices[idx] = v;\n        };\n        // public GlyphLayout setText (CharSequence str, float x, float y) {\n        // \tclear();\n        // \treturn addText(str, x, y, 0, str.length(), 0, Align.left, false);\n        // }\n        // public GlyphLayout setText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {\n        // \tclear();\n        // \treturn addText(str, x, y, 0, str.length(), targetWidth, halign, wrap);\n        // }\n        // public GlyphLayout setText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign,\n        // \tboolean wrap) {\n        // \tclear();\n        // \treturn addText(str, x, y, start, end, targetWidth, halign, wrap);\n        // }\n        this.setText = (str, x, y, start, end, targetWidth, halign, wrap, truncate) => {\n            this.clear();\n            return this.addText(str, x, y, start, end, targetWidth, halign, wrap, truncate);\n        };\n        this.setTextToCache = (layout, x, y) => {\n            this.clear();\n            this.addTextToCache(layout, x, y);\n        };\n        // public GlyphLayout addText (CharSequence str, float x, float y) {\n        // \treturn addText(str, x, y, 0, str.length(), 0, Align.left, false, null);\n        // }\n        // public GlyphLayout addText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {\n        // \treturn addText(str, x, y, 0, str.length(), targetWidth, halign, wrap, null);\n        // }\n        // public GlyphLayout addText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign,\n        // \tboolean wrap) {\n        // \treturn addText(str, x, y, start, end, targetWidth, halign, wrap, null);\n        // }\n        this.addText = (str, x, y, start, end, targetWidth, halign, wrap, truncate) => {\n            const layout = Utils_1.Pools.obtain('GlyphLayout');\n            this.pooledLayouts.push(layout);\n            layout.setText(this.font, str, start, end, this.color, targetWidth, halign, wrap, truncate);\n            this.addTextToCache(layout, x, y);\n            return layout;\n        };\n        this.addTextToCache = (layout, x, y) => {\n            this.addToCache(layout, x, y + this.font.data.ascent);\n        };\n        /** Returns the x position of the cached string, relative to the position when the string was cached. */\n        this.getX = () => {\n            return this.x;\n        };\n        /** Returns the y position of the cached string, relative to the position when the string was cached. */\n        this.getY = () => {\n            return this.y;\n        };\n        this.getFont = () => {\n            return this.font;\n        };\n        this.setUseIntegerPositions = (use) => {\n            this.integer = use;\n        };\n        /** @return whether this font uses integer positions for drawing. */\n        this.usesIntegerPositions = () => {\n            return this.integer;\n        };\n        this.getVertices = (page) => {\n            return this.pageVertices[page];\n        };\n        this.getVertexCount = (page) => {\n            return this.idx[page];\n        };\n        this.getLayouts = () => {\n            return this.layouts;\n        };\n        this.font = font;\n        this.integer = integer;\n        const pageCount = font.regions.length;\n        if (pageCount === 0)\n            console.log('The specified font must contain at least one texture page.');\n        this.pageVertices = new Array(pageCount).fill([]);\n        this.idx = new Array(pageCount);\n        if (pageCount > 1) {\n            // Contains the indices of the glyph in the cache as they are added.\n            this.pageGlyphIndices = new Array(pageCount);\n            for (let i = 0, n = this.pageGlyphIndices.length; i < n; i++)\n                this.pageGlyphIndices[i] = [];\n        }\n        this.tempGlyphCount = new Array(pageCount);\n        Utils_1.Pools.get('GlyphLayout', () => new GlyphLayout_1.GlyphLayout(font, '', 0, 0, Utils_1.Color.WHITE, 0, Utils_1.Align.left, false));\n    }\n    draw(batch) {\n        const regions = this.font.getRegions();\n        for (let i = 0; i < this.pageVertices.length; i++) {\n            if (this.idx[i] > 0) {\n                const vertices = this.pageVertices[i];\n                for (let j = 0; j < this.idx[i] / 20; j++) {\n                    const offset = 20 * j;\n                    const region = regions.find(item => { var _a; return item.id === ((_a = this.drawingTexts) === null || _a === void 0 ? void 0 : _a[j]); });\n                    if (region) {\n                        region.draw(batch, vertices[0 + offset], vertices[1 + offset], vertices[10 + offset] - vertices[0 + offset], vertices[11 + offset] - vertices[1 + offset]);\n                    }\n                }\n            }\n        }\n    }\n}\nexports.BitmapFontCache = BitmapFontCache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}