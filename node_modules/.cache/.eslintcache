[{"D:\\projects\\test-game\\src\\index.ts":"1","D:\\projects\\test-game\\src\\index3.ts":"2"},{"size":12503,"mtime":1660118077621,"results":"3","hashOfConfig":"4"},{"size":8931,"mtime":1660555166611,"results":"5","hashOfConfig":"4"},{"filePath":"6","messages":"7","suppressedMessages":"8","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"9","usedDeprecatedRules":"10"},"1wyhpi",{"filePath":"11","messages":"12","suppressedMessages":"13","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"D:\\projects\\test-game\\src\\index.ts",["14","15","16"],[],"import {\n  createGameLoop,\n  createStage,\n  createViewport,\n  PolygonBatch,\n  ShapeRenderer,\n  Texture,\n  Vector2,\n  BitmapFont,\n  TextureRegion,\n  Color,\n} from \"gdxts\";\n\nimport { init3 } from \"./index3\";\n\nexport const init = async () => {\n  const stage = createStage();\n  const canvas = stage.getCanvas();\n  const viewport = createViewport(canvas, 1500, 2000);\n  const gl = viewport.getContext();\n  const shapeRenderer = new ShapeRenderer(gl);\n  const batch = new PolygonBatch(gl);\n  const camera = viewport.getCamera();\n\n  // const background = await Texture.load(gl, \"./TetrisBg.png\");\n  // const border = await Texture.load(gl, \"./border.png\");\n  const bgRight = await Texture.load(gl, \"./bg1.png\");\n  const block = await Texture.load(gl, \"./borderBlock.png\");\n  const mainBlock = await Texture.load(gl, \"./GreenBlock.png\");\n  const black = new Color(0, 0, 0, 1);\n\n  //config game\n  const ROWGAME = 24;\n  const COLGAME = 12;\n  let map: any[] = [];\n  let blockSize = new Vector2(83, 83);\n  let delayTime = 0;\n  let moveLeft = false;\n  let moveRight = false;\n  let moveDown = false;\n\n  //I\n  const iBlock = [\n    [0, 0, 0, 0],\n    [1, 1, 1, 1],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n  ];\n\n  //L\n  const lBlock = [\n    [0, 0, 1],\n    [1, 1, 1],\n    [0, 0, 0],\n  ];\n\n  //L-reverse\n  const lReverseBlock = [\n    [1, 0, 0],\n    [1, 1, 1],\n    [0, 0, 0],\n  ];\n\n  // Square\n  const sBlock = [\n    [1, 1],\n    [1, 1],\n  ];\n\n  // Z\n  const zBlock = [\n    [0, 1, 1],\n    [1, 1, 0],\n    [0, 0, 0],\n  ];\n\n  // Z-reverse\n  const zReverseBlock = [\n    [1, 1, 0],\n    [0, 1, 1],\n    [0, 0, 0],\n  ];\n\n  // T\n  const tBlock = [\n    [0, 1, 0],\n    [1, 1, 1],\n    [0, 0, 0],\n  ];\n\n  const blocks = [\n    iBlock,\n    lReverseBlock,\n    lBlock,\n    sBlock,\n    zBlock,\n    zReverseBlock,\n    tBlock,\n  ];\n  console.log(map);\n  let currentBlock = blocks[0]; //\n  let nextBlock = blocks[getRandomInt(0, 6)];\n  let positionBlock: number[] = [];\n  let currentPosition = new Vector2(23, 11);\n\n  function getRandomInt(min: number, max: number) {\n    return Math.floor(Math.random() * (max - min)) + min;\n  }\n\n  // draw the map\n  function mapGame() {\n    for (let row = 0; row < ROWGAME; row++) {\n      map[row] = [];\n      for (let col = 0; col < COLGAME; col++) {\n        if (row >= 1) {\n          map[row].push(0);\n        } else {\n          map[row].push(1);\n        }\n      }\n      for (let col = 0; col < map[row].length; col++) {\n        map[row][0] = 1;\n        map[row][11] = 1;\n      }\n    }\n  }\n\n  function keyMove() {\n    if (moveLeft) {\n      for (let i = 1; i < positionBlock.length; i += 2) {\n        positionBlock[i] -= 1;\n        if (i + 2 >= positionBlock.length) {\n          map[positionBlock[i - 1]][positionBlock[i]] = 0;\n          console.warn(\"dcm\");\n        }\n      }\n      console.log(positionBlock);\n      moveLeft = false;\n    }\n    if (moveRight) {\n      if (moveRight) {\n        for (let i = 1; i < positionBlock.length; i += 2) {\n          positionBlock[i] += 1;\n        }\n        console.log(positionBlock);\n        moveRight = false;\n      }\n    }\n    if (moveDown) {\n      for (let i = 0; i < positionBlock.length; i += 2) {\n        positionBlock[i] -= 1;\n      }\n      console.log(positionBlock);\n      moveDown = false;\n    }\n  }\n\n  function blockOnMap() {\n    positionBlock = [];\n    for (let row = 0; row < currentBlock.length; row++) {\n      for (let col = 0; col < currentBlock[row].length; col++) {\n        map[ROWGAME - 1 - row][COLGAME / 2 - 1 + col] = currentBlock[row][col];\n        if (map[ROWGAME - 1 - row][COLGAME / 2 - 1 + col]) {\n          positionBlock.push(ROWGAME - 1 - row, COLGAME / 2 - 1 + col);\n        }\n        console.warn(positionBlock);\n      }\n      console.log(map);\n    }\n  }\n\n  function drawTetromino() {\n    for (let row = 0; row < map.length; row++) {\n      for (let col = 0; col < map[row].length; col++) {\n        if (map[row][col] !== 0) {\n          batch.draw(\n            map[row][col] === 1 ? block : mainBlock,\n            col * blockSize.x,\n            row * blockSize.y,\n            83,\n            83\n          );\n        } // scan to draw\n      }\n    } //\n  }\n\n  function collisionHandmade() {\n    switch (currentBlock) {\n      case blocks[0]:\n        if (\n          map[positionBlock[0] - 1][positionBlock[1]] === 0 &&\n          map[positionBlock[2] - 1][positionBlock[3]] === 0 &&\n          map[positionBlock[4] - 1][positionBlock[5]] === 0 &&\n          map[positionBlock[6] - 1][positionBlock[7]] === 0\n        ) {\n          keyMove();\n          map[positionBlock[0] - 1][positionBlock[1]] = 1;\n          map[positionBlock[2] - 1][positionBlock[3]] = 1;\n          map[positionBlock[4] - 1][positionBlock[5]] = 1;\n          map[positionBlock[6] - 1][positionBlock[7]] = 1;\n          //undraw\n          map[positionBlock[0]][positionBlock[1]] = 0;\n          map[positionBlock[2]][positionBlock[3]] = 0;\n          map[positionBlock[4]][positionBlock[5]] = 0;\n          map[positionBlock[6]][positionBlock[7]] = 0;\n          for (let i = 0; i < positionBlock.length; i += 2) {\n            positionBlock[i] -= 1;\n          }\n        } else {\n          currentBlock = nextBlock;\n          nextBlock = blocks[getRandomInt(0, 6)];\n          blockOnMap();\n        }\n\n        break;\n      case blocks[1]:\n        if (\n          map[positionBlock[2] - 1][positionBlock[3]] === 0 &&\n          map[positionBlock[4] - 1][positionBlock[5]] === 0 &&\n          map[positionBlock[6] - 1][positionBlock[7]] === 0\n        ) {\n          // keyMove();\n          // map[positionBlock[0] - 1][positionBlock[1]] =\n          //   map[positionBlock[0]][positionBlock[1]];\n          // map[positionBlock[2] - 1][positionBlock[3]] = 1;\n          // map[positionBlock[4] - 1][positionBlock[5]] =\n          //   map[positionBlock[4]][positionBlock[5]];\n          // map[positionBlock[6] - 1][positionBlock[7]] =\n          //   map[positionBlock[6]][positionBlock[7]];\n          // //undraw\n          // map[positionBlock[0]][positionBlock[1]] = 0;\n          // map[positionBlock[4]][positionBlock[5]] = 0;\n          // map[positionBlock[6]][positionBlock[7]] = 0;\n          // for (let i = 0; i < positionBlock.length; i += 2) {\n          //   positionBlock[i] -= 1;\n          // }\n        } else {\n          currentBlock = nextBlock;\n          nextBlock = blocks[getRandomInt(0, 6)];\n          blockOnMap();\n        }\n        break;\n      case blocks[2]:\n        if (\n          map[positionBlock[2] - 1][positionBlock[3]] === 0 &&\n          map[positionBlock[4] - 1][positionBlock[5]] === 0 &&\n          map[positionBlock[6] - 1][positionBlock[7]] === 0\n        ) {\n          // keyMove();\n          // map[positionBlock[2] - 1][positionBlock[3]] =\n          //   map[positionBlock[2]][positionBlock[3]];\n          // map[positionBlock[4] - 1][positionBlock[5]] =\n          //   map[positionBlock[4]][positionBlock[5]];\n          // map[positionBlock[6] - 1][positionBlock[7]] = 1;\n          // map[positionBlock[0] - 1][positionBlock[1]] =\n          //   map[positionBlock[0]][positionBlock[1]];\n          // //undraw\n          // map[positionBlock[0]][positionBlock[1]] = 0;\n          // map[positionBlock[2]][positionBlock[3]] = 0;\n          // map[positionBlock[4]][positionBlock[5]] = 0;\n          // for (let i = 0; i < positionBlock.length; i += 2) {\n          //   positionBlock[i] -= 1;\n          // }\n        } else {\n          currentBlock = nextBlock;\n          nextBlock = blocks[getRandomInt(0, 6)];\n          blockOnMap();\n        }\n        break;\n      case blocks[3]:\n        if (\n          map[positionBlock[4] - 1][positionBlock[5]] === 0 &&\n          map[positionBlock[6] - 1][positionBlock[7]] === 0\n        ) {\n          // keyMove();\n          // map[positionBlock[4] - 1][positionBlock[5]] =\n          //   map[positionBlock[4]][positionBlock[5]];\n          // map[positionBlock[6] - 1][positionBlock[7]] =\n          //   map[positionBlock[6]][positionBlock[7]];\n          // //undraw\n          // map[positionBlock[0]][positionBlock[1]] = 0;\n          // map[positionBlock[2]][positionBlock[3]] = 0;\n          // for (let i = 0; i < positionBlock.length; i += 2) {\n          //   positionBlock[i] -= 1;\n          // }\n        } else {\n          currentBlock = nextBlock;\n          nextBlock = blocks[getRandomInt(0, 6)];\n          blockOnMap();\n        }\n        break;\n      case blocks[4]:\n        if (\n          map[positionBlock[4] - 1][positionBlock[5]] === 0 &&\n          map[positionBlock[6] - 1][positionBlock[7]] === 0\n        ) {\n          // keyMove();\n          // map[positionBlock[4] - 1][positionBlock[5]] =\n          //   map[positionBlock[4]][positionBlock[5]];\n          // map[positionBlock[6] - 1][positionBlock[7]] =\n          //   map[positionBlock[6]][positionBlock[7]];\n          // map[positionBlock[2] - 1][positionBlock[3]] =\n          //   map[positionBlock[2]][positionBlock[3]];\n          // // undraw\n          // map[positionBlock[0]][positionBlock[1]] = 0;\n          // map[positionBlock[2]][positionBlock[3]] = 0;\n          // map[positionBlock[4]][positionBlock[5]] = 0;\n          // for (let i = 0; i < positionBlock.length; i += 2) {\n          //   positionBlock[i] -= 1;\n          // }\n        } else {\n          currentBlock = nextBlock;\n          nextBlock = blocks[getRandomInt(0, 6)];\n          blockOnMap();\n        }\n        break;\n      case blocks[5]:\n        if (\n          map[positionBlock[0] - 1][positionBlock[1]] === 0 &&\n          map[positionBlock[4] - 1][positionBlock[5]] === 0 &&\n          map[positionBlock[6] - 1][positionBlock[7]] === 0\n        ) {\n          // keyMove();\n          // map[positionBlock[0] - 1][positionBlock[1]] =\n          //   map[positionBlock[0]][positionBlock[1]];\n          // map[positionBlock[4] - 1][positionBlock[5]] =\n          //   map[positionBlock[4]][positionBlock[5]];\n          // map[positionBlock[6] - 1][positionBlock[7]] =\n          //   map[positionBlock[6]][positionBlock[7]];\n          // // undraw\n          // map[positionBlock[0]][positionBlock[1]] = 0;\n          // map[positionBlock[2]][positionBlock[3]] = 0;\n          // map[positionBlock[6]][positionBlock[7]] = 0;\n          // for (let i = 0; i < positionBlock.length; i += 2) {\n          //   positionBlock[i] -= 1;\n          // }\n        } else {\n          currentBlock = nextBlock;\n          nextBlock = blocks[getRandomInt(0, 6)];\n          blockOnMap();\n        }\n        break;\n      case blocks[6]:\n        if (\n          map[positionBlock[2] - 1][positionBlock[3]] === 0 &&\n          map[positionBlock[4] - 1][positionBlock[5]] === 0 &&\n          map[positionBlock[6] - 1][positionBlock[7]] === 0\n        ) {\n          // keyMove();\n          // map[positionBlock[2] - 1][positionBlock[3]] =\n          //   map[positionBlock[0]][positionBlock[1]];\n          // map[positionBlock[4] - 1][positionBlock[5]] =\n          //   map[positionBlock[4]][positionBlock[5]];\n          // map[positionBlock[6] - 1][positionBlock[7]] =\n          //   map[positionBlock[6]][positionBlock[7]];\n          // //undraw\n          // map[positionBlock[0]][positionBlock[1]] = 0;\n          // map[positionBlock[2]][positionBlock[3]] = 0;\n          // map[positionBlock[6]][positionBlock[7]] = 0;\n          // for (let i = 0; i < positionBlock.length; i += 2) {\n          //   positionBlock[i] -= 1;\n          // }\n        } else {\n          currentBlock = nextBlock;\n          nextBlock = blocks[getRandomInt(0, 6)];\n          blockOnMap();\n        }\n\n        break;\n      default:\n        break;\n    }\n  }\n  function control(e: any) {\n    switch (e.keyCode) {\n      case 37:\n        moveLeft = true;\n        break;\n      case 39:\n        moveRight = true;\n        break;\n      case 40:\n        moveDown = true;\n        break;\n      default:\n        break;\n    }\n  }\n\n  window.addEventListener(\"keydown\", function (e) {\n    control(e);\n  });\n\n  mapGame();\n  blockOnMap();\n\n  createGameLoop((delta: number) => {\n    delayTime += delta;\n    if (delayTime >= 0.5) {\n      delayTime = 0;\n      collisionHandmade();\n    }\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.clearColor(0, 0, 0, 1);\n    shapeRenderer.setProjection(camera.projectionView.values);\n    shapeRenderer.begin();\n    shapeRenderer.rect(true, 0, 0, 1000, 2000, black);\n    shapeRenderer.end();\n    // console.log(currentBlock);\n\n    //draw border\n    batch.setProjection(camera.projectionView.values);\n    batch.begin();\n    drawTetromino();\n    batch.draw(bgRight, 1000, 0, 500, 2000);\n    batch.end();\n  });\n};\n\n// init();\n// init2();\ninit3();\n",[],"D:\\projects\\test-game\\src\\index3.ts",["17","18","19","20","21"],[],{"ruleId":"22","severity":1,"message":"23","line":9,"column":3,"nodeType":"24","messageId":"25","endLine":9,"endColumn":13},{"ruleId":"22","severity":1,"message":"26","line":10,"column":3,"nodeType":"24","messageId":"25","endLine":10,"endColumn":16},{"ruleId":"22","severity":1,"message":"27","line":104,"column":7,"nodeType":"24","messageId":"25","endLine":104,"endColumn":22},{"ruleId":"22","severity":1,"message":"26","line":8,"column":3,"nodeType":"24","messageId":"25","endLine":8,"endColumn":16},{"ruleId":"22","severity":1,"message":"28","line":9,"column":3,"nodeType":"24","messageId":"25","endLine":9,"endColumn":8},{"ruleId":"22","severity":1,"message":"29","line":11,"column":10,"nodeType":"24","messageId":"25","endLine":11,"endColumn":14},{"ruleId":"22","severity":1,"message":"30","line":23,"column":9,"nodeType":"24","messageId":"25","endLine":23,"endColumn":13},{"ruleId":"22","severity":1,"message":"31","line":236,"column":7,"nodeType":"24","messageId":"25","endLine":236,"endColumn":12},"@typescript-eslint/no-unused-vars","'BitmapFont' is defined but never used.","Identifier","unusedVar","'TextureRegion' is defined but never used.","'currentPosition' is assigned a value but never used.","'Color' is defined but never used.","'text' is defined but never used.","'font' is assigned a value but never used.","'score' is assigned a value but never used."]