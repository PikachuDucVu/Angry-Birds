"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyArray = exports.createStage = exports.pointInRect = exports.resizeCanvas = exports.createGameLoop = exports.WindowedMean = exports.TimeKeeper = exports.Pools = exports.Pool = exports.Utils = exports.PowOut = exports.Pow = exports.Interpolation = exports.MathUtils = exports.Color = exports.StringSet = exports.IntSet = exports.Align = void 0;
class Align {
    static isLeft(align) {
        return (align & this.left) !== 0;
    }
    static isRight(align) {
        return (align & this.right) !== 0;
    }
    static isTop(align) {
        return (align & this.top) !== 0;
    }
    static isBottom(align) {
        return (align & this.bottom) !== 0;
    }
    static isCenterVertical(align) {
        return (align & this.top) === 0 && (align & this.bottom) === 0;
    }
    static isCenterHorizontal(align) {
        return (align & this.left) === 0 && (align & this.right) === 0;
    }
}
exports.Align = Align;
_a = Align;
Align.center = 1 << 0;
Align.top = 1 << 1;
Align.bottom = 1 << 2;
Align.left = 1 << 3;
Align.right = 1 << 4;
Align.topLeft = _a.top | _a.left;
Align.topRight = _a.top | _a.right;
Align.bottomLeft = _a.bottom | _a.left;
Align.bottomRight = _a.bottom | _a.right;
class IntSet {
    constructor() {
        this.array = new Array();
    }
    add(value) {
        let contains = this.contains(value);
        this.array[value | 0] = value | 0;
        return !contains;
    }
    contains(value) {
        return this.array[value | 0] !== undefined;
    }
    remove(value) {
        this.array[value | 0] = undefined;
    }
    clear() {
        this.array.length = 0;
    }
}
exports.IntSet = IntSet;
class StringSet {
    constructor() {
        this.entries = {};
        this.size = 0;
    }
    add(value) {
        let contains = this.entries[value];
        this.entries[value] = true;
        if (!contains) {
            this.size++;
            return true;
        }
        return false;
    }
    addAll(values) {
        let oldSize = this.size;
        for (var i = 0, n = values.length; i < n; i++)
            this.add(values[i]);
        return oldSize !== this.size;
    }
    contains(value) {
        return this.entries[value];
    }
    clear() {
        this.entries = {};
        this.size = 0;
    }
}
exports.StringSet = StringSet;
class Color {
    constructor(r = 0, g = 0, b = 0, a = 0) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    set(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        return this.clamp();
    }
    setFromColor(c) {
        this.r = c.r;
        this.g = c.g;
        this.b = c.b;
        this.a = c.a;
        return this;
    }
    setFromString(hex) {
        hex = hex.charAt(0) === '#' ? hex.substring(1) : hex;
        this.r = parseInt(hex.substring(0, 2), 16) / 255;
        this.g = parseInt(hex.substring(2, 4), 16) / 255;
        this.b = parseInt(hex.substring(4, 6), 16) / 255;
        this.a = hex.length !== 8 ? 1 : parseInt(hex.substring(6, 8), 16) / 255;
        return this;
    }
    add(r, g, b, a) {
        this.r += r;
        this.g += g;
        this.b += b;
        this.a += a;
        return this.clamp();
    }
    clamp() {
        if (this.r < 0)
            this.r = 0;
        else if (this.r > 1)
            this.r = 1;
        if (this.g < 0)
            this.g = 0;
        else if (this.g > 1)
            this.g = 1;
        if (this.b < 0)
            this.b = 0;
        else if (this.b > 1)
            this.b = 1;
        if (this.a < 0)
            this.a = 0;
        else if (this.a > 1)
            this.a = 1;
        return this;
    }
    toIntBits() {
        return ((255 * this.a) << 24) | ((255 * this.b) << 16) | ((255 * this.g) << 8) | (255 * this.r);
    }
    static rgba8888ToColor(color, value) {
        color.r = ((value & 0xff000000) >>> 24) / 255;
        color.g = ((value & 0x00ff0000) >>> 16) / 255;
        color.b = ((value & 0x0000ff00) >>> 8) / 255;
        color.a = (value & 0x000000ff) / 255;
    }
    static rgb888ToColor(color, value) {
        color.r = ((value & 0x00ff0000) >>> 16) / 255;
        color.g = ((value & 0x0000ff00) >>> 8) / 255;
        color.b = (value & 0x000000ff) / 255;
    }
    static fromString(hex) {
        return new Color().setFromString(hex);
    }
}
exports.Color = Color;
Color.WHITE = new Color(1, 1, 1, 1);
Color.RED = new Color(1, 0, 0, 1);
Color.GREEN = new Color(0, 1, 0, 1);
Color.BLUE = new Color(0, 0, 1, 1);
Color.MAGENTA = new Color(1, 0, 1, 1);
class MathUtils {
    static clamp(value, min, max) {
        if (value < min)
            return min;
        if (value > max)
            return max;
        return value;
    }
    static cosDeg(degrees) {
        return Math.cos(degrees * MathUtils.degRad);
    }
    static sinDeg(degrees) {
        return Math.sin(degrees * MathUtils.degRad);
    }
    static signum(value) {
        return value > 0 ? 1 : value < 0 ? -1 : 0;
    }
    static toInt(x) {
        return x > 0 ? Math.floor(x) : Math.ceil(x);
    }
    static cbrt(x) {
        let y = Math.pow(Math.abs(x), 1 / 3);
        return x < 0 ? -y : y;
    }
    static randomTriangular(min, max) {
        return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);
    }
    static randomTriangularWith(min, max, mode) {
        let u = Math.random();
        let d = max - min;
        if (u <= (mode - min) / d)
            return min + Math.sqrt(u * d * (mode - min));
        return max - Math.sqrt((1 - u) * d * (max - mode));
    }
    static isPowerOfTwo(value) {
        return value && (value & (value - 1)) === 0;
    }
}
exports.MathUtils = MathUtils;
MathUtils.PI = 3.1415927;
MathUtils.PI2 = MathUtils.PI * 2;
MathUtils.radiansToDegrees = 180 / MathUtils.PI;
MathUtils.radDeg = MathUtils.radiansToDegrees;
MathUtils.degreesToRadians = MathUtils.PI / 180;
MathUtils.degRad = MathUtils.degreesToRadians;
class Interpolation {
    apply(start, end, a) {
        return start + (end - start) * this.applyInternal(a);
    }
}
exports.Interpolation = Interpolation;
class Pow extends Interpolation {
    constructor(power) {
        super();
        this.power = 2;
        this.power = power;
    }
    applyInternal(a) {
        if (a <= 0.5)
            return Math.pow(a * 2, this.power) / 2;
        return Math.pow((a - 1) * 2, this.power) / (this.power % 2 === 0 ? -2 : 2) + 1;
    }
}
exports.Pow = Pow;
class PowOut extends Pow {
    // constructor(power: number) {
    //   super(power);
    // }
    applyInternal(a) {
        return Math.pow(a - 1, this.power) * (this.power % 2 === 0 ? -1 : 1) + 1;
    }
}
exports.PowOut = PowOut;
class Utils {
    static arrayCopy(source, sourceStart, dest, destStart, numElements) {
        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
            dest[j] = source[i];
        }
    }
    static arrayFill(array, fromIndex, toIndex, value) {
        for (let i = fromIndex; i < toIndex; i++)
            array[i] = value;
    }
    static setArraySize(array, size, value = 0) {
        let oldSize = array.length;
        if (oldSize === size)
            return array;
        array.length = size;
        if (oldSize < size) {
            for (let i = oldSize; i < size; i++)
                array[i] = value;
        }
        return array;
    }
    static ensureArrayCapacity(array, size, value = 0) {
        if (array.length >= size)
            return array;
        return Utils.setArraySize(array, size, value);
    }
    static newArray(size, defaultValue) {
        let array = new Array(size);
        for (let i = 0; i < size; i++)
            array[i] = defaultValue;
        return array;
    }
    static newFloatArray(size) {
        if (Utils.SUPPORTS_TYPED_ARRAYS)
            return new Float32Array(size);
        else {
            let array = new Array(size);
            for (let i = 0; i < array.length; i++)
                array[i] = 0;
            return array;
        }
    }
    static newShortArray(size) {
        if (Utils.SUPPORTS_TYPED_ARRAYS)
            return new Int16Array(size);
        else {
            let array = new Array(size);
            for (let i = 0; i < array.length; i++)
                array[i] = 0;
            return array;
        }
    }
    static toFloatArray(array) {
        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
    }
    static toSinglePrecision(value) {
        return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
    }
    static contains(array, element, identity = true) {
        for (var i = 0; i < array.length; i++)
            if (array[i] === element)
                return true;
        return false;
    }
    static enumValue(type, name) {
        return type[name[0].toUpperCase() + name.slice(1)];
    }
}
exports.Utils = Utils;
Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== 'undefined';
class Pool {
    constructor(instantiator) {
        this.items = new Array();
        if (instantiator) {
            this.instantiator = instantiator;
        }
        else {
            this.instantiator = () => ({});
        }
    }
    obtain() {
        const item = this.items.length > 0 ? this.items.pop() : this.instantiator();
        return item;
    }
    free(item) {
        if (item === null || item === void 0 ? void 0 : item.reset) {
            item.reset();
        }
        this.items.push(item);
    }
    freeAll(items) {
        for (let i = 0; i < items.length; i++)
            this.free(items[i]);
    }
    clear() {
        this.items.length = 0;
    }
}
exports.Pool = Pool;
class Pools {
    static free(name, object) {
        if (this.pools[name]) {
            this.pools[name].free(object);
        }
    }
    static freeAll(name, objects) {
        if (this.pools[name]) {
            this.pools[name].freeAll(objects);
        }
    }
    static get(name, instantiator) {
        if (this.pools[name]) {
            return this.pools[name];
        }
        this.pools[name] = new Pool(instantiator);
        return this.pools[name];
    }
    static set(name, pool) {
        this.pools[name] = pool;
    }
    static obtain(name, instantiator) {
        return this.get(name, instantiator).obtain();
    }
}
exports.Pools = Pools;
Pools.pools = {};
class TimeKeeper {
    constructor() {
        this.maxDelta = 0.064;
        this.framesPerSecond = 0;
        this.delta = 0;
        this.totalTime = 0;
        this.lastTime = Date.now() / 1000;
        this.frameCount = 0;
        this.frameTime = 0;
    }
    update() {
        let now = Date.now() / 1000;
        this.delta = now - this.lastTime;
        this.frameTime += this.delta;
        this.totalTime += this.delta;
        if (this.delta > this.maxDelta)
            this.delta = this.maxDelta;
        this.lastTime = now;
        this.frameCount++;
        if (this.frameTime > 1) {
            this.framesPerSecond = this.frameCount / this.frameTime;
            this.frameTime = 0;
            this.frameCount = 0;
        }
    }
}
exports.TimeKeeper = TimeKeeper;
class WindowedMean {
    constructor(windowSize = 32) {
        this.addedValues = 0;
        this.lastValue = 0;
        this.mean = 0;
        this.dirty = true;
        this.values = new Array(windowSize);
    }
    hasEnoughData() {
        return this.addedValues >= this.values.length;
    }
    addValue(value) {
        if (this.addedValues < this.values.length)
            this.addedValues++;
        this.values[this.lastValue++] = value;
        if (this.lastValue > this.values.length - 1)
            this.lastValue = 0;
        this.dirty = true;
    }
    getMean() {
        if (this.hasEnoughData()) {
            if (this.dirty) {
                let mean = 0;
                for (let i = 0; i < this.values.length; i++)
                    mean += this.values[i];
                this.mean = mean / this.values.length;
                this.dirty = false;
            }
            return this.mean;
        }
        return 0;
    }
}
exports.WindowedMean = WindowedMean;
const createGameLoop = (update) => {
    let lastUpdate = Date.now();
    let fps = 0;
    let running = true;
    let requestId;
    let frameInLastSecond = 0;
    let elapsed = 0;
    function loop() {
        if (running) {
            const delta = Date.now() - lastUpdate;
            lastUpdate = Date.now();
            frameInLastSecond++;
            elapsed += delta;
            if (elapsed >= 1000) {
                fps = frameInLastSecond;
                frameInLastSecond = 0;
                elapsed -= 1000;
            }
            requestId = requestAnimationFrame(loop);
            update(delta / 1000);
        }
    }
    loop();
    return {
        isRunning: () => running,
        start: () => {
            if (!running) {
                running = true;
                loop();
            }
        },
        stop: () => {
            if (requestId) {
                cancelAnimationFrame(requestId);
            }
            running = false;
        },
        getFps: () => fps
    };
};
exports.createGameLoop = createGameLoop;
const resizeCanvas = (canvas, deviceRatio) => {
    const devicePixelRatio = deviceRatio || window.devicePixelRatio || 1;
    const displayWidth = canvas.clientWidth * devicePixelRatio;
    const displayHeight = canvas.clientHeight * devicePixelRatio;
    if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
        canvas.width = displayWidth;
        canvas.height = displayHeight;
    }
    return [displayWidth, displayHeight];
};
exports.resizeCanvas = resizeCanvas;
const pointInRect = (pX, pY, x, y, width, height) => {
    return pX > x && pX < x + width && pY > y && pY < y + height;
};
exports.pointInRect = pointInRect;
const createStage = (options) => {
    const defaultOptions = {
        hidden: false,
        info: true
    };
    options = Object.assign(Object.assign({}, defaultOptions), options);
    const wrapper = document.createElement('div');
    wrapper.setAttribute('style', `position:fixed;top:0;left:0;right:0;bottom:0;`);
    if (options.wrapperClassName) {
        wrapper.className = options.wrapperClassName;
    }
    if (options.hidden) {
        wrapper.style.display = 'none';
    }
    const canvas = document.createElement('canvas');
    canvas.setAttribute('style', `width:100%;height:100%;`);
    const info = document.createElement('div');
    info.setAttribute('style', `position:absolute;top:1em;left:1em;color:white`);
    if (!options.info) {
        info.style.display = 'none';
    }
    wrapper.appendChild(canvas);
    wrapper.appendChild(info);
    document.body.appendChild(wrapper);
    return {
        getCanvas: () => canvas,
        getInfo: () => info,
        show: () => (wrapper.style.display = 'block'),
        hide: () => (wrapper.style.display = 'none'),
        cleanup: () => document.body.removeChild(wrapper)
    };
};
exports.createStage = createStage;
const copyArray = (src, target, targetOffset = 0, srcOffset = 0, count = target.length) => {
    for (let i = 0; i < count; i++) {
        target[targetOffset + i] = src[srcOffset + i];
    }
};
exports.copyArray = copyArray;
