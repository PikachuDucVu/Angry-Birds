"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlyphLayout = void 0;
const GlyphRun_1 = require("./GlyphRun");
const Utils_1 = require("./Utils");
class GlyphLayout {
    constructor(font, str, start, end, color, targetWidth, hAlign, wrap, truncate) {
        this.epsilon = 0.0001;
        this.glyphRunPool = Utils_1.Pools.get('GlyphRun', () => new GlyphRun_1.GlyphRun());
        this.colorStack = new Array(4);
        this.runs = [];
        this.colors = [];
        this.setText = (font, str, start, end, color, targetWidth, hAlign, wrap, truncate) => {
            this.reset();
            const fontData = font.data;
            if (start === end) {
                // Empty string.
                this.height = fontData.capHeight;
                return;
            }
            // Avoid wrapping one line per character, which is very inefficient.
            if (wrap)
                targetWidth = Math.max(targetWidth, fontData.spaceXadvance * 3);
            const wrapOrTruncate = wrap || truncate != null;
            let currentColor = color.toIntBits();
            let nextColor = currentColor;
            this.colors.shift();
            const markupEnabled = fontData.markupEnabled;
            if (markupEnabled)
                this.colorStack.push(currentColor);
            let isLastRun = false;
            let y = 0;
            let down = fontData.down;
            let lineRun = null; // Collects glyphs for the current line.
            let lastGlyph = null; // Last glyph of the previous run on the same line, used for kerning between runs.
            let runStart = start;
            while (true) {
                let runEnd;
                let newline = false;
                if (start === end) {
                    // End of text.
                    if (runStart === end)
                        break; // No run to process, we're done.
                    runEnd = end; // Process the final run.
                    isLastRun = true;
                }
                else {
                    // Each run is delimited by newline or left square bracket.
                    switch (str.charAt(start++)) {
                        case '\n': // End of line.
                            runEnd = start - 1;
                            newline = true;
                            break;
                        // Fall through.
                        default:
                            continue;
                    }
                }
                // eslint-disable-next-line no-labels
                runEnded: {
                    // Store the run that has ended.
                    const run = this.glyphRunPool.obtain();
                    run.x = 0;
                    run.y = y;
                    fontData.getGlyphs(run, str, runStart, runEnd, lastGlyph);
                    this.glyphCount += run.glyphs.length;
                    if (nextColor !== currentColor) {
                        // Can only be different if markupEnabled.
                        if (this.colors[this.colors.length - 2] === this.glyphCount) {
                            // Consecutive color changes, or after an empty run, or at the beginning of the string.
                            this.colors[this.colors.length - 1] = nextColor;
                        }
                        else {
                            this.colors.push(this.glyphCount);
                            this.colors.push(nextColor);
                        }
                        currentColor = nextColor;
                    }
                    if (run.glyphs.length === 0) {
                        this.glyphRunPool.free(run);
                        if (!lineRun)
                            break; // Otherwise wrap and truncate must still be processed for lineRun.
                    }
                    else if (!lineRun) {
                        lineRun = run;
                        this.runs.push(lineRun);
                    }
                    else {
                        lineRun.appendRun(run);
                        this.glyphRunPool.free(run);
                    }
                    if (newline || isLastRun) {
                        this.setLastGlyphXAdvance(fontData, lineRun);
                        lastGlyph = null;
                    }
                    else
                        lastGlyph = lineRun.glyphs[lineRun.glyphs.length - 1];
                    if (!wrapOrTruncate || lineRun.glyphs.length === 0) {
                        // eslint-disable-next-line no-labels
                        break runEnded; // No wrap or truncate, or no glyphs.
                    }
                    if (newline || isLastRun) {
                        // Wrap or truncate. First xadvance is the first glyph's X offset relative to the drawing position.
                        let runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.
                        for (let i = 2; i < lineRun.xAdvances.length; i++) {
                            const glyph = lineRun.glyphs[i - 1];
                            let glyphWidth = this.getGlyphWidth(glyph, fontData);
                            if (runWidth + glyphWidth - this.epsilon <= targetWidth) {
                                // Glyph fits.
                                runWidth += lineRun.xAdvances[i];
                                continue;
                            }
                            if (truncate != null) {
                                // Truncate.
                                this.truncate(fontData, lineRun, targetWidth, truncate);
                                break;
                            }
                            // Wrap.
                            let wrapIndex = fontData.getWrapIndex(lineRun.glyphs, i);
                            if ((wrapIndex === 0 && lineRun.x === 0) || // Require at least one glyph per line.
                                wrapIndex >= lineRun.glyphs.length) {
                                // Wrap at least the glyph that didn't fit.
                                wrapIndex = i - 1;
                            }
                            lineRun = this.wrap(fontData, lineRun, wrapIndex);
                            // eslint-disable-next-line no-labels
                            if (!lineRun)
                                break runEnded; // All wrapped glyphs were whitespace.
                            this.runs.push(lineRun);
                            y += down;
                            lineRun.x = 0;
                            lineRun.y = y;
                            // Start the wrap loop again, another wrap might be necessary.
                            runWidth = lineRun.xAdvances[0] + lineRun.xAdvances[1]; // At least the first glyph will fit.
                            i = 1;
                        }
                    }
                }
                if (newline) {
                    lineRun = null;
                    lastGlyph = null;
                    // Next run will be on the next line.
                    if (runEnd === runStart)
                        // Blank line.
                        y += down * fontData.blankLineScale;
                    else
                        y += down;
                }
                runStart = start;
            }
            this.height = fontData.capHeight + Math.abs(y);
            this.calculateWidths(fontData);
            this.alignRuns(targetWidth, hAlign);
            // Clear the color stack.
            if (markupEnabled)
                this.colorStack.length = 0;
        };
        this.calculateWidths = (fontData) => {
            var _a;
            let width = 0;
            const runsItems = [...this.runs];
            for (let i = 0, n = this.runs.length; i < n; i++) {
                const run = runsItems[i];
                const xAdvances = run.xAdvances;
                let runWidth = run.x + xAdvances[0];
                let max = 0; // run.x is needed to ensure floats are rounded same as above.
                const glyphs = run.glyphs;
                for (let ii = 0; ii < run.glyphs.length;) {
                    const glyph = glyphs[ii];
                    const glyphWidth = this.getGlyphWidth(glyph, fontData);
                    max = Math.max(max, runWidth + glyphWidth); // A glyph can extend past the right edge of subsequent glyphs.
                    ii++;
                    runWidth += (_a = xAdvances[ii]) !== null && _a !== void 0 ? _a : 0;
                }
                run.width = Math.max(runWidth, max) - run.x;
                width = Math.max(width, run.x + (isNaN(run.width) ? runWidth : run.width));
            }
            this.width = width;
        };
        this.alignRuns = (targetWidth, halign) => {
            if ((halign & Utils_1.Align.left) === 0) {
                // Not left aligned, so must be center or right aligned.
                const center = (halign & Utils_1.Align.center) !== 0;
                const runsItems = [...this.runs];
                for (let i = 0, n = this.runs.length; i < n; i++) {
                    const run = runsItems[i];
                    run.x += center ? 0.5 * (targetWidth - run.width) : targetWidth - run.width;
                }
            }
        };
        /** @param truncate May be empty string. */
        this.truncate = (fontData, run, targetWidth, truncate) => {
            let glyphCount = run.glyphs.length;
            // Determine truncate string size.
            const truncateRun = this.glyphRunPool.obtain();
            fontData.getGlyphs(truncateRun, truncate, 0, truncate.length, null);
            let truncateWidth = 0;
            if (truncateRun.xAdvances.length > 0) {
                this.setLastGlyphXAdvance(fontData, truncateRun);
                const xAdvances = truncateRun.xAdvances;
                // Skip first for tight bounds.
                for (let i = 1; i < truncateRun.xAdvances.length; i++) {
                    truncateWidth += xAdvances[i];
                }
            }
            targetWidth -= truncateWidth;
            // Determine visible glyphs.
            let count = 0;
            let width = run.x;
            const xAdvances = run.xAdvances;
            while (count < run.xAdvances.length) {
                const xAdvance = xAdvances[count];
                width += xAdvance;
                if (width > targetWidth)
                    break;
                count++;
            }
            if (count > 1) {
                // Some run glyphs fit, append truncate glyphs.
                if (count - 1 >= 0 && run.glyphs.length > count - 1) {
                    for (let i = count - 1; i < run.glyphs.length; i++) {
                        run.glyphs.splice(i, 1);
                    }
                }
                if (count >= 0 && run.xAdvances.length > count) {
                    for (let i = count; i < run.xAdvances.length; i++) {
                        run.xAdvances.splice(i, 1);
                    }
                }
                this.setLastGlyphXAdvance(fontData, run);
                if (truncateRun.xAdvances.length > 0) {
                    Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 1, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length - 1);
                }
            }
            else {
                // No run glyphs fit, use only truncate glyphs.
                run.glyphs.length = 0;
                run.xAdvances.length = 0;
                // run.xAdvances.addAll(truncateRun.xAdvances);
                Utils_1.Utils.arrayCopy(truncateRun.xAdvances, 0, run.xAdvances, run.xAdvances.length, truncateRun.xAdvances.length);
            }
            const droppedGlyphCount = glyphCount - run.glyphs.length;
            if (droppedGlyphCount > 0) {
                this.glyphCount -= droppedGlyphCount;
                if (fontData.markupEnabled) {
                    while (this.colors.length > 2 && this.colors[this.colors.length - 2] >= this.glyphCount)
                        this.colors.length -= 2;
                }
            }
            Utils_1.Utils.arrayCopy(truncateRun.glyphs, 0, run.glyphs, run.glyphs.length, truncateRun.glyphs.length);
            this.glyphCount += truncate.length;
            this.glyphRunPool.free(truncateRun);
        };
        /** Sets the xadvance of the last glyph to use its width instead of xadvance. */
        this.setLastGlyphXAdvance = (fontData, run) => {
            const last = run.glyphs[run.glyphs.length - 1];
            if (!last.fixedWidth)
                run.xAdvances[run.xAdvances.length - 1] = this.getGlyphWidth(last, fontData);
        };
        /** Returns the distance from the glyph's drawing position to the right edge of the glyph. */
        this.getGlyphWidth = (glyph, fontData) => {
            return (glyph.width + glyph.xoffset) * fontData.scaleX - fontData.padRight;
        };
        /** Returns an X offset for the first glyph so when drawn, none of it is left of the line's drawing position. */
        this.getLineOffset = (glyphs, fontData) => {
            return -glyphs[0].xoffset * fontData.scaleX - fontData.padLeft;
        };
        this.reset = () => {
            this.glyphRunPool.freeAll(this.runs);
            this.runs.length = 0;
            this.colors.length = 0;
            this.glyphCount = 0;
            this.width = 0;
            this.height = 0;
        };
        this.setText(font, str, start, end, color, targetWidth, hAlign, wrap, truncate);
    }
    /** Breaks a run into two runs at the specified wrapIndex.
     * @return May be null if second run is all whitespace. */
    wrap(fontData, first, wrapIndex) {
        const glyphCount = first.glyphs.length;
        let glyphs2 = first.glyphs; // Starts with all the glyphs.
        let xAdvances2 = first.xAdvances; // Starts with all the xadvances.
        // Skip whitespace before the wrap index.
        let firstEnd = wrapIndex;
        for (; firstEnd > 0; firstEnd--)
            if (!fontData.isWhitespace(glyphs2[firstEnd - 1].id))
                break;
        // Skip whitespace after the wrap index.
        let secondStart = wrapIndex;
        for (; secondStart < glyphCount; secondStart++)
            if (!fontData.isWhitespace(glyphs2[secondStart].id))
                break;
        // Copy wrapped glyphs and xadvances to second run.
        // The second run will contain the remaining glyph data, so swap instances rather than copying.
        let second;
        if (secondStart < glyphCount) {
            second = this.glyphRunPool.obtain();
            const glyphs1 = second.glyphs; // Starts empty.
            Utils_1.Utils.arrayCopy(glyphs2, 0, glyphs1, glyphs1.length, firstEnd);
            // glyphs2.removeRange(0, secondStart - 1);
            glyphs2.splice(0, secondStart - 1 + 1);
            first.glyphs = glyphs1;
            second.glyphs = glyphs2;
            const xAdvances1 = second.xAdvances; // Starts empty.
            Utils_1.Utils.arrayCopy(xAdvances2, 0, xAdvances1, xAdvances1.length, firstEnd + 1);
            // xAdvances2.removeRange(1, secondStart); // Leave first entry to be overwritten by next line.
            xAdvances2.splice(1, secondStart); // Leave first entry to be overwritten by next line.
            xAdvances2[0] = this.getLineOffset(glyphs2, fontData);
            first.xAdvances = xAdvances1;
            second.xAdvances = xAdvances2;
            const firstGlyphCount = first.glyphs.length; // After wrapping it.
            const secondGlyphCount = second.glyphs.length;
            const droppedGlyphCount = glyphCount - firstGlyphCount - secondGlyphCount;
            this.glyphCount -= droppedGlyphCount;
            if (fontData.markupEnabled && droppedGlyphCount > 0) {
                const reductionThreshold = this.glyphCount - secondGlyphCount;
                for (let i = this.colors.length - 2; i >= 2; i -= 2) {
                    // i >= 1 because first 2 values always determine the base color.
                    const colorChangeIndex = this.colors[i];
                    if (colorChangeIndex <= reductionThreshold)
                        break;
                    this.colors[i] = colorChangeIndex - droppedGlyphCount;
                }
            }
        }
        else {
            // Second run is empty, just trim whitespace glyphs from end of first run.
            glyphs2 = glyphs2.slice(0, firstEnd);
            xAdvances2 = xAdvances2.slice(0, firstEnd + 1);
            const droppedGlyphCount = secondStart - firstEnd;
            if (droppedGlyphCount > 0) {
                this.glyphCount -= droppedGlyphCount;
                if (fontData.markupEnabled && this.colors[this.colors.length - 2] > this.glyphCount) {
                    // Many color changes can be hidden in the dropped whitespace, so keep only the very last color entry.
                    const lastColor = this.colors[this.colors.length - 1];
                    while (this.colors[this.colors.length - 2] > this.glyphCount)
                        this.colors.length -= 2;
                    this.colors[this.colors.length - 2] = this.glyphCount; // Update color change index.
                    this.colors[this.colors.length - 1] = lastColor; // Update color entry.
                }
            }
        }
        if (firstEnd === 0) {
            // If the first run is now empty, remove it.
            this.glyphRunPool.free(first);
            this.runs.pop();
        }
        else
            this.setLastGlyphXAdvance(fontData, first);
        return second;
    }
}
exports.GlyphLayout = GlyphLayout;
