"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Shader = void 0;
const WebGL_1 = require("./WebGL");
class Shader {
    constructor(context, vertexShader, fragmentShader) {
        this.vertexShader = vertexShader;
        this.fragmentShader = fragmentShader;
        this.vs = null;
        this.fs = null;
        this.program = null;
        this.tmp2x2 = new Float32Array(2 * 2);
        this.tmp3x3 = new Float32Array(3 * 3);
        this.tmp4x4 = new Float32Array(4 * 4);
        this.vsSource = vertexShader;
        this.fsSource = fragmentShader;
        this.context =
            context instanceof WebGL_1.ManagedWebGLRenderingContext ? context : new WebGL_1.ManagedWebGLRenderingContext(context);
        this.context.addRestorable(this);
        this.compile();
    }
    getProgram() {
        return this.program;
    }
    getVertexShader() {
        return this.vertexShader;
    }
    getFragmentShader() {
        return this.fragmentShader;
    }
    getVertexShaderSource() {
        return this.vsSource;
    }
    getFragmentSource() {
        return this.fsSource;
    }
    compile() {
        let gl = this.context.gl;
        try {
            this.vs = this.compileShader(gl.VERTEX_SHADER, this.vertexShader);
            this.fs = this.compileShader(gl.FRAGMENT_SHADER, this.fragmentShader);
            this.program = this.compileProgram(this.vs, this.fs);
        }
        catch (e) {
            this.dispose();
            throw e;
        }
    }
    compileShader(type, source) {
        let gl = this.context.gl;
        let shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let error = "Couldn't compile shader: " + gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            if (!gl.isContextLost())
                throw new Error(error);
        }
        return shader;
    }
    compileProgram(vs, fs) {
        let gl = this.context.gl;
        let program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let error = "Couldn't compile shader program: " + gl.getProgramInfoLog(program);
            gl.deleteProgram(program);
            if (!gl.isContextLost())
                throw new Error(error);
        }
        return program;
    }
    restore() {
        this.compile();
    }
    bind() {
        this.context.gl.useProgram(this.program);
    }
    unbind() {
        this.context.gl.useProgram(null);
    }
    setUniformi(uniform, value) {
        this.context.gl.uniform1i(this.getUniformLocation(uniform), value);
    }
    setUniformf(uniform, value) {
        this.context.gl.uniform1f(this.getUniformLocation(uniform), value);
    }
    setUniform2f(uniform, value, value2) {
        this.context.gl.uniform2f(this.getUniformLocation(uniform), value, value2);
    }
    setUniform3f(uniform, value, value2, value3) {
        this.context.gl.uniform3f(this.getUniformLocation(uniform), value, value2, value3);
    }
    setUniform4f(uniform, value, value2, value3, value4) {
        this.context.gl.uniform4f(this.getUniformLocation(uniform), value, value2, value3, value4);
    }
    setUniform2x2f(uniform, value) {
        let gl = this.context.gl;
        this.tmp2x2.set(value);
        gl.uniformMatrix2fv(this.getUniformLocation(uniform), false, this.tmp2x2);
    }
    setUniform3x3f(uniform, value) {
        let gl = this.context.gl;
        this.tmp3x3.set(value);
        gl.uniformMatrix3fv(this.getUniformLocation(uniform), false, this.tmp3x3);
    }
    setUniform4x4f(uniform, value) {
        let gl = this.context.gl;
        this.tmp4x4.set(value);
        gl.uniformMatrix4fv(this.getUniformLocation(uniform), false, this.tmp4x4);
    }
    getUniformLocation(uniform) {
        let gl = this.context.gl;
        let location = gl.getUniformLocation(this.program, uniform);
        if (!location && !gl.isContextLost())
            throw new Error(`Couldn't find location for uniform ${uniform}`);
        return location;
    }
    getAttributeLocation(attribute) {
        let gl = this.context.gl;
        let location = gl.getAttribLocation(this.program, attribute);
        if (location === -1 && !gl.isContextLost())
            throw new Error(`Couldn't find location for attribute ${attribute}`);
        return location;
    }
    dispose() {
        this.context.removeRestorable(this);
        let gl = this.context.gl;
        if (this.vs) {
            gl.deleteShader(this.vs);
            this.vs = null;
        }
        if (this.fs) {
            gl.deleteShader(this.fs);
            this.fs = null;
        }
        if (this.program) {
            gl.deleteProgram(this.program);
            this.program = null;
        }
    }
    static newColoredTextured(context) {
        let vs = `
         attribute vec4 ${Shader.POSITION};
         attribute vec4 ${Shader.COLOR};
         attribute vec2 ${Shader.TEXCOORDS};
         uniform mat4 ${Shader.MVP_MATRIX};
         varying vec4 v_color;
         varying vec2 v_texCoords;
 
         void main () {
           v_color = ${Shader.COLOR};
           v_texCoords = ${Shader.TEXCOORDS};
           gl_Position = ${Shader.MVP_MATRIX} * ${Shader.POSITION};
         }
       `;
        let fs = `
         #ifdef GL_ES
           #define LOWP lowp
           precision mediump float;
         #else
           #define LOWP
         #endif
         varying LOWP vec4 v_color;
         varying vec2 v_texCoords;
         uniform sampler2D u_texture;
 
         void main () {
           gl_FragColor = v_color * texture2D(u_texture, v_texCoords);
         }
       `;
        return new Shader(context, vs, fs);
    }
    static newTwoColoredTextured(context) {
        let vs = `
         attribute vec4 ${Shader.POSITION};
         attribute vec4 ${Shader.COLOR};
         attribute vec4 ${Shader.COLOR2};
         attribute vec2 ${Shader.TEXCOORDS};
         uniform mat4 ${Shader.MVP_MATRIX};
         varying vec4 v_light;
         varying vec4 v_dark;
         varying vec2 v_texCoords;
 
         void main () {
           v_light = ${Shader.COLOR};
           v_dark = ${Shader.COLOR2};
           v_texCoords = ${Shader.TEXCOORDS};
           gl_Position = ${Shader.MVP_MATRIX} * ${Shader.POSITION};
         }
       `;
        let fs = `
         #ifdef GL_ES
           #define LOWP lowp
           precision mediump float;
         #else
           #define LOWP
         #endif
         varying LOWP vec4 v_light;
         varying LOWP vec4 v_dark;
         varying vec2 v_texCoords;
         uniform sampler2D u_texture;
 
         void main () {
           vec4 texColor = texture2D(u_texture, v_texCoords);
           gl_FragColor.a = texColor.a * v_light.a;
           gl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;
         }
       `;
        return new Shader(context, vs, fs);
    }
    static newColored(context) {
        let vs = `
         attribute vec4 ${Shader.POSITION};
         attribute vec4 ${Shader.COLOR};
         uniform mat4 ${Shader.MVP_MATRIX};
         varying vec4 v_color;
 
         void main () {
           v_color = ${Shader.COLOR};
           gl_Position = ${Shader.MVP_MATRIX} * ${Shader.POSITION};
         }
       `;
        let fs = `
         #ifdef GL_ES
           #define LOWP lowp
           precision mediump float;
         #else
           #define LOWP
         #endif
         varying LOWP vec4 v_color;
 
         void main () {
           gl_FragColor = v_color;
         }
       `;
        return new Shader(context, vs, fs);
    }
}
exports.Shader = Shader;
Shader.MVP_MATRIX = 'u_projTrans';
Shader.POSITION = 'a_position';
Shader.COLOR = 'a_color';
Shader.COLOR2 = 'a_color2';
Shader.TEXCOORDS = 'a_texCoords';
Shader.SAMPLER = 'u_texture';
