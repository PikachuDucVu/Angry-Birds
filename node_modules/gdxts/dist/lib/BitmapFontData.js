"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitmapFontData = void 0;
const Glyph_1 = require("./Glyph");
const Texture_1 = require("./Texture");
const TextureRegion_1 = require("./TextureRegion");
function concatAndResolveUrl(url, concat) {
    let url1 = url.split('/');
    let url2 = concat.split('/');
    let url3 = [];
    for (let i = 0, l = url1.length; i < l; i++) {
        if (url1[i] === '..') {
            url3.pop();
        }
        else if (url1[i] === '.') {
            continue;
        }
        else {
            url3.push(url1[i]);
        }
    }
    for (let i = 0, l = url2.length; i < l; i++) {
        if (url2[i] === '..') {
            url3.pop();
        }
        else if (url2[i] === '.') {
            continue;
        }
        else {
            url3.push(url2[i]);
        }
    }
    return url3.join('/');
}
const CHARACTER_MAX_VALUE = 65535;
class BitmapFontData {
    /** Creates an empty BitmapFontData for configuration before calling {@link #load(FileHandle, boolean)}, to subclass, or to
     * populate yourself, e.g. using stb-truetype or FreeType. */
    constructor(fontFile, flip) {
        /** The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of
         * the first line, the cap height can be used to get the location of the baseline. */
        this.capHeight = 1;
        /** Multiplier for the line height of blank lines. down * blankLineHeight is used as the distance to move down for a blank
         * line. */
        this.blankLineScale = 1;
        this.scaleX = 1;
        this.scaleY = 1;
        this.glyphs = {};
        /** The x-height, which is the distance from the top of most lowercase characters to the baseline. */
        this.xHeight = 1;
        this.xChars = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z'];
        this.capChars = [
            'M',
            'N',
            'B',
            'D',
            'C',
            'E',
            'F',
            'K',
            'A',
            'G',
            'H',
            'I',
            'J',
            'L',
            'O',
            'P',
            'Q',
            'R',
            'S',
            'T',
            'U',
            'V',
            'W',
            'X',
            'Y',
            'Z'
        ];
        this.loadFont = (gl) => __awaiter(this, void 0, void 0, function* () {
            if (this.imagePaths != null)
                return;
            let i = 0;
            let fileContent;
            const res = yield fetch(this.fontFile);
            fileContent = yield res.text();
            const lines = fileContent.split(/\r?\n/).map((s) => s.trim());
            try {
                let line = lines[i];
                if (typeof line !== 'string')
                    throw new Error('File is empty.');
                line = line.substring(line.indexOf('padding=') + 8);
                const padding = line.substring(0, line.indexOf(' ')).split(',', 4);
                if (padding.length !== 4)
                    throw new Error('Invalid padding.');
                this.padTop = parseInt(padding[0]);
                this.padRight = parseInt(padding[1]);
                this.padBottom = parseInt(padding[2]);
                this.padLeft = parseInt(padding[3]);
                const padY = this.padTop + this.padBottom;
                i++;
                line = lines[i];
                if (typeof line !== 'string')
                    throw new Error('Missing common header.');
                const common = line.split(' ', 9); // At most we want the 6th element; i.e. "page=N"
                // At least lineHeight and base are required.
                if (common.length < 3)
                    throw new Error('Invalid common header.');
                if (!common[1].startsWith('lineHeight='))
                    throw new Error('Missing: lineHeight');
                this.lineHeight = parseInt(common[1].substring(11));
                if (!common[2].startsWith('base='))
                    throw new Error('Missing: base');
                const baseLine = parseInt(common[2].substring(5));
                let pageCount = 1;
                if (common.length >= 6 && common[5] != null && common[5].startsWith('pages=')) {
                    try {
                        pageCount = Math.max(1, parseInt(common[5].substring(6)));
                    }
                    catch (_a) {
                        // Use one page.
                    }
                }
                this.imagePaths = new Array(pageCount);
                const imagePaths = [];
                // Read each page definition.
                for (let p = 0; p < pageCount; p++) {
                    // Read each "page" info line.
                    i++;
                    line = lines[i];
                    if (typeof line !== 'string')
                        throw new Error('Missing additional page definitions.');
                    // Expect ID to mean "index".
                    const idMatches = line.match(new RegExp('.*id=(\\d+)'));
                    if (idMatches && idMatches.length > 1) {
                        const id = idMatches[1];
                        try {
                            const pageID = parseInt(id);
                            if (pageID !== p)
                                throw new Error('Page IDs must be indices starting at 0: ' + id);
                        }
                        catch (_b) { }
                    }
                    const fileMatches = line.match(new RegExp('.*file="?([^"]+)"?'));
                    if (!fileMatches || fileMatches.length <= 1)
                        throw new Error('Missing: file');
                    const fileName = fileMatches[1];
                    imagePaths[p] = fileName;
                    // this.imagePaths[p] = fontFile.parent().child(fileName).path().replaceAll("\\\\", "/");
                }
                this.descent = 0;
                while (true) {
                    i++;
                    line = lines[i];
                    if (!line)
                        break; // EOF
                    if (line.startsWith('kernings '))
                        break; // Starting kernings block.
                    if (line.startsWith('metrics '))
                        break; // Starting metrics block.
                    if (!line.startsWith('char '))
                        continue;
                    const glyph = new Glyph_1.Glyph();
                    const tokens = new StringTokenizer(line, '=');
                    tokens.nextToken();
                    tokens.nextToken();
                    const ch = parseInt(tokens.nextToken());
                    if (ch > 0 && ch > CHARACTER_MAX_VALUE)
                        continue;
                    glyph.id = ch + '';
                    tokens.nextToken();
                    glyph.srcX = parseInt(tokens.nextToken());
                    tokens.nextToken();
                    glyph.srcY = parseInt(tokens.nextToken());
                    tokens.nextToken();
                    glyph.width = parseInt(tokens.nextToken());
                    tokens.nextToken();
                    glyph.height = parseInt(tokens.nextToken());
                    tokens.nextToken();
                    glyph.xoffset = parseInt(tokens.nextToken());
                    tokens.nextToken();
                    if (this.flipped)
                        glyph.yoffset = parseInt(tokens.nextToken());
                    else
                        glyph.yoffset = -(glyph.height + parseInt(tokens.nextToken()));
                    tokens.nextToken();
                    glyph.xadvance = parseInt(tokens.nextToken());
                    // Check for page safely, it could be omitted or invalid.
                    if (tokens.hasMoreTokens())
                        tokens.nextToken();
                    if (tokens.hasMoreTokens()) {
                        try {
                            glyph.page = parseInt(tokens.nextToken());
                        }
                        catch (_c) { }
                    }
                    if (glyph.width > 0 && glyph.height > 0)
                        this.descent = Math.min(baseLine + glyph.yoffset, this.descent);
                    if (ch <= 0) {
                        this.missingGlyph = glyph;
                    }
                    else if (ch <= CHARACTER_MAX_VALUE) {
                        this.setGlyph(ch, glyph);
                    }
                }
                this.descent += this.padBottom;
                while (true) {
                    i++;
                    line = lines[i];
                    if (typeof line !== 'string')
                        break;
                    if (!line.startsWith('kerning '))
                        break;
                    const tokens = new StringTokenizer(line, '=');
                    tokens.nextToken();
                    tokens.nextToken();
                    let first = parseInt(tokens.nextToken());
                    tokens.nextToken();
                    let second = parseInt(tokens.nextToken());
                    if (first < 0 || first > CHARACTER_MAX_VALUE || second < 0 || second > CHARACTER_MAX_VALUE)
                        continue;
                    const glyph = this.getGlyph(first + '');
                    tokens.nextToken();
                    const amount = parseInt(tokens.nextToken());
                    if (glyph) {
                        // Kernings may exist for glyph pairs not contained in the font.
                        glyph.setKerning(second, amount);
                    }
                }
                let hasMetricsOverride = false;
                let overrideAscent = 0;
                let overrideDescent = 0;
                let overrideDown = 0;
                let overrideCapHeight = 0;
                let overrideLineHeight = 0;
                let overrideSpaceXAdvance = 0;
                let overrideXHeight = 0;
                // Metrics override
                if (line != null && line.startsWith('metrics ')) {
                    hasMetricsOverride = true;
                    const tokens = new StringTokenizer(line, '=');
                    tokens.nextToken();
                    tokens.nextToken();
                    overrideAscent = parseFloat(tokens.nextToken());
                    tokens.nextToken();
                    overrideDescent = parseFloat(tokens.nextToken());
                    tokens.nextToken();
                    overrideDown = parseFloat(tokens.nextToken());
                    tokens.nextToken();
                    overrideCapHeight = parseFloat(tokens.nextToken());
                    tokens.nextToken();
                    overrideLineHeight = parseFloat(tokens.nextToken());
                    tokens.nextToken();
                    overrideSpaceXAdvance = parseFloat(tokens.nextToken());
                    tokens.nextToken();
                    overrideXHeight = parseFloat(tokens.nextToken());
                }
                let spaceGlyph = this.getGlyph('32');
                if (!spaceGlyph) {
                    spaceGlyph = new Glyph_1.Glyph();
                    spaceGlyph.id = '32';
                    let xadvanceGlyph = this.getGlyph('l');
                    if (!xadvanceGlyph)
                        xadvanceGlyph = this.getFirstGlyph();
                    spaceGlyph.xadvance = xadvanceGlyph.xadvance;
                    this.setGlyph(32, spaceGlyph); // space character ascii code
                }
                if (spaceGlyph.width === 0) {
                    spaceGlyph.width = this.padLeft + spaceGlyph.xadvance + this.padRight;
                    spaceGlyph.xoffset = -this.padLeft;
                }
                this.spaceXadvance = spaceGlyph.xadvance;
                let xGlyph;
                for (let i = 0; i < this.xChars.length; i++) {
                    xGlyph = this.getGlyph(this.xChars[i]);
                    if (xGlyph)
                        break;
                }
                if (!xGlyph)
                    xGlyph = this.getFirstGlyph();
                this.xHeight = xGlyph.height - padY;
                let capGlyph;
                for (let i = 0; i < this.capChars.length; i++) {
                    capGlyph = this.getGlyph(this.capChars[i]);
                    if (capGlyph)
                        break;
                }
                if (!capGlyph) {
                    const glyphValues = Object.values(this.glyphs);
                    for (let i = 0; i < glyphValues.length; i++) {
                        const page = glyphValues[i];
                        if (!page)
                            continue;
                        for (let j = 0; j < page.length; j++) {
                            if (!page[j] || page[j].height === 0 || page[j].width === 0)
                                continue;
                            this.capHeight = Math.max(this.capHeight, page[j].height);
                        }
                    }
                }
                else
                    this.capHeight = capGlyph.height;
                this.capHeight -= padY;
                this.ascent = baseLine - this.capHeight;
                this.down = -this.lineHeight;
                if (this.flipped) {
                    this.ascent = -this.ascent;
                    this.down = -this.down;
                }
                if (hasMetricsOverride) {
                    this.ascent = overrideAscent;
                    this.descent = overrideDescent;
                    this.down = overrideDown;
                    this.capHeight = overrideCapHeight;
                    this.lineHeight = overrideLineHeight;
                    this.spaceXadvance = overrideSpaceXAdvance;
                    this.xHeight = overrideXHeight;
                }
                // Generate texture regions
                const regionsData = [];
                const glyphValues = Object.values(this.glyphs);
                for (let i = 0; i < glyphValues.length; i++) {
                    const values = Object.values(glyphValues[i]);
                    for (let j = 0; j < values.length; j++) {
                        const region = {
                            id: values[j].id,
                            left: values[j].srcX,
                            top: values[j].srcY,
                            width: values[j].width,
                            height: values[j].height,
                            xoffset: values[j].xoffset,
                            yoffset: values[j].yoffset,
                            xadvance: values[j].xadvance,
                            page: imagePaths[values[j].page],
                            pageId: values[j].page
                        };
                        regionsData.push(region);
                    }
                }
                const pages = [];
                for (let i = 0; i < pageCount; i++) {
                    const texture = yield Texture_1.Texture.load(gl, concatAndResolveUrl(this.fontFile, `../${imagePaths[i]}`));
                    const invTexWidth = 1 / texture.width;
                    const invTexHeight = 1 / texture.height;
                    pages.push({
                        texture,
                        invTexWidth,
                        invTexHeight
                    });
                }
                this.regions = [];
                for (let regionData of regionsData) {
                    const left = regionData.left;
                    const top = regionData.top;
                    const width = regionData.width;
                    const height = regionData.height;
                    const { texture, invTexWidth, invTexHeight } = pages[regionData.pageId];
                    const region = new TextureRegion_1.TextureRegion(texture, left, top, width, height, regionData, invTexWidth, invTexHeight);
                    region.originalWidth = width;
                    region.originalHeight = height;
                    region.offsetX = 0;
                    region.offsetY = 0;
                    this.regions.push(region);
                }
            }
            catch (ex) {
                console.error(ex);
            }
        });
        this.setGlyphRegion = (glyph, region) => {
            const texture = region.texture;
            const invTexWidth = 1 / texture.width;
            const invTexHeight = 1 / texture.height;
            let offsetX = 0, offsetY = 0;
            const u = region.u;
            const v = region.v;
            const regionWidth = region.originalWidth;
            const regionHeight = region.originalHeight;
            // if (region instanceof AtlasRegion) {
            //    // Compensate for whitespace stripped from left and top edges.
            //    AtlasRegion atlasRegion = (AtlasRegion)region;
            //    offsetX = atlasRegion.offsetX;
            //    offsetY = atlasRegion.originalHeight - atlasRegion.packedHeight - atlasRegion.offsetY;
            // }
            let x = glyph.srcX;
            let x2 = glyph.srcX + glyph.width;
            let y = glyph.srcY;
            let y2 = glyph.srcY + glyph.height;
            // Shift glyph for left and top edge stripped whitespace. Clip glyph for right and bottom edge stripped whitespace.
            // Note if the font region has padding, whitespace stripping must not be used.
            if (offsetX > 0) {
                x -= offsetX;
                if (x < 0) {
                    glyph.width += x;
                    glyph.xoffset -= x;
                    x = 0;
                }
                x2 -= offsetX;
                if (x2 > regionWidth) {
                    glyph.width -= x2 - regionWidth;
                    x2 = regionWidth;
                }
            }
            if (offsetY > 0) {
                y -= offsetY;
                if (y < 0) {
                    glyph.height += y;
                    if (glyph.height < 0)
                        glyph.height = 0;
                    y = 0;
                }
                y2 -= offsetY;
                if (y2 > regionHeight) {
                    const amount = y2 - regionHeight;
                    glyph.height -= amount;
                    glyph.yoffset += amount;
                    y2 = regionHeight;
                }
            }
            glyph.u = u + x * invTexWidth;
            glyph.u2 = u + x2 * invTexWidth;
            if (this.flipped) {
                glyph.v = v + y * invTexHeight;
                glyph.v2 = v + y2 * invTexHeight;
            }
            else {
                glyph.v2 = v + y * invTexHeight;
                glyph.v = v + y2 * invTexHeight;
            }
        };
        /** Sets the line height, which is the distance from one line of text to the next. */
        this.setLineHeight = (height) => {
            this.lineHeight = height * this.scaleY;
            this.down = this.flipped ? this.lineHeight : -this.lineHeight;
        };
        this.setGlyph = (ch, glyph) => {
            let page = this.glyphs[ch / Glyph_1.PAGE_SIZE];
            if (!page) {
                page = new Array(Glyph_1.PAGE_SIZE);
                this.glyphs[ch / Glyph_1.PAGE_SIZE] = page;
                // this.glyphs[ch / PAGE_SIZE] = page = new Glyph[PAGE_SIZE];
            }
            page[ch & (Glyph_1.PAGE_SIZE - 1)] = glyph;
        };
        this.getFirstGlyph = () => {
            const glyphValues = Object.values(this.glyphs);
            for (let i = 0; i < glyphValues.length; i++) {
                const page = glyphValues[i];
                if (!page)
                    continue;
                for (let j = 0; j < page.length; j++) {
                    const glyph = page[j];
                    if (!glyph || glyph.height === 0 || glyph.width === 0)
                        continue;
                    return glyph;
                }
            }
        };
        /** Returns true if the font has the glyph, or if the font has a {@link #missingGlyph}. */
        this.hasGlyph = (ch) => {
            if (this.missingGlyph)
                return true;
            return this.getGlyph(ch) != null;
        };
        /** Returns the glyph for the specified character, or null if no such glyph exists. Note that
         * {@link #getGlyphs(GlyphRun, CharSequence, int, int, Glyph)} should be be used to shape a string of characters into a list
         * of glyphs. */
        this.getGlyph = (ch) => {
            const page = this.glyphs[ch.charCodeAt(0) / Glyph_1.PAGE_SIZE];
            if (page != null)
                return page[ch.charCodeAt(0) & (Glyph_1.PAGE_SIZE - 1)];
            return undefined;
        };
        /** Using the specified string, populates the glyphs and positions of the specified glyph run.
         * @param str Characters to convert to glyphs. Will not contain newline or color tags. May contain "[[" for an escaped left
         *           square bracket.
         * @param lastGlyph The glyph immediately before this run, or null if this is run is the first on a line of text. Used tp
         *           apply kerning between the specified glyph and the first glyph in this run. */
        this.getGlyphs = (run, str, start, end, lastGlyph) => {
            const max = end - start;
            if (max === 0)
                return;
            let markupEnabled = this.markupEnabled;
            const scaleX = this.scaleX;
            const glyphs = run.glyphs;
            const xAdvances = run.xAdvances;
            // Guess at number of glyphs needed.
            // glyphs.ensureCapacity(max);
            // run.xAdvances.ensureCapacity(max + 1);
            do {
                const ch = str.charAt(start++);
                if (ch === '\r')
                    continue; // Ignore.
                let glyph = this.getGlyph(ch);
                if (!glyph) {
                    if (!this.missingGlyph)
                        continue;
                    glyph = this.missingGlyph;
                }
                glyphs.push(glyph);
                xAdvances.push(!lastGlyph // First glyph on line, adjust the position so it isn't drawn left of 0.
                    ? glyph.fixedWidth
                        ? 0
                        : -glyph.xoffset * scaleX - this.padLeft
                    : (lastGlyph.xadvance + lastGlyph.getKerning(ch)) * scaleX);
                lastGlyph = glyph;
                // "[[" is an escaped left square bracket, skip second character.
                if (markupEnabled && ch === '[' && start < end && str.charAt(start) === '[')
                    start++;
            } while (start < end);
            if (lastGlyph) {
                const lastGlyphWidth = lastGlyph.fixedWidth
                    ? lastGlyph.xadvance * scaleX
                    : (lastGlyph.width + lastGlyph.xoffset) * scaleX - this.padRight;
                xAdvances.push(lastGlyphWidth);
            }
        };
        /** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and
         * (typically) moving toward the beginning of the glyphs array. */
        this.getWrapIndex = (glyphs, start) => {
            let i = start - 1;
            const glyphsItems = glyphs;
            let ch = glyphsItems[i].id;
            if (this.isWhitespace(ch + ''))
                return i;
            if (this.isBreakChar(ch + ''))
                i--;
            for (; i > 0; i--) {
                ch = glyphsItems[i].id;
                if (this.isWhitespace(ch + '') || this.isBreakChar(ch + '')) {
                    return i + 1;
                }
            }
            return 0;
        };
        this.isBreakChar = (c) => {
            if (!this.breakChars)
                return false;
            const character = String.fromCharCode(parseInt(c));
            for (let i = 0; i < this.breakChars.length; i++) {
                if (character === this.breakChars[i])
                    return true;
            }
            return false;
        };
        this.isWhitespace = (c) => {
            const character = String.fromCharCode(parseInt(c));
            switch (character) {
                case '\n':
                case '\r':
                case '\t':
                case ' ':
                    return true;
                default:
                    return false;
            }
        };
        /** Returns the image path for the texture page at the given index (the "id" in the BMFont file). */
        this.getImagePath = (index) => {
            return this.imagePaths[index];
        };
        this.getImagePaths = () => {
            return this.imagePaths;
        };
        /** Scales the font by the specified amounts on both axes
         * <p>
         * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}.
         * The default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.
         * @throws IllegalArgumentException if scaleX or scaleY is zero. */
        this.setScale = (scaleX, scaleY) => {
            if (scaleX === 0 || scaleY === 0)
                return;
            const x = scaleX / this.scaleX;
            const y = scaleY / this.scaleY;
            this.lineHeight *= y;
            this.spaceXadvance *= x;
            this.xHeight *= y;
            this.capHeight *= y;
            this.ascent *= y;
            this.descent *= y;
            this.down *= y;
            this.padLeft *= x;
            this.padRight *= x;
            this.padTop *= y;
            this.padBottom *= y;
            this.scaleX = scaleX;
            this.scaleY = scaleY;
        };
        /** Sets the font's scale relative to the current scale.
         * @see #setScale(float, float)
         * @throws IllegalArgumentException if the resulting scale is zero. */
        this.scale = (amount) => {
            this.setScale(this.scaleX + amount, this.scaleY + amount);
        };
        this.fontFile = fontFile;
        this.flipped = flip;
    }
    /** Scales the font by the specified amount in both directions.
     * @see #setScale(float, float)
     * @throws IllegalArgumentException if scaleX or scaleY is zero. */
    setXYScale(scaleXY) {
        this.setScale(scaleXY, scaleXY);
    }
}
exports.BitmapFontData = BitmapFontData;
class StringTokenizer {
    constructor(str, delimitter) {
        this.strArray = [];
        this.currentIndex = 0;
        const strings = str.split(/\s+/);
        for (let i = 0; i < strings.length; i++) {
            const st = strings[i];
            this.strArray.push(...st.split(delimitter));
        }
    }
    hasMoreTokens() {
        return this.currentIndex >= this.strArray.length;
    }
    nextToken() {
        return this.strArray[this.currentIndex++];
    }
}
