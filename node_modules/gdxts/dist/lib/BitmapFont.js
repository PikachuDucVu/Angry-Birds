"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitmapFont = void 0;
const BitmapFontCache_1 = require("./BitmapFontCache");
const BitmapFontData_1 = require("./BitmapFontData");
const Utils_1 = require("./Utils");
class BitmapFont {
    /** Constructs a new BitmapFont from the given {@link BitmapFontData} and array of {@link TextureRegion}. If the TextureRegion
     * is null or empty, the image path(s) will be read from the BitmapFontData. The dispose() method will not dispose the texture
     * of the region(s) if the regions array is != null and not empty.
     * @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */
    constructor(data, regions, integer) {
        this.load = (data) => {
            const glyphValues = Object.values(data.glyphs);
            for (let i = 0; i < glyphValues.length; i++) {
                const page = glyphValues[i];
                if (!page)
                    continue;
                for (let j = 0; j < page.length; j++) {
                    const glyph = page[j];
                    if (glyph) {
                        data.setGlyphRegion(glyph, this.regions[glyph.page]);
                    }
                }
            }
            if (data.missingGlyph != null)
                data.setGlyphRegion(data.missingGlyph, this.regions[data.missingGlyph.page]);
        };
        /** Draws text at the specified position.
         * @see BitmapFontCache#addText(CharSequence, float, float, int, int, float, int, boolean, String) */
        this.draw = (batch, str, x, y, targetWidth, halign = Utils_1.Align.left, wrap = true, start = 0, end = str.length, truncate) => {
            this.cache.clear();
            this.cache.addText(str, x, y, start, end, targetWidth, halign, wrap, truncate);
            this.cache.draw(batch);
        };
        /** Returns the color of text drawn with this font. */
        this.getColor = () => {
            return this.cache.getColor();
        };
        /** A convenience method for setting the font color. The color can also be set by modifying {@link #getColor()}. */
        // setColor = (r: number, g: number, b: number, a: number) => {
        //    this.cache.getColor().set(r, g, b, a);
        // };
        this.getScaleX = () => {
            return this.data.scaleX;
        };
        this.getScaleY = () => {
            return this.data.scaleY;
        };
        /** Returns the array of TextureRegions that represents each texture page of glyphs.
         * @return the array of texture regions; modifying it may produce undesirable results */
        this.getRegions = () => {
            return this.regions;
        };
        /** Returns the texture page at the given index.
         * @return the texture page at the given index */
        this.getRegion = (index) => {
            return this.regions[index];
        };
        /** Returns the line height, which is the distance from one line of text to the next. */
        this.getLineHeight = () => {
            return this.data.lineHeight;
        };
        /** Returns the x-advance of the space character. */
        this.getSpaceXadvance = () => {
            return this.data.spaceXadvance;
        };
        /** Returns the x-height, which is the distance from the top of most lowercase characters to the baseline. */
        this.getXHeight = () => {
            return this.data.xHeight;
        };
        /** Returns the cap height, which is the distance from the top of most uppercase characters to the baseline. Since the drawing
         * position is the cap height of the first line, the cap height can be used to get the location of the baseline. */
        this.getCapHeight = () => {
            return this.data.capHeight;
        };
        /** Returns the ascent, which is the distance from the cap height to the top of the tallest glyph. */
        this.getAscent = () => {
            return this.data.ascent;
        };
        /** Returns the descent, which is the distance from the bottom of the glyph that extends the lowest to the baseline. This
         * number is negative. */
        this.getDescent = () => {
            return this.data.descent;
        };
        /** Returns true if this BitmapFont has been flipped for use with a y-down coordinate system. */
        this.isFlipped = () => {
            return this.flipped;
        };
        /** Disposes the texture used by this BitmapFont's region IF this BitmapFont created the texture. */
        this.dispose = () => {
            if (this.ownsTexture) {
                for (let i = 0; i < this.regions.length; i++) {
                    this.regions[i].texture.dispose();
                }
            }
        };
        /** Makes the specified glyphs fixed width. This can be useful to make the numbers in a font fixed width. Eg, when horizontally
         * centering a score or loading percentage text, it will not jump around as different numbers are shown. */
        this.setFixedWidthGlyphs = (glyphs) => {
            const data = this.data;
            let maxAdvance = 0;
            for (let index = 0, end = glyphs.length; index < end; index++) {
                const g = data.getGlyph(glyphs.charAt(index));
                if (g != null && g.xadvance > maxAdvance)
                    maxAdvance = g.xadvance;
            }
            for (let index = 0, end = glyphs.length; index < end; index++) {
                const g = data.getGlyph(glyphs.charAt(index));
                if (!g)
                    continue;
                g.xoffset += (maxAdvance - g.xadvance) / 2;
                g.xadvance = maxAdvance;
                g.kerning = [];
                g.kerning = null;
                g.fixedWidth = true;
            }
        };
        /** Specifies whether to use integer positions. Default is to use them so filtering doesn't kick in as badly. */
        this.setUseIntegerPositions = (integer) => {
            this.integer = integer;
            this.cache.setUseIntegerPositions(integer);
        };
        /** Checks whether this font uses integer positions for drawing. */
        this.usesIntegerPositions = () => {
            return this.integer;
        };
        /** For expert usage -- returns the BitmapFontCache used by this font, for rendering to a sprite batch. This can be used, for
         * example, to manipulate glyph colors within a specific index.
         * @return the bitmap font cache used by this font */
        this.getCache = () => {
            return this.cache;
        };
        /** Gets the underlying {@link BitmapFontData} for this BitmapFont. */
        this.getData = () => {
            return this.data;
        };
        /** @return whether the texture is owned by the font, font disposes the texture itself if true */
        this.getOwnsTexture = () => {
            return this.ownsTexture;
        };
        /** Sets whether the font owns the texture. In case it does, the font will also dispose of the texture when {@link #dispose()}
         * is called. Use with care!
         * @param ownsTexture whether the font owns the texture */
        this.setOwnsTexture = (ownsTexture) => {
            this.ownsTexture = ownsTexture;
        };
        /** Creates a new BitmapFontCache for this font. Using this method allows the font to provide the BitmapFontCache
         * implementation to customize rendering.
         * <p>
         * Note this method is called by the BitmapFont constructors. If a subclass overrides this method, it will be called before the
         * subclass constructors. */
        this.newFontCache = () => {
            return new BitmapFontCache_1.BitmapFontCache(this, this.integer);
        };
        this.regions = regions;
        this.flipped = data.flipped;
        this.data = data;
        this.integer = integer;
        if (this.regions.length === 0) {
            console.log('No texture region were found');
            return;
        }
        else {
            this.ownsTexture = false;
        }
        this.cache = this.newFontCache();
        this.load(data);
    }
}
exports.BitmapFont = BitmapFont;
_a = BitmapFont;
BitmapFont.load = (gl, fontFile, flip = false, interger = false) => __awaiter(void 0, void 0, void 0, function* () {
    const fontData = new BitmapFontData_1.BitmapFontData(fontFile, flip);
    yield fontData.loadFont(gl);
    return new BitmapFont(fontData, fontData.regions, interger);
});
