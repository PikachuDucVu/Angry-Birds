"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextureAtlas = void 0;
const Texture_1 = require("./Texture");
const TextureRegion_1 = require("./TextureRegion");
function concatAndResolveUrl(url, concat) {
    let url1 = url.split('/');
    let url2 = concat.split('/');
    let url3 = [];
    for (let i = 0, l = url1.length; i < l; i++) {
        if (url1[i] === '..') {
            url3.pop();
        }
        else if (url1[i] === '.') {
            continue;
        }
        else {
            url3.push(url1[i]);
        }
    }
    for (let i = 0, l = url2.length; i < l; i++) {
        if (url2[i] === '..') {
            url3.pop();
        }
        else if (url2[i] === '.') {
            continue;
        }
        else {
            url3.push(url2[i]);
        }
    }
    return url3.join('/');
}
class TextureAtlas {
    constructor(pages, regions) {
        this.pages = pages;
        this.regions = regions;
    }
    dispose() {
        for (let page of this.pages) {
            page.dispose();
        }
    }
    getPages() {
        return this.pages;
    }
    getRegions() {
        return this.regions;
    }
    findRegion(name, index) {
        for (let i = 0; i < this.regions.length; i++) {
            let region = this.regions[i];
            if (region.name !== name)
                continue;
            if (index !== undefined && region.index !== index)
                continue;
            return region;
        }
        return null;
    }
    findRegions(name) {
        return this.regions.filter(region => region.name === name).sort((a, b) => a.index - b.index);
    }
    static load(gl, packFileUrl, textureOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const packFileContent = yield fetch(packFileUrl).then(res => res.text());
            const pageData = [];
            const pages = [];
            const regionsData = [];
            let pageImage;
            const lines = packFileContent.split(/\r?\n/);
            let i = 0;
            let tuple;
            while (true) {
                let line = lines[i];
                if (line === undefined) {
                    break;
                }
                if (line.trim().length === 0) {
                    pageImage = null;
                }
                else if (pageImage === null) {
                    const file = concatAndResolveUrl(packFileUrl, `../${line}`);
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    const width = parseInt(tuple[0], 10);
                    const height = parseInt(tuple[1], 10);
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    const format = tuple[0];
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    const [min, max] = tuple;
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    const direction = tuple[0];
                    let repeatX = Texture_1.TextureWrap.ClampToEdge;
                    let repeatY = Texture_1.TextureWrap.ClampToEdge;
                    if (direction === 'x') {
                        repeatX = Texture_1.TextureWrap.Repeat;
                    }
                    else if (direction === 'y') {
                        repeatY = Texture_1.TextureWrap.Repeat;
                    }
                    else if (direction === 'xy') {
                        repeatX = Texture_1.TextureWrap.Repeat;
                        repeatY = Texture_1.TextureWrap.Repeat;
                    }
                    const mipMaps = min !== 'Nearest' && min !== 'Linear';
                    pageImage = {
                        file,
                        width,
                        height,
                        format,
                        mipMaps,
                        min,
                        max,
                        direction,
                        repeatX,
                        repeatY
                    };
                    pageData.push(pageImage);
                }
                else {
                    const name = line;
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    const rotate = tuple[0] === 'true';
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    const left = parseInt(tuple[0], 10);
                    const top = parseInt(tuple[1], 10);
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    const width = parseInt(tuple[0], 10);
                    const height = parseInt(tuple[1], 10);
                    const region = {
                        name,
                        rotate,
                        left,
                        top,
                        width,
                        height,
                        page: pageImage
                    };
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    if (tuple.length === 4) {
                        region.splits = tuple.map(i => parseInt(i, 10));
                        i++;
                        line = lines[i];
                        tuple = line
                            .split(':')[1]
                            .split(',')
                            .map(s => s.trim());
                        if (tuple.length === 4) {
                            region.pads = tuple.map(i => parseInt(i, 10));
                            i++;
                            line = lines[i];
                            tuple = line
                                .split(':')[1]
                                .split(',')
                                .map(s => s.trim());
                        }
                    }
                    region.originalWidth = parseInt(tuple[0], 10);
                    region.originalHeight = parseInt(tuple[1], 10);
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    region.offsetX = parseInt(tuple[0], 10);
                    region.offsetY = parseInt(tuple[1], 10);
                    i++;
                    line = lines[i];
                    tuple = line
                        .split(':')[1]
                        .split(',')
                        .map(s => s.trim());
                    region.index = parseInt(tuple[0], 10);
                    regionsData.push(region);
                }
                i++;
            }
            for (let page of pageData) {
                page.texture = yield Texture_1.Texture.load(gl, page.file, textureOptions);
                page.invTexWidth = 1 / page.texture.width;
                page.invTexHeight = 1 / page.texture.height;
            }
            const regions = [];
            for (let regionData of regionsData) {
                const { left: x, top: y } = regionData;
                const width = regionData.rotate ? regionData.height : regionData.width;
                const height = regionData.rotate ? regionData.width : regionData.height;
                const { texture, invTexWidth, invTexHeight } = regionData.page;
                regions.push(new TextureRegion_1.TextureRegion(texture, x, y, width, height, regionData, invTexWidth, invTexHeight, regionData.rotate));
            }
            return new TextureAtlas(pages, regions);
        });
    }
}
exports.TextureAtlas = TextureAtlas;
