"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Color2Attribute = exports.ColorAttribute = exports.TexCoordAttribute = exports.Position3Attribute = exports.Position2Attribute = exports.VertexAttribute = exports.VertexAttributeType = exports.Mesh = void 0;
const Shader_1 = require("./Shader");
class Mesh {
    constructor(context, attributes, maxVertices, maxIndices) {
        this.attributes = attributes;
        this.verticesLength = 0;
        this.dirtyVertices = false;
        this.indicesLength = 0;
        this.dirtyIndices = false;
        this.elementsPerVertex = 0;
        this.context = context;
        this.elementsPerVertex = 0;
        for (let i = 0; i < attributes.length; i++) {
            this.elementsPerVertex += attributes[i].numElements;
        }
        this.vertices = new Float32Array(maxVertices * this.elementsPerVertex);
        this.indices = new Uint16Array(maxIndices);
    }
    getAttributes() {
        return this.attributes;
    }
    maxVertices() {
        return this.vertices.length / this.elementsPerVertex;
    }
    numVertices() {
        return this.verticesLength / this.elementsPerVertex;
    }
    setVerticesLength(length) {
        this.dirtyVertices = true;
        this.verticesLength = length;
    }
    getVertices() {
        return this.vertices;
    }
    maxIndices() {
        return this.indices.length;
    }
    numIndices() {
        return this.indicesLength;
    }
    setIndicesLength(length) {
        this.dirtyIndices = true;
        this.indicesLength = length;
    }
    getIndices() {
        return this.indices;
    }
    getVertexSizeInFloats() {
        let size = 0;
        for (var i = 0; i < this.attributes.length; i++) {
            let attribute = this.attributes[i];
            size += attribute.numElements;
        }
        return size;
    }
    setVertices(vertices) {
        this.dirtyVertices = true;
        if (vertices.length > this.vertices.length)
            throw Error("Mesh can't store more than " + this.maxVertices() + ' vertices');
        this.vertices.set(vertices, 0);
        this.verticesLength = vertices.length;
    }
    setIndices(indices) {
        this.dirtyIndices = true;
        if (indices.length > this.indices.length)
            throw Error("Mesh can't store more than " + this.maxIndices() + ' indices');
        this.indices.set(indices, 0);
        this.indicesLength = indices.length;
    }
    draw(shader, primitiveType) {
        this.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);
    }
    drawWithOffset(shader, primitiveType, offset, count) {
        let gl = this.context;
        if (this.dirtyVertices || this.dirtyIndices)
            this.update();
        this.bind(shader);
        if (this.indicesLength > 0) {
            gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);
        }
        else {
            gl.drawArrays(primitiveType, offset, count);
        }
        this.unbind(shader);
    }
    bind(shader) {
        let gl = this.context;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);
        let offset = 0;
        for (let i = 0; i < this.attributes.length; i++) {
            let attrib = this.attributes[i];
            let location = shader.getAttributeLocation(attrib.name);
            gl.enableVertexAttribArray(location);
            gl.vertexAttribPointer(location, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);
            offset += attrib.numElements;
        }
        if (this.indicesLength > 0)
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
    }
    unbind(shader) {
        let gl = this.context;
        for (let i = 0; i < this.attributes.length; i++) {
            let attrib = this.attributes[i];
            let location = shader.getAttributeLocation(attrib.name);
            gl.disableVertexAttribArray(location);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        if (this.indicesLength > 0)
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
    update() {
        let gl = this.context;
        if (this.dirtyVertices) {
            if (!this.verticesBuffer) {
                this.verticesBuffer = gl.createBuffer();
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);
            this.dirtyVertices = false;
        }
        if (this.dirtyIndices) {
            if (!this.indicesBuffer) {
                this.indicesBuffer = gl.createBuffer();
            }
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);
            this.dirtyIndices = false;
        }
    }
    restore() {
        this.verticesBuffer = null;
        this.indicesBuffer = null;
        this.update();
    }
    dispose() {
        let gl = this.context;
        gl.deleteBuffer(this.verticesBuffer);
        gl.deleteBuffer(this.indicesBuffer);
    }
}
exports.Mesh = Mesh;
var VertexAttributeType;
(function (VertexAttributeType) {
    VertexAttributeType[VertexAttributeType["Float"] = 0] = "Float";
})(VertexAttributeType = exports.VertexAttributeType || (exports.VertexAttributeType = {}));
class VertexAttribute {
    constructor(name, type, numElements) {
        this.name = name;
        this.type = type;
        this.numElements = numElements;
    }
}
exports.VertexAttribute = VertexAttribute;
class Position2Attribute extends VertexAttribute {
    constructor() {
        super(Shader_1.Shader.POSITION, VertexAttributeType.Float, 2);
    }
}
exports.Position2Attribute = Position2Attribute;
class Position3Attribute extends VertexAttribute {
    constructor() {
        super(Shader_1.Shader.POSITION, VertexAttributeType.Float, 3);
    }
}
exports.Position3Attribute = Position3Attribute;
class TexCoordAttribute extends VertexAttribute {
    constructor(unit = 0) {
        super(Shader_1.Shader.TEXCOORDS + (unit === 0 ? '' : unit), VertexAttributeType.Float, 2);
    }
}
exports.TexCoordAttribute = TexCoordAttribute;
class ColorAttribute extends VertexAttribute {
    constructor() {
        super(Shader_1.Shader.COLOR, VertexAttributeType.Float, 4);
    }
}
exports.ColorAttribute = ColorAttribute;
class Color2Attribute extends VertexAttribute {
    constructor() {
        super(Shader_1.Shader.COLOR2, VertexAttributeType.Float, 4);
    }
}
exports.Color2Attribute = Color2Attribute;
