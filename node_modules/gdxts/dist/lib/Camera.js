"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrthoCamera = void 0;
const Matrix4_1 = require("./Matrix4");
const Vector3_1 = require("./Vector3");
class OrthoCamera {
    constructor(viewportWidth, viewportHeight, screenWidth, screenHeight) {
        this.position = new Vector3_1.Vector3(0, 0, 0);
        this.direction = new Vector3_1.Vector3(0, 0, -1);
        this.up = new Vector3_1.Vector3(0, 1, 0);
        this.near = 0;
        this.far = 100;
        this.zoom = 1;
        this.viewportWidth = 0;
        this.viewportHeight = 0;
        this.projectionView = new Matrix4_1.Matrix4();
        this.inverseProjectionView = new Matrix4_1.Matrix4();
        this.projection = new Matrix4_1.Matrix4();
        this.view = new Matrix4_1.Matrix4();
        this.tmp3 = new Vector3_1.Vector3();
        this.resize(viewportWidth, viewportHeight, screenWidth, screenHeight);
    }
    setYDown(yDown) {
        if (yDown) {
            this.up.set(0, -1, 0);
            this.direction.set(0, 0, 1);
        }
        else {
            this.up.set(0, 1, 0);
            this.direction.set(0, 0, -1);
        }
        this.update();
    }
    resize(viewportWidth, viewportHeight, screenWidth, screenHeight) {
        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
        this.update();
    }
    setPosition(cameraX, cameraY) {
        this.position.set(cameraX, cameraY, this.position.z);
    }
    update() {
        let projection = this.projection;
        let view = this.view;
        let projectionView = this.projectionView;
        let inverseProjectionView = this.inverseProjectionView;
        let zoom = this.zoom, viewportWidth = this.viewportWidth, viewportHeight = this.viewportHeight;
        projection.ortho(zoom * (-viewportWidth / 2), zoom * (viewportWidth / 2), zoom * (-viewportHeight / 2), zoom * (viewportHeight / 2), this.near, this.far);
        view.lookAt(this.position, this.direction, this.up);
        projectionView.set(projection.values);
        projectionView.multiply(view);
        inverseProjectionView.set(projectionView.values).invert();
        this.combined = projectionView.values;
    }
    screenToWorld(screenCoords, screenWidth, screenHeight) {
        screenWidth = screenWidth || this.screenWidth;
        screenHeight = screenHeight || this.screenHeight;
        let x = screenCoords.x, y = screenHeight - screenCoords.y - 1;
        screenCoords.x = (2 * x) / screenWidth - 1;
        screenCoords.y = (2 * y) / screenHeight - 1;
        screenCoords.z = 2 * screenCoords.z - 1;
        screenCoords.project(this.inverseProjectionView);
        return screenCoords;
    }
    worldToScreen(worldCoords, screenWidth, screenHeight) {
        screenWidth = screenWidth || this.screenWidth;
        screenHeight = screenHeight || this.screenHeight;
        worldCoords.project(this.projectionView);
        worldCoords.x = (screenWidth * (worldCoords.x + 1)) / 2;
        worldCoords.y = (screenHeight * (worldCoords.y + 1)) / 2;
        worldCoords.z = (worldCoords.z + 1) / 2;
        return worldCoords;
    }
    unprojectVector2(worldCoord, screenCoord) {
        this.tmp3.set(screenCoord.x, screenCoord.y, 0);
        this.screenToWorld(this.tmp3);
        worldCoord.set(this.tmp3.x, this.tmp3.y);
    }
    setViewport(viewportWidth, viewportHeight) {
        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;
    }
}
exports.OrthoCamera = OrthoCamera;
