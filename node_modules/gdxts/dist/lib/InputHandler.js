"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputHandler = exports.InputEvent = void 0;
const events_1 = require("events");
const Vector2_1 = require("./Vector2");
var InputEvent;
(function (InputEvent) {
    InputEvent["TouchStart"] = "touchStart";
    InputEvent["TouchEnd"] = "touchEnd";
    InputEvent["TouchMove"] = "touchMove";
})(InputEvent = exports.InputEvent || (exports.InputEvent = {}));
class InputHandler {
    constructor(canvas) {
        this.screenCoord = new Vector2_1.Vector2();
        this.worldCoord = new Vector2_1.Vector2();
        this.canvas = canvas;
        this.lastX = 0;
        this.lastY = 0;
        this.touched = false;
        const emitter = (this.emitter = new events_1.EventEmitter());
        this.mouseDownHandler = evt => {
            this.touched = true;
            this.handleMove(evt);
            emitter.emit('touchStart', this.getX(), this.getY());
        };
        this.mouseUpHandler = evt => {
            this.touched = false;
            emitter.emit('touchEnd', this.getX(), this.getY());
        };
        this.mouseMoveHandler = evt => {
            this.handleMove(evt);
            emitter.emit('touchMove', this.getX(), this.getY());
        };
        this.touchStartHandler = evt => {
            evt.preventDefault();
            // TODO: handle multi touch
            let touch = evt.touches[0];
            this.canvas.dispatchEvent(new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            }));
        };
        this.touchEndHandler = evt => {
            evt.preventDefault();
            this.canvas.dispatchEvent(new MouseEvent('mouseup'));
        };
        this.touchMoveHandler = evt => {
            evt.preventDefault();
            let touch = evt.touches[0];
            this.canvas.dispatchEvent(new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            }));
        };
        this.canvas.addEventListener('mousedown', this.mouseDownHandler, false);
        this.canvas.addEventListener('mouseup', this.mouseUpHandler, false);
        this.canvas.addEventListener('mousemove', this.mouseMoveHandler, false);
        this.canvas.addEventListener('touchstart', this.touchStartHandler, false);
        this.canvas.addEventListener('touchend', this.touchEndHandler, false);
        this.canvas.addEventListener('touchmove', this.touchMoveHandler, false);
    }
    cleanup() {
        this.canvas.removeEventListener('mousedown', this.mouseDownHandler);
        this.canvas.removeEventListener('mouseup', this.mouseUpHandler);
        this.canvas.removeEventListener('mousemove', this.mouseMoveHandler);
        this.canvas.removeEventListener('touchstart', this.touchStartHandler);
        this.canvas.removeEventListener('touchend', this.touchEndHandler);
        this.canvas.removeEventListener('touchmove', this.touchMoveHandler);
    }
    addEventListener(event, listener) {
        this.emitter.addListener(event, listener);
    }
    handleMove(evt) {
        const rect = this.canvas.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;
        this.lastX = x;
        this.lastY = y;
    }
    getX() {
        return this.lastX;
    }
    getY() {
        return this.lastY;
    }
    isTouched() {
        return this.touched;
    }
    getTouchedWorldCoord(camera) {
        this.screenCoord.set(this.getX(), this.getY());
        camera.unprojectVector2(this.worldCoord, this.screenCoord);
        return this.worldCoord;
    }
}
exports.InputHandler = InputHandler;
