"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetManager = void 0;
const BitmapFont_1 = require("./BitmapFont");
const Texture_1 = require("./Texture");
const TextureAtlas_1 = require("./TextureAtlas");
class AssetManager {
    constructor(gl) {
        this.promises = [];
        this.atlases = new Map();
        this.textures = new Map();
        this.jsonData = new Map();
        this.binaryData = new Map();
        this.done = 0;
        this.listeners = [];
        this.fonts = new Map();
        this.gl = gl;
    }
    addListener(handler) {
        this.listeners.push(handler);
    }
    reportDone() {
        this.done++;
        for (const handler of this.listeners) {
            handler((this.done / this.getTotal()) * 100, this.done >= this.getTotal());
        }
    }
    loadAtlas(path, name) {
        const promise = TextureAtlas_1.TextureAtlas.load(this.gl, path, {}).then(atlas => {
            this.atlases.set(name, atlas);
            this.reportDone();
            return atlas;
        });
        this.promises.push(promise);
        return promise;
    }
    getAtlas(name) {
        return this.atlases.get(name);
    }
    loadJsonData(path, name) {
        const promise = fetch(path)
            .then(res => res.json())
            .then(json => {
            this.jsonData.set(name, json);
            this.reportDone();
            return json;
        });
        this.promises.push(promise);
        return promise;
    }
    getJsonData(name) {
        return this.jsonData.get(name);
    }
    loadBinaryData(path, name) {
        const promise = fetch(path)
            .then(res => res.arrayBuffer())
            .then(buffer => {
            this.binaryData.set(name, buffer);
            this.reportDone();
            return buffer;
        });
        this.promises.push(promise);
        return promise;
    }
    getBinaryData(name) {
        return this.binaryData.get(name);
    }
    loadFont(path, name, flip = false) {
        const promise = BitmapFont_1.BitmapFont.load(this.gl, path, flip).then(font => {
            this.fonts.set(name, font);
            this.reportDone();
            return font;
        });
        this.promises.push(promise);
        return promise;
    }
    getFont(name) {
        return this.fonts.get(name);
    }
    loadTexture(path, name) {
        const promise = Texture_1.Texture.load(this.gl, path).then(texture => {
            this.textures.set(name, texture);
            this.reportDone();
            return texture;
        });
        this.promises.push(promise);
        return promise;
    }
    getTexture(name) {
        return this.textures.get(name);
    }
    finishLoading() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this.promises);
        });
    }
    getDone() {
        return this.done;
    }
    getTotal() {
        return this.promises.length;
    }
    disposeAll() {
        const atlasKeys = [...this.atlases.keys()];
        atlasKeys.forEach(key => {
            var _a;
            const textureRegions = ((_a = this.atlases.get(key)) === null || _a === void 0 ? void 0 : _a.getRegions()) || [];
            textureRegions.forEach(texture => {
                var _a;
                (_a = texture.texture) === null || _a === void 0 ? void 0 : _a.destroy();
            });
            this.atlases.delete(key);
        });
        const localTextureKeys = [...this.textures.keys()];
        localTextureKeys.forEach(key => {
            var _a;
            (_a = this.textures.get(key)) === null || _a === void 0 ? void 0 : _a.destroy();
            this.textures.delete(key);
        });
        const fontMapKeys = [...this.fonts.keys()];
        fontMapKeys.forEach(key => {
            var _a;
            const textureRegions = ((_a = this.fonts.get(key)) === null || _a === void 0 ? void 0 : _a.getRegions()) || [];
            textureRegions.forEach(texture => {
                var _a;
                (_a = texture.texture) === null || _a === void 0 ? void 0 : _a.destroy();
            });
            this.fonts.delete(key);
        });
    }
}
exports.AssetManager = AssetManager;
exports.default = AssetManager;
