"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fastbitset_1 = __importDefault(require("fastbitset"));
const ComponentMapper_1 = require("./ComponentMapper");
class World {
    constructor() {
        this.index = 0;
        this.mappers = {};
        this.componentBitsMap = [];
        this.componentIndices = new Map();
        this.currentComponentIndex = 0;
        this.activeSystems = [];
        this.passiveSystems = [];
        this.injectionRegistry = {};
        this.delta = 0;
    }
    getNewId() {
        return this.index++;
    }
    createEntity() {
        const id = this.getNewId();
        return id;
    }
    getComponentBits(entityId) {
        if (!this.componentBitsMap[entityId]) {
            this.componentBitsMap[entityId] = new fastbitset_1.default();
        }
        return this.componentBitsMap[entityId];
    }
    getMapper(type) {
        const typeIndex = this.getComponentIndex(type);
        return this.getMapperByIndex(typeIndex);
    }
    getMapperByIndex(typeIndex) {
        if (!this.mappers[typeIndex]) {
            this.mappers[typeIndex] = new ComponentMapper_1.ComponentMapper();
        }
        return this.mappers[typeIndex];
    }
    getComponentIndex(type) {
        let index = this.componentIndices.get(type);
        if (index === undefined) {
            index = this.currentComponentIndex++;
            this.componentIndices.set(type, index);
        }
        return index;
    }
    createEntityByArchetype(archetype) {
        const id = this.getNewId();
        archetype.componentTypes.forEach(type => {
            const component = new type();
            if (!archetype.componentBitsInitialized) {
                archetype.componentBits.add(this.getComponentIndex(type));
            }
            this.addComponent(id, component, false);
        });
        this.componentBitsMap[id] = archetype.componentBits;
        return id;
    }
    addComponent(entityId, component, updateComponentBits = true) {
        const typeIndex = this.getComponentIndex(component.constructor);
        const mapper = this.getMapperByIndex(typeIndex);
        mapper.add(entityId, component);
        if (updateComponentBits)
            this.getComponentBits(entityId).add(typeIndex);
        return component;
    }
    getComponent(entityId, type) {
        const mapper = this.getMapper(type);
        return mapper.get(entityId);
    }
    getEntities(componentBits, iterator) {
        for (let i = 0; i < this.componentBitsMap.length; i++) {
            if (this.componentBitsMap[i]) {
                const entityComponentBits = this.componentBitsMap[i];
                if (componentBits.union_size(entityComponentBits) === entityComponentBits.size()) {
                    iterator(i);
                }
            }
        }
    }
    addSystem(system, active = true) {
        active ? this.activeSystems.push(system) : this.passiveSystems.push(system);
        system.setWorld(this);
        this.injectMapper(system);
        this.inject(system);
        system.initialized();
    }
    injectMapper(system) {
        const type = system.constructor;
        const injectPoints = type.__injectMapper__ || {};
        for (let injectKey in injectPoints) {
            const componentType = injectPoints[injectKey];
            system[injectKey] = this.getMapper(componentType);
        }
    }
    register(name, value) {
        this.injectionRegistry[name] = value;
    }
    inject(object) {
        const type = object.constructor;
        const injectPoints = type.__inject__ || {};
        for (let injectKey in injectPoints) {
            const injectName = injectPoints[injectKey];
            object[injectKey] = this.injectionRegistry[injectName];
        }
    }
    dispose() {
        for (let system of this.activeSystems) {
            system.dispose();
        }
        for (let system of this.passiveSystems) {
            system.dispose();
        }
    }
    setDelta(delta) {
        this.delta = delta;
    }
    processActiveSystem() {
        for (let system of this.activeSystems) {
            system.process();
        }
    }
    processPassiveSystem() {
        for (let system of this.passiveSystems) {
            system.process();
        }
    }
    deleteEntity(entityId) {
        for (let type in this.mappers) {
            this.mappers[type].remove(entityId);
        }
        delete this.componentBitsMap[entityId];
    }
    isEntityActive(entityId) {
        return !!this.componentBitsMap[entityId];
    }
}
exports.default = World;
